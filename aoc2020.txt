-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Development environment for Advent of Code challenges
--   
--   Scaffolding for an integrated development environment for Advent of
--   Code challenges. Includes auto-runner, prompt displays and countdowns,
--   and integrated submissions.
@package aoc2020
@version 0.1.0.0

module AOC.Common.Search

-- | A* Search
aStar :: forall n p. (Ord n, Ord p, Num p) => (n -> p) -> (n -> Map n p) -> n -> (n -> Bool) -> Maybe (p, [n])

-- | Breadth-first search, with loop detection
bfs :: forall n. Ord n => (n -> Set n) -> n -> (n -> Bool) -> Maybe [n]
binarySearch :: (Int -> Ordering) -> Int -> Int -> Maybe Int
exponentialSearch :: (Int -> Ordering) -> Int -> Maybe Int

-- | Find the lowest value where the predicate is satisfied within the
--   given bounds.
binaryMinSearch :: (Int -> Bool) -> Int -> Int -> Maybe Int

-- | Find the lowest value where the predicate is satisfied above a given
--   bound.
exponentialMinSearch :: (Int -> Bool) -> Int -> Maybe Int

-- | Find the lowest value where the predicate is <a>Just</a> within the
--   given bounds.
binaryFindMin :: (Int -> Maybe a) -> Int -> Int -> Maybe a

-- | Find the lowest value where the predicate is <a>Just</a> above a given
--   bound.
exponentialFindMin :: (Int -> Maybe a) -> Int -> Maybe a


-- | Utilities for loading configuration file.
module AOC.Run.Config

-- | Configuration for auto-runner.
data Config
Cfg :: Maybe String -> Integer -> Config

-- | Default: <a>Nothing</a>
[_cfgSession] :: Config -> Maybe String

-- | Default: 2015
[_cfgYear] :: Config -> Integer

-- | Load a <a>Config</a> from a given filepath.
configFile :: FilePath -> IO Config

-- | Default math to find a configuration file.
defConfPath :: FilePath

-- | Load a session token from the configuration file at a given filepath.
session :: FilePath -> IO (Maybe String)
instance GHC.Generics.Generic AOC.Run.Config.Config
instance Data.Default.Class.Default AOC.Run.Config.Config
instance Data.Aeson.Types.ToJSON.ToJSON AOC.Run.Config.Config
instance Data.Aeson.Types.FromJSON.FromJSON AOC.Run.Config.Config


-- | Assorted utility functions and orphans used for solutions.
module AOC.Util

-- | Strip trailing and leading whitespace.
strip :: String -> String

-- | Strip trailing newline
stripNewline :: String -> String

-- | Convert an <a>Either</a> into a <a>Maybe</a>, or any
--   <a>Alternative</a> instance, forgetting the error value.
eitherToMaybe :: Alternative m => Either e a -> m a

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
firstJust :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Convert a <a>Maybe</a> into an <a>Either</a>, or any <a>MonadError</a>
--   instance, by providing an error value in case <a>Nothing</a> was
--   given.
maybeToEither :: MonadError e m => e -> Maybe a -> m a

-- | Generalize a <a>Maybe</a> to any <a>Alternative</a>
maybeAlt :: Alternative m => Maybe a -> m a

-- | Like <a>traceShowId</a> but with an extra message
traceShowIdMsg :: Show a => String -> a -> a

-- | Like <a>traceShow</a> but with an extra message
traceShowMsg :: Show a => String -> a -> b -> b


-- | Common functions for solutions
module AOC.Common

-- | Iterate until a <a>Nothing</a> is produced
iterateMaybe :: (a -> Maybe a) -> a -> [a]

-- | Apply function until <a>Nothing</a> is produced, and return last
--   produced value.
loopMaybe :: (a -> Maybe a) -> a -> a

-- | Apply monadic function until <a>Nothing</a> is produced, and return
--   last produced value.
loopMaybeM :: Monad m => (a -> m (Maybe a)) -> a -> m a

-- | Apply function until a <a>Left</a>.
loopEither :: (a -> Either r a) -> a -> r

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
firstJust :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Strict (!!)
(!!!) :: [a] -> Int -> a
(!?) :: [a] -> Int -> Maybe a

-- | Strict drop
drop' :: Int -> [a] -> [a]

-- | A tuple of the same item twice
dup :: a -> (a, a)

-- | <a>scanl</a> generalized to all <a>Traversable</a>.
scanlT :: Traversable t => (b -> a -> b) -> b -> t a -> t b

-- | <a>scanr</a> generalized to all <a>Traversable</a>.
scanrT :: Traversable t => (a -> b -> b) -> b -> t a -> t b

-- | Lazily find the first repeated item.
firstRepeated :: Ord a => [a] -> Maybe a

-- | Repeat a function until you get the same result twice.
fixedPoint :: Eq a => (a -> a) -> a -> a

-- | Flood fill from a starting set
floodFill :: Ord a => (a -> Set a) -> Set a -> Set a

-- | Flood fill from a starting set, counting the number of steps
floodFillCount :: Ord a => (a -> Set a) -> Set a -> (Int, Set a)

-- | Count the number of items in a container where the predicate is true.
countTrue :: Foldable f => (a -> Bool) -> f a -> Int

-- | Build a frequency map
freqs :: (Foldable f, Ord a) => f a -> Map a Int

-- | Look up a count from a frequency map, defaulting to zero if item is
--   not foudn
lookupFreq :: Ord a => a -> Map a Int -> Int

-- | Build a list of <i>descending</i> frequencies. Ties are sorted.
freqList :: (Foldable f, Ord a) => f a -> [(Int, a)]

-- | Build a reverse frequency map
revFreq :: (Foldable f, Ord a) => f a -> IntMap (NESet a)

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbations :: (a -> [a]) -> [a] -> [[a]]

-- | each item paired with the list not including that item
select :: [a] -> [(a, [a])]

-- | Clear out characters not matching a predicate
clearOut :: (Char -> Bool) -> String -> String

-- | <a>foldMap</a>, but in parallel.
foldMapPar :: Monoid b => (a -> b) -> [a] -> b

-- | <a>foldMap1</a>, but in parallel.
foldMapPar1 :: Semigroup b => (a -> b) -> NonEmpty a -> b
foldMapParChunk :: (NFData m, Monoid m) => Int -> (a -> m) -> [a] -> m

-- | <a>Fold</a> for computing mean and variance
meanVar :: Fractional a => Fold a (a, a)

-- | Get the key-value pair corresponding to the maximum value in the map
maximumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the maximum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'maximumVal' == 'maximumValBy' 'compare'
--   </pre>
maximumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map
minimumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'minimumVal' == 'minimumValBy' 'compare'
--   </pre>
minimumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Version of <a>maximumVal</a> for nonempty maps.
maximumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>maximumValBy</a> for nonempty maps.
maximumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>minimumVal</a> for nonempty maps.
minimumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>minimumValBy</a> for nonempty maps.
minimumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)
listTup :: [a] -> Maybe (a, a)
_ListTup :: Prism' [a] (a, a)
listTup3 :: [a] -> Maybe (a, a, a)
_ListTup3 :: Prism' [a] (a, a, a)
listTup4 :: [a] -> Maybe (a, a, a, a)
_ListTup4 :: Prism' [a] (a, a, a, a)

-- | Delete a potential value from a <a>Finite</a>.
deleteFinite :: KnownNat n => Finite (n + 1) -> Finite (n + 1) -> Maybe (Finite n)
type Letter = Finite 26

-- | Parse a letter into a number 0 to 25. Returns <a>False</a> if
--   lowercase and <a>True</a> if uppercase.
charFinite :: Char -> Maybe (Bool, Finite 26)

-- | Prism for a <a>Char</a> as <tt>(<a>Bool</a>, <a>Finite</a> 26)</tt>,
--   where the <a>Finite</a> is the letter parsed as a number from 0 to 25,
--   and the <a>Bool</a> is lowercase (<a>False</a>) or uppercase
--   (<a>True</a>).
_CharFinite :: Prism' Char (Bool, Finite 26)
hexDigit :: Prism' Char (Finite 16)
decimalDigit :: Prism' Char (Finite 10)
splitWord :: Word8 -> (Finite 16, Finite 16)
digitToIntSafe :: Char -> Maybe Int

-- | Caeser shift, preserving case. If you have an <a>Int</a> or
--   <a>Integer</a>, convert into <a>Finite</a> using <a>modulo</a>.
caeser :: Finite 26 -> Char -> Char
eitherItem :: Lens' (Either a a) a
getDown :: Down a -> a
toNatural :: Integral a => a -> Maybe Natural

-- | Use a stream of tokens <tt>a</tt> as the underlying parser stream.
--   Note that error messages for parser errors are going necessarily to be
--   wonky.
newtype TokStream a
TokStream :: [a] -> TokStream a
[getTokStream] :: TokStream a -> [a]

-- | Parse a stream of tokens <tt>s</tt> purely, returning <a>Either</a>
parseTokStream :: Foldable t => Parsec e (TokStream s) a -> t s -> Either (ParseErrorBundle (TokStream s) e) a

-- | Parse a stream of tokens <tt>s</tt> purely
parseTokStream_ :: (Alternative m, Foldable t) => Parsec e (TokStream s) a -> t s -> m a

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad,
--   returning <a>Either</a>
parseTokStreamT :: (Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (Either (ParseErrorBundle (TokStream s) e) a)

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad
parseTokStreamT_ :: (Alternative f, Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (f a)

-- | Skip every result until this token matches
nextMatch :: MonadParsec e s m => m a -> m a
parseMaybeLenient :: Parsec e s a -> s -> Maybe a
parseOrFail :: (Stream s, ShowErrorComponent e) => Parsec e s a -> s -> a
type CharParser = Parsec Void String
parseLines :: Parsec e String a -> String -> Maybe [a]

-- | 2D Coordinate
type Point = V2 Int
cardinalNeighbs :: Point -> [Point]
cardinalNeighbsSet :: Point -> Set Point
fullNeighbs :: Point -> [Point]
fullNeighbsSet :: Point -> Set Point
mannDist :: (Foldable f, Num a, Num (f a)) => f a -> f a -> a

-- | Treat as complex number multiplication. useful for rotations
mulPoint :: Point -> Point -> Point

-- | Lattice points for line between points, not including endpoints
lineTo :: Point -> Point -> [Point]
data Dir
North :: Dir
East :: Dir
South :: Dir
West :: Dir
parseDir :: Char -> Maybe Dir
dirPoint :: Dir -> Point

-- | <a>dirPoint</a> but with inverted y axis
dirPoint' :: Dir -> Point

-- | Multiply headings, taking North as straight, East as clockwise turn,
--   West as counter-clockwise turn, and South as reverse.
--   
--   Should be a commutative group; it's essentially complex number
--   multiplication like <a>mulPoint</a>, with North = 1, West = i. The
--   identity is <a>North</a> and the inverse is the opposite direction.
mulDir :: Dir -> Dir -> Dir
memoPoint :: Memo Point

-- | Find the minimum and maximum x and y from a collection of points.
--   
--   Returns <tt><a>V2</a> (V2 xMin yMin) (V2 xMax yMax)</tt>.
boundingBox :: (Foldable1 f, Applicative g, Ord a) => f (g a) -> V2 (g a)

-- | A version of <a>boundingBox</a> that works for normal possibly-empty
--   lists.
boundingBox' :: Foldable f => f Point -> Maybe (V2 Point)
parseAsciiMap :: (Char -> Maybe a) -> String -> Map Point a
parseAsciiSet :: (Char -> Bool) -> String -> Set Point

-- | It's <a>Point</a>, but with a newtype wrapper so we have an <a>Ord</a>
--   that sorts by y first, then x
newtype ScanPoint
SP :: Point -> ScanPoint
[_getSP] :: ScanPoint -> Point
displayAsciiMap :: Char -> Map Point Char -> String
instance GHC.Base.Functor AOC.Common.TokStream
instance GHC.Generics.Generic (AOC.Common.TokStream a)
instance GHC.Show.Show a => GHC.Show.Show (AOC.Common.TokStream a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (AOC.Common.TokStream a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (AOC.Common.TokStream a)
instance GHC.Generics.Generic AOC.Common.ScanPoint
instance GHC.Num.Num AOC.Common.ScanPoint
instance GHC.Show.Show AOC.Common.ScanPoint
instance GHC.Classes.Eq AOC.Common.ScanPoint
instance GHC.Enum.Enum AOC.Common.Dir
instance GHC.Generics.Generic AOC.Common.Dir
instance GHC.Classes.Ord AOC.Common.Dir
instance GHC.Classes.Eq AOC.Common.Dir
instance GHC.Show.Show AOC.Common.Dir
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (AOC.Common.TokStream a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (AOC.Common.TokStream a)
instance (GHC.Classes.Ord a, GHC.Show.Show a) => Text.Megaparsec.Stream.Stream (AOC.Common.TokStream a)
instance Data.Hashable.Class.Hashable AOC.Common.ScanPoint
instance Control.DeepSeq.NFData AOC.Common.ScanPoint
instance GHC.Classes.Ord AOC.Common.ScanPoint
instance Data.Hashable.Class.Hashable AOC.Common.Dir
instance Control.DeepSeq.NFData AOC.Common.Dir
instance GHC.Base.Semigroup AOC.Common.Dir
instance GHC.Base.Monoid AOC.Common.Dir
instance Data.Group.Group AOC.Common.Dir
instance Data.Group.Abelian AOC.Common.Dir
instance (Control.Lens.At.Ixed (v a), Control.Lens.At.Index (v a) GHC.Types.~ GHC.Types.Int, Control.Lens.At.IxValue (v a) GHC.Types.~ a) => Control.Lens.At.Ixed (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord p) => Control.Lens.At.Ixed (Data.OrdPSQ.Internal.OrdPSQ k p v)
instance Control.Lens.Indexed.FunctorWithIndex k (Data.Map.NonEmpty.Internal.NEMap k)
instance Control.Lens.Indexed.FoldableWithIndex k (Data.Map.NonEmpty.Internal.NEMap k)
instance Control.Lens.Indexed.TraversableWithIndex k (Data.Map.NonEmpty.Internal.NEMap k)

module AOC.Common.OCR
parseLetters :: Set Point -> String
parseLettersSafe :: Set Point -> Maybe String
parseLettersAll :: Set Point -> NonEmpty String

-- | The set of unconnected shapes, indexed by their original center of
--   mass
contiguousShapes :: Set Point -> Map (V2 Double) (NESet Point)

module AOC.Util.DynoMap
newtype DynoMap
Dyno :: Map String Dynamic -> DynoMap
[runDyno] :: DynoMap -> Map String Dynamic

-- | Lookup the value at a given key in a <a>Dyno</a>.
--   
--   <pre>
--   lookupDyno "hello"
--   </pre>
lookupDyno :: forall a. Typeable a => String -> DynoMap -> Maybe a

-- | Like <a>lookupDyno</a>, but with a default value to be returned if the
--   key is not found or has the wrong type.
lookupDynoWith :: forall a. Typeable a => String -> a -> DynoMap -> a
instance GHC.Base.Monoid AOC.Util.DynoMap.DynoMap
instance GHC.Base.Semigroup AOC.Util.DynoMap.DynoMap


-- | Types to drive the challenge runner and help speed up/clean up
--   solutions.
module AOC.Solver

-- | Abstracting over the type of a challenge solver to help with cleaner
--   solutions.
--   
--   A <tt>a <a>:~&gt;</a> b</tt> encapsulates something that solves a
--   challenge with input type <tt>a</tt> into a response of type
--   <tt>b</tt>.
--   
--   Consists of a parser, a shower, and a solver. The solver solves a
--   general <tt>a -&gt; <a>Maybe</a> b</tt> function, and the parser and
--   shower are used to handle the boilerplate of parsing and printing the
--   solution.
data a :~> b
MkSol :: (String -> Maybe a) -> ((?dyno :: DynoMap) => a -> Maybe b) -> (b -> String) -> (:~>) a b

-- | parse input into an <tt>a</tt>
[sParse] :: (:~>) a b -> String -> Maybe a

-- | solve an <tt>a</tt> input to a <tt>b</tt> solution
[sSolve] :: (:~>) a b -> (?dyno :: DynoMap) => a -> Maybe b

-- | print out the <tt>b</tt> solution in a pretty way
[sShow] :: (:~>) a b -> b -> String

-- | Construct a <a>:~&gt;</a> from a <tt>String -&gt; <a>Maybe</a>
--   String</tt> solver, which might fail. Does no parsing or special
--   printing treatment.
withSolver :: (String -> Maybe String) -> String :~> String

-- | Construct a <a>:~&gt;</a> from just a normal <tt>String -&gt;
--   String</tt> solver. Does no parsing or special printing treatment.
withSolver' :: (String -> String) -> String :~> String

-- | Wrap an <tt>a <a>:~&gt;</a> b</tt> and hide the type variables so we
--   can put different solutions in a container.
data SomeSolution
[MkSomeSolWH] :: (a :~> b) -> SomeSolution
[MkSomeSolNF] :: (NFData a, NFData b) => (a :~> b) -> SomeSolution

-- | Handy pattern to work with both <a>MkSomeSolWH</a> and
--   <a>MkSomeSolNF</a>. As a constructor, just uses <a>MkSomeSolWH</a>, so
--   might not be desirable.
pattern MkSomeSol :: () => forall a b. () => (a :~> b) -> SomeSolution

-- | Errors that might happen when running a <a>:~&gt;</a> on some input.
data SolutionError
SEParse :: SolutionError
SESolve :: SolutionError

-- | Run a <a>:~&gt;</a> on some input.
runSolution :: (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input.
runSomeSolution :: SomeSolution -> String -> Either SolutionError String

-- | Check if a <a>SomeSolution</a> is equipped with an <a>NFData</a>
--   instance on the types
ssIsNF :: SomeSolution -> Bool

-- | Run a <a>:~&gt;</a> on some input, with a map of dynamic values for
--   testing
runSolutionWith :: Map String Dynamic -> (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input, with a map of dynamic values
--   for testing
runSomeSolutionWith :: Map String Dynamic -> SomeSolution -> String -> Either SolutionError String

-- | From a <tt>?dyno</tt> Implicit Params, look up a value at a given key.
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno' @"hello"
--   </pre>
--   
--   This can be used within the body of <a>sSolve</a>, since it will
--   always be called with the implicit parameter.
--   
--   When called on actual puzzle input, result will always be
--   <a>Nothing</a>. But, for some test inputs, there might be supplied
--   values.
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> Maybe a

-- | A version of <a>dyno</a> taking a default value in case the key is not
--   in the map. When called on actual puzzle input, this is always
--   <a>id</a>. However, for some test inputs, there might be supplied
--   values.
--   
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno_' @"hello" 7
--   </pre>
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno_ :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> a -> a
instance GHC.Generics.Generic AOC.Solver.SolutionError
instance GHC.Classes.Ord AOC.Solver.SolutionError
instance GHC.Classes.Eq AOC.Solver.SolutionError
instance GHC.Show.Show AOC.Solver.SolutionError
instance Control.DeepSeq.NFData AOC.Solver.SolutionError


-- | Custom Prelude while developing challenges. Ideally, once challenges
--   are completed, an import to this module would be replaced with
--   explicit ones for future readers.
module AOC.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(min(m,n))</i>. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | <i>O(n)</i>. <a>map</a> <tt>f xs</tt> is the list obtained by applying
--   <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <a>elem</a> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <a>!!</a> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <a>length</a> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class Ord a => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i>Purity</i> <tt><a>mfix</a> (<a>return</a> . h) = <a>return</a>
--   (<a>fix</a> h)</tt></li>
--   <li><i>Left shrinking (or Tightening)</i> <tt><a>mfix</a> (\x -&gt; a
--   &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y -&gt; <a>mfix</a> (\x -&gt;
--   f x y)</tt></li>
--   <li><i>Sliding</i> <tt><a>mfix</a> (<a>liftM</a> h . f) = <a>liftM</a>
--   h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i>Nesting</i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y -&gt; f x
--   y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class Monad m => MonadFix (m :: Type -> Type)

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | A variant of <a>foldMap</a> that is strict in the accumulator.
foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <tt>O(n)</tt>
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The kind of types with values. For example <tt>Int :: Type</tt>.
type Type = Type

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | Use <tt><a>Option</a> (<a>First</a> a)</tt> to get the behavior of
--   <a>First</a> from <a>Data.Monoid</a>.
newtype First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Use <tt><a>Option</a> (<a>Last</a> a)</tt> to get the behavior of
--   <a>Last</a> from <a>Data.Monoid</a>
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | <i>O(1)</i>. Extract the first element of a list, which must be
--   non-empty.
head :: [a] -> a

-- | <i>O(1)</i>. Extract the elements after the head of a list, which must
--   be non-empty.
tail :: [a] -> [a]

-- | <i>O(n)</i>. Extract the last element of a list, which must be finite
--   and non-empty.
last :: [a] -> a

-- | <i>O(n)</i>. Return all the elements of a list except the last one.
--   The list must be non-empty.
init :: [a] -> [a]

-- | <i>O(n)</i>. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <i>O(n)</i>. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <i>O(n)</i>. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <i>O(min(m,n))</i>. <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
isUpper :: Char -> Bool

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | <i>O(min(m,n))</i>. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
nub :: Eq a => [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | <i>O(n)</i>. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <a>Error</a> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | A set of values <tt>a</tt>.
data Set a

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a> argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The <a>Const</a> functor.
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]
newtype WrappedArrow (a :: Type -> Type -> Type) b c
WrapArrow :: a b c -> WrappedArrow (a :: Type -> Type -> Type) b c
[unwrapArrow] :: WrappedArrow (a :: Type -> Type -> Type) b c -> a b c
newtype WrappedMonad (m :: Type -> Type) a
WrapMonad :: m a -> WrappedMonad (m :: Type -> Type) a
[unwrapMonad] :: WrappedMonad (m :: Type -> Type) a -> m a

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | <i>O(n)</i>. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant (f :: Type -> Type)
contramap :: Contravariant f => (a -> b) -> f b -> f a

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a
zonedTimeToUTC :: ZonedTime -> UTCTime

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime
UTCTime :: Day -> DiffTime -> UTCTime

-- | the day
[utctDay] :: UTCTime -> Day

-- | the time from midnight, 0 &lt;= t &lt; 86401s (because of
--   leap-seconds)
[utctDayTime] :: UTCTime -> DiffTime

-- | This is a length of time, as measured by UTC. It has a precision of
--   10^-12 s.
--   
--   Conversion functions will treat it as seconds. For example, <tt>(0.010
--   :: NominalDiffTime)</tt> corresponds to 10 milliseconds.
--   
--   It ignores leap-seconds, so it's not necessarily a fixed amount of
--   clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime =
--   01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.
data NominalDiffTime

-- | A local time together with a time zone.
--   
--   There is no <a>Eq</a> instance for <tt>ZonedTime</tt>. If you want to
--   compare local times, use <a>zonedTimeToLocalTime</a>. If you want to
--   compare absolute times, use <a>zonedTimeToUTC</a>.
data ZonedTime
ZonedTime :: LocalTime -> TimeZone -> ZonedTime
[zonedTimeToLocalTime] :: ZonedTime -> LocalTime
[zonedTimeZone] :: ZonedTime -> TimeZone

-- | Finite number type. <tt><a>Finite</a> n</tt> is inhabited by exactly
--   <tt>n</tt> values. Invariants:
--   
--   <pre>
--   getFinite x &lt; natVal x
--   </pre>
--   
--   <pre>
--   getFinite x &gt;= 0
--   </pre>
data Finite (n :: Nat)
unsafeCoerce :: a -> b

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
vacuous :: Functor f => f Void -> f a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | Uninhabited data type
data Void

-- | Fold an <a>Option</a> case-wise, just like <a>maybe</a>.
option :: b -> (a -> b) -> Option a -> b

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
data Arg a b
Arg :: a -> b -> Arg a b
type ArgMin a b = Min Arg a b
type ArgMax a b = Max Arg a b

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>.
--   
--   In GHC 8.4 and higher, the <a>Monoid</a> instance for <a>Maybe</a> has
--   been corrected to lift a <a>Semigroup</a> instance instead of a
--   <a>Monoid</a> instance. Consequently, this type is no longer useful.
--   It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Calls <a>perror</a> to indicate that there is a type error or similar
--   in the given argument.
errorBadArgument :: a

-- | Calls <a>perror</a> to indicate that there is a missing argument in
--   the argument list.
errorMissingArgument :: a

-- | Calls <a>perror</a> to indicate that the format string ended early.
errorShortFormat :: a

-- | Calls <a>perror</a> to indicate an unknown format letter for a given
--   type.
errorBadFormat :: Char -> a

-- | Raises an <a>error</a> with a printf-specific prefix on the message
--   string.
perror :: String -> a

-- | Formatter for <a>RealFloat</a> values.
formatRealFloat :: RealFloat a => a -> FieldFormatter

-- | Formatter for <a>Integer</a> values.
formatInteger :: Integer -> FieldFormatter

-- | Formatter for <a>Int</a> values.
formatInt :: (Integral a, Bounded a) => a -> FieldFormatter

-- | Formatter for <a>String</a> values.
formatString :: IsChar a => [a] -> FieldFormatter

-- | Formatter for <a>Char</a> values.
formatChar :: Char -> FieldFormatter

-- | Substitute a 'v' format character with the given default format
--   character in the <a>FieldFormat</a>. A convenience for
--   user-implemented types, which should support "%v".
vFmt :: Char -> FieldFormat -> FieldFormat

-- | Similar to <a>printf</a>, except that output is via the specified
--   <a>Handle</a>. The return type is restricted to <tt>(<a>IO</a>
--   a)</tt>.
hPrintf :: HPrintfType r => Handle -> String -> r

-- | Format a variable number of arguments with the C-style formatting
--   string.
--   
--   <pre>
--   &gt;&gt;&gt; printf "%s, %d, %.4f" "hello" 123 pi
--   hello, 123, 3.1416
--   </pre>
--   
--   The return value is either <a>String</a> or <tt>(<a>IO</a> a)</tt>
--   (which should be <tt>(<a>IO</a> ())</tt>, but Haskell's type system
--   makes this hard).
--   
--   The format string consists of ordinary characters and <i>conversion
--   specifications</i>, which specify how to format one of the arguments
--   to <a>printf</a> in the output string. A format specification is
--   introduced by the <tt>%</tt> character; this character can be
--   self-escaped into the format string using <tt>%%</tt>. A format
--   specification ends with a <i>format character</i> that provides the
--   primary information about how to format the value. The rest of the
--   conversion specification is optional. In order, one may have flag
--   characters, a width specifier, a precision specifier, and
--   type-specific modifier characters.
--   
--   Unlike C <tt>printf(3)</tt>, the formatting of this <a>printf</a> is
--   driven by the argument type; formatting is type specific. The types
--   formatted by <a>printf</a> "out of the box" are:
--   
--   <ul>
--   <li><a>Integral</a> types, including <a>Char</a></li>
--   <li><a>String</a></li>
--   <li><a>RealFloat</a> types</li>
--   </ul>
--   
--   <a>printf</a> is also extensible to support other types: see below.
--   
--   A conversion specification begins with the character <tt>%</tt>,
--   followed by zero or more of the following flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   +      always use a sign (+ or -) for signed conversions
--   space  leading space for positive numbers in signed conversions
--   0      pad with zeros rather than spaces
--   #      use an \"alternate form\": see below
--   </pre>
--   
--   When both flags are given, <tt>-</tt> overrides <tt>0</tt> and
--   <tt>+</tt> overrides space. A negative width specifier in a <tt>*</tt>
--   conversion is treated as positive but implies the left adjust flag.
--   
--   The "alternate form" for unsigned radix conversions is as in C
--   <tt>printf(3)</tt>:
--   
--   <pre>
--   %o           prefix with a leading 0 if needed
--   %x           prefix with a leading 0x if nonzero
--   %X           prefix with a leading 0X if nonzero
--   %b           prefix with a leading 0b if nonzero
--   %[eEfFgG]    ensure that the number contains a decimal point
--   </pre>
--   
--   Any flags are followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   The field width is a minimum, not a maximum: it will be expanded as
--   needed to avoid mutilating a value.
--   
--   Any field width is followed optionally by a precision:
--   
--   <pre>
--   .num   precision
--   .      same as .0
--   .*     as num, but taken from argument list
--   </pre>
--   
--   Negative precision is taken as 0. The meaning of the precision depends
--   on the conversion type.
--   
--   <pre>
--   Integral    minimum number of digits to show
--   RealFloat   number of digits after the decimal point
--   String      maximum number of characters
--   </pre>
--   
--   The precision for Integral types is accomplished by zero-padding. If
--   both precision and zero-pad are given for an Integral field, the
--   zero-pad is ignored.
--   
--   Any precision is followed optionally for Integral types by a width
--   modifier; the only use of this modifier being to set the implicit size
--   of the operand for conversion of a negative operand to unsigned:
--   
--   <pre>
--   hh     Int8
--   h      Int16
--   l      Int32
--   ll     Int64
--   L      Int64
--   </pre>
--   
--   The specification ends with a format character:
--   
--   <pre>
--   c      character               Integral
--   d      decimal                 Integral
--   o      octal                   Integral
--   x      hexadecimal             Integral
--   X      hexadecimal             Integral
--   b      binary                  Integral
--   u      unsigned decimal        Integral
--   f      floating point          RealFloat
--   F      floating point          RealFloat
--   g      general format float    RealFloat
--   G      general format float    RealFloat
--   e      exponent format float   RealFloat
--   E      exponent format float   RealFloat
--   s      string                  String
--   v      default format          any type
--   </pre>
--   
--   The "%v" specifier is provided for all built-in types, and should be
--   provided for user-defined type formatters as well. It picks a "best"
--   representation for the given type. For the built-in types the "%v"
--   specifier is converted as follows:
--   
--   <pre>
--   c      Char
--   u      other unsigned Integral
--   d      other signed Integral
--   g      RealFloat
--   s      String
--   </pre>
--   
--   Mismatch between the argument types and the format string, as well as
--   any other syntactic or semantic errors in the format string, will
--   cause an exception to be thrown at runtime.
--   
--   Note that the formatting for <a>RealFloat</a> types is currently a bit
--   different from that of C <tt>printf(3)</tt>, conforming instead to
--   <a>showEFloat</a>, <a>showFFloat</a> and <a>showGFloat</a> (and their
--   alternate versions <a>showFFloatAlt</a> and <a>showGFloatAlt</a>).
--   This is hard to fix: the fixed versions would format in a
--   backward-incompatible way. In any case the Haskell behavior is
--   generally more sensible than the C behavior. A brief summary of some
--   key differences:
--   
--   <ul>
--   <li>Haskell <a>printf</a> never uses the default "6-digit" precision
--   used by C printf.</li>
--   <li>Haskell <a>printf</a> treats the "precision" specifier as
--   indicating the number of digits after the decimal point.</li>
--   <li>Haskell <a>printf</a> prints the exponent of e-format numbers
--   without a gratuitous plus sign, and with the minimum possible number
--   of digits.</li>
--   <li>Haskell <a>printf</a> will place a zero after a decimal point when
--   possible.</li>
--   </ul>
printf :: PrintfType r => String -> r

-- | The <a>PrintfType</a> class provides the variable argument magic for
--   <a>printf</a>. Its implementation is intentionally not visible from
--   this module. If you attempt to pass an argument of a type which is not
--   an instance of this class to <a>printf</a> or <a>hPrintf</a>, then the
--   compiler will report it as a missing instance of <a>PrintfArg</a>.
class PrintfType t

-- | The <a>HPrintfType</a> class provides the variable argument magic for
--   <a>hPrintf</a>. Its implementation is intentionally not visible from
--   this module.
class HPrintfType t

-- | Typeclass of <a>printf</a>-formattable values. The <a>formatArg</a>
--   method takes a value and a field format descriptor and either fails
--   due to a bad descriptor or produces a <a>ShowS</a> as the result. The
--   default <a>parseFormat</a> expects no modifiers: this is the normal
--   case. Minimal instance: <a>formatArg</a>.
class PrintfArg a

formatArg :: PrintfArg a => a -> FieldFormatter

parseFormat :: PrintfArg a => a -> ModifierParser

-- | This class, with only the one instance, is used as a workaround for
--   the fact that <a>String</a>, as a concrete type, is not allowable as a
--   typeclass instance. <a>IsChar</a> is exported for
--   backward-compatibility.
class IsChar c

toChar :: IsChar c => c -> Char

fromChar :: IsChar c => Char -> c

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign

-- | Description of field formatting for <a>formatArg</a>. See UNIX
--   <tt>printf(3)</tt> for a description of how field formatting works.
data FieldFormat
FieldFormat :: Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat

-- | Total width of the field.
[fmtWidth] :: FieldFormat -> Maybe Int

-- | Secondary field width specifier.
[fmtPrecision] :: FieldFormat -> Maybe Int

-- | Kind of filling or padding to be done.
[fmtAdjust] :: FieldFormat -> Maybe FormatAdjustment

-- | Whether to insist on a plus sign for positive numbers.
[fmtSign] :: FieldFormat -> Maybe FormatSign

-- | Indicates an "alternate format". See <tt>printf(3)</tt> for the
--   details, which vary by argument spec.
[fmtAlternate] :: FieldFormat -> Bool

-- | Characters that appeared immediately to the left of <a>fmtChar</a> in
--   the format and were accepted by the type's <a>parseFormat</a>.
--   Normally the empty string.
[fmtModifiers] :: FieldFormat -> String

-- | The format character <a>printf</a> was invoked with. <a>formatArg</a>
--   should fail unless this character matches the type. It is normal to
--   handle many different format characters for a single type.
[fmtChar] :: FieldFormat -> Char

-- | The "format parser" walks over argument-type-specific modifier
--   characters to find the primary format character. This is the type of
--   its result.
data FormatParse
FormatParse :: String -> Char -> String -> FormatParse

-- | Any modifiers found.
[fpModifiers] :: FormatParse -> String

-- | Primary format character.
[fpChar] :: FormatParse -> Char

-- | Rest of the format string.
[fpRest] :: FormatParse -> String

-- | This is the type of a field formatter reified over its argument.
type FieldFormatter = FieldFormat -> ShowS

-- | Type of a function that will parse modifier characters from the format
--   string.
type ModifierParser = String -> FormatParse

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: String -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: String -> a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: String -> a -> a

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <a>MonadIO</a>, <tt><a>liftIO</a> .
--   <a>traceIO</a></tt> may be a better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow (x,y) (x + y) in f (1+2) 5
--   (3,5)
--   8
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   "hello
--   hello"
--   </pre>
traceId :: String -> String

putTraceMsg :: String -> IO ()

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: Traversable t => (a -> b) -> t a -> t b

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | A slightly faster version of <a>fixIO</a> that may not be safe to use
--   with multiple threads. The unsafety arises when used like this:
--   
--   <pre>
--   unsafeFixIO $ \r -&gt; do
--      forkIO (print r)
--      return (...)
--   </pre>
--   
--   In this case, the child thread will receive a <tt>NonTermination</tt>
--   exception instead of waiting for the value of <tt>r</tt> to be
--   computed.
unsafeFixIO :: (a -> IO a) -> IO a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>.
stimesIdempotent :: Integral b => b -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | <i>O(n)</i>. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | <i>O(n)</i>. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
genericLength :: Num i => [a] -> i

-- | <i>O(n)</i>. The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | <i>O(n)</i>. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,2,3,4] `intersect` [6,4,4,2]
--   [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | <i>O(n)</i>. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | <i>O(min(m,n))</i>. The <a>stripPrefix</a> function drops the given
--   prefix from a list. It returns <a>Nothing</a> if the list did not
--   start with the prefix given, or <a>Just</a> the list after the prefix,
--   if it does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall k (a :: k). a :~: a
infix 4 :~:

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Selects lower-case alphabetic Unicode characters (letters).
isLower :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It ensures that the result of each application of force to weak head
--   normal form before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <i>O(n)</i>. A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | <i>O(1)</i>. Decompose a list into its head and tail. If the list is
--   empty, returns <a>Nothing</a>. If the list is non-empty, returns
--   <tt><a>Just</a> (x, xs)</tt>, where <tt>x</tt> is the head of the list
--   and <tt>xs</tt> its tail.
uncons :: [a] -> Maybe (a, [a])

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: HasCallStack => Maybe a -> a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
unsafePerformIO :: IO a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s (m :: Type -> Type) a
[runStateT] :: StateT s (m :: Type -> Type) a -> s -> m (a, s)

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | A map of integers to values <tt>a</tt>.
data IntMap a

-- | The <tt>nubIntOn</tt> function behaves just like <a>nubInt</a> except
--   it performs comparisons not on the original datatype, but a
--   user-specified projection from that datatype. For example,
--   <tt>nubIntOn <a>fromEnum</a></tt> can be used to nub characters and
--   typical fixed-with numerical types efficiently.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubIntOn</tt> is strict in the values of the function applied to
--   the elements of the list.
nubIntOn :: (a -> Int) -> [a] -> [a]

-- | &lt;math&gt;. The <tt>nubInt</tt> function removes duplicate
--   <a>Int</a> values from a list. In particular, it keeps only the first
--   occurrence of each element. By using an <a>IntSet</a> internally, it
--   attains better asymptotics than the standard <a>nub</a> function.
--   
--   See also <a>nubIntOn</a>, a more widely applicable generalization.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubInt</tt> is strict in the elements of the list.
nubInt :: [Int] -> [Int]

-- | The <tt>nubOrdOn</tt> function behaves just like <a>nubOrd</a> except
--   it performs comparisons not on the original datatype, but a
--   user-specified projection from that datatype.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubOrdOn</tt> is strict in the values of the function applied to
--   the elements of the list.
nubOrdOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <tt>nubOrd</tt> function removes duplicate elements
--   from a list. In particular, it keeps only the first occurrence of each
--   element. By using a <a>Set</a> internally it has better asymptotics
--   than the standard <a>nub</a> function.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubOrd</tt> is strict in the elements of the list.
--   
--   <h4>Efficiency note</h4>
--   
--   When applicable, it is almost always better to use <a>nubInt</a> or
--   <a>nubIntOn</a> instead of this function, although it can be a little
--   worse in certain pathological cases. For example, to nub a list of
--   characters, use
--   
--   <pre>
--   nubIntOn fromEnum xs
--   </pre>
nubOrd :: Ord a => [a] -> [a]

-- | A set of integers.
data IntSet

-- | This is a length of time, as measured by a clock. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s.
data DiffTime

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf2 :: (NFData2 p, NFData a, NFData b) => p a b -> ()

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf1 :: (NFData1 f, NFData a) => f a -> ()

-- | Reduce to weak head normal form
--   
--   Equivalent to <tt>\x -&gt; <a>seq</a> x ()</tt>.
--   
--   Useful for defining <a>NFData</a> for types for which NF=WHNF holds.
--   
--   <pre>
--   data T = C1 | C2 | C3
--   instance NFData T where rnf = rwhnf
--   </pre>
rwhnf :: a -> ()

-- | Deeply strict version of <a>&lt;$&gt;</a>.
(<$!!>) :: (Monad m, NFData b) => (a -> b) -> m a -> m b
infixl 4 <$!!>

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | A class of functors that can be fully evaluated.
class NFData1 (f :: Type -> Type)

-- | <a>liftRnf</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given an argument to reduce
--   <tt>a</tt> arguments, and then return <tt>()</tt>.
--   
--   See <a>rnf</a> for the generic deriving.
liftRnf :: NFData1 f => (a -> ()) -> f a -> ()

-- | A class of bifunctors that can be fully evaluated.
class NFData2 (p :: Type -> Type -> Type)

-- | <a>liftRnf2</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given functions to reduce
--   <tt>a</tt> and <tt>b</tt> arguments respectively, and then return
--   <tt>()</tt>.
--   
--   <b>Note</b>: Unlike for the unary <a>liftRnf</a>, there is currently
--   no support for generically deriving <a>liftRnf2</a>.
liftRnf2 :: NFData2 p => (a -> ()) -> (b -> ()) -> p a b -> ()

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Produce the <a>Finite</a> that is congruent to the given integer
--   modulo <tt>n</tt>.
modulo :: forall (n :: Nat). KnownNat n => Integer -> Finite n

-- | Generate a list of length <tt>n</tt> of all elements of
--   <tt><a>Finite</a> n</tt>.
finites :: forall (n :: Nat). KnownNat n => [Finite n]

-- | Convert an <a>Integer</a> into a <a>Finite</a>, returning
--   <a>Nothing</a> if the input is out of bounds.
packFinite :: forall (n :: Nat). KnownNat n => Integer -> Maybe (Finite n)

-- | Convert a <a>Finite</a> into the corresponding <a>Integer</a>.
getFinite :: forall (n :: Nat). Finite n -> Integer

-- | Formally, the class <a>Profunctor</a> represents a profunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where the first argument is
--   contravariant and the second argument is covariant.
--   
--   You can define a <a>Profunctor</a> by either defining <a>dimap</a> or
--   by defining both <a>lmap</a> and <a>rmap</a>.
--   
--   If you supply <a>dimap</a>, you should ensure that:
--   
--   <pre>
--   <a>dimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>lmap</a> and <a>rmap</a>, ensure:
--   
--   <pre>
--   <a>lmap</a> <a>id</a> ≡ <a>id</a>
--   <a>rmap</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>dimap</a> (f <a>.</a> g) (h <a>.</a> i) ≡ <a>dimap</a> g h <a>.</a> <a>dimap</a> f i
--   <a>lmap</a> (f <a>.</a> g) ≡ <a>lmap</a> g <a>.</a> <a>lmap</a> f
--   <a>rmap</a> (f <a>.</a> g) ≡ <a>rmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
class Profunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d

-- | Map the first argument contravariantly.
--   
--   <pre>
--   <a>lmap</a> f ≡ <a>dimap</a> f <a>id</a>
--   </pre>
lmap :: Profunctor p => (a -> b) -> p b c -> p a c

-- | Map the second argument covariantly.
--   
--   <pre>
--   <a>rmap</a> ≡ <a>dimap</a> <a>id</a>
--   </pre>
rmap :: Profunctor p => (b -> c) -> p a b -> p a c

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a
defaultFieldRules :: LensRules

-- | Generate overloaded field accessors based on field names which are
--   only prefixed with an underscore (e.g. <tt>_name</tt>), not
--   additionally with the type name (e.g. <tt>_fooName</tt>).
--   
--   This might be the desired behaviour in case the
--   <tt>DuplicateRecordFields</tt> language extension is used in order to
--   get rid of the necessity to prefix each field name with the type name.
--   
--   As an example:
--   
--   <pre>
--   data Foo a  = Foo { _x :: <a>Int</a>, _y :: a }
--   newtype Bar = Bar { _x :: <a>Char</a> }
--   makeFieldsNoPrefix ''Foo
--   makeFieldsNoPrefix ''Bar
--   </pre>
--   
--   will create classes
--   
--   <pre>
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   </pre>
--   
--   together with instances
--   
--   <pre>
--   instance HasX (Foo a) Int
--   instance HasY (Foo a) a where
--   instance HasX Bar Char where
--   </pre>
--   
--   For details, see <a>classUnderscoreNoPrefixFields</a>.
--   
--   <pre>
--   makeFieldsNoPrefix = <a>makeLensesWith</a> <a>classUnderscoreNoPrefixFields</a>
--   </pre>
makeFieldsNoPrefix :: Name -> DecsQ

-- | Generate overloaded field accessors.
--   
--   <i>e.g</i>
--   
--   <pre>
--   data Foo a = Foo { _fooX :: <a>Int</a>, _fooY :: a }
--   newtype Bar = Bar { _barX :: <a>Char</a> }
--   makeFields ''Foo
--   makeFields ''Bar
--   </pre>
--   
--   will create
--   
--   <pre>
--   _fooXLens :: Lens' (Foo a) Int
--   _fooYLens :: Lens (Foo a) (Foo b) a b
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   instance HasX (Foo a) Int where
--     x = _fooXLens
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   instance HasY (Foo a) a where
--     y = _fooYLens
--   _barXLens :: Iso' Bar Char
--   instance HasX Bar Char where
--     x = _barXLens
--   </pre>
--   
--   For details, see <a>camelCaseFields</a>.
--   
--   <pre>
--   makeFields = <a>makeLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
makeFields :: Name -> DecsQ

-- | A <a>FieldNamer</a> for <a>abbreviatedFields</a>.
abbreviatedNamer :: FieldNamer

-- | Field rules fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   Note that <tt>prefix</tt> may be any string of characters that are not
--   uppercase letters. (In particular, it may be arbitrary string of
--   lowercase letters and numbers) This is the behavior that
--   <a>defaultFieldRules</a> had in lens 4.4 and earlier.
abbreviatedFields :: LensRules

-- | A <a>FieldNamer</a> for <a>classUnderscoreNoPrefixFields</a>.
classUnderscoreNoPrefixNamer :: FieldNamer

-- | Field rules for fields in the form <tt> _fieldname </tt> (the leading
--   underscore is mandatory).
--   
--   <b>Note</b>: The primary difference to <a>camelCaseFields</a> is that
--   for <tt>classUnderscoreNoPrefixFields</tt> the field names are not
--   expected to be prefixed with the type name. This might be the desired
--   behaviour when the <tt>DuplicateRecordFields</tt> extension is
--   enabled.
classUnderscoreNoPrefixFields :: LensRules

-- | A <a>FieldNamer</a> for <a>camelCaseFields</a>.
camelCaseNamer :: FieldNamer

-- | Field rules for fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   <b>Note</b>: The <tt>prefix</tt> must be the same as the typename
--   (with the first letter lowercased). This is a change from lens
--   versions before lens 4.5. If you want the old behaviour, use
--   <a>makeLensesWith</a> <a>abbreviatedFields</a>
camelCaseFields :: LensRules

-- | A <a>FieldNamer</a> for <a>underscoreFields</a>.
underscoreNamer :: FieldNamer

-- | Field rules for fields in the form <tt> _prefix_fieldname </tt>
underscoreFields :: LensRules

-- | Build <tt>Wrapped</tt> instance for a given newtype
makeWrapped :: Name -> DecsQ

-- | Declare lenses for each records in the given declarations, using the
--   specified <a>LensRules</a>. Any record syntax in the input will be
--   stripped off.
declareLensesWith :: LensRules -> DecsQ -> DecsQ

-- | <pre>
--   declareFields = <a>declareLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
declareFields :: DecsQ -> DecsQ

-- | Build <a>Wrapped</a> instance for each newtype.
declareWrapped :: DecsQ -> DecsQ

-- | Generate a <a>Prism</a> for each constructor of each data type.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declarePrisms [d|
--     data Exp = Lit Int | Var String | Lambda{ bound::String, body::Exp }
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Exp = Lit Int | Var String | Lambda { bound::String, body::Exp }
--   _Lit :: <tt>Prism'</tt> Exp Int
--   _Var :: <tt>Prism'</tt> Exp String
--   _Lambda :: <tt>Prism'</tt> Exp (String, Exp)
--   </pre>
declarePrisms :: DecsQ -> DecsQ

-- | Similar to <a>makeClassyFor</a>, but takes a declaration quote.
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ

-- | For each record in the declaration quote, make lenses and traversals
--   for it, and create a class when the type has no arguments. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareClassy [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--   instance HasFoo Foo where foo = <a>id</a>
--   fooX, fooY :: HasFoo t =&gt; <a>Lens'</a> t <a>Int</a>
--   </pre>
declareClassy :: DecsQ -> DecsQ

-- | Similar to <a>makeLensesFor</a>, but takes a declaration quote.
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ

-- | Make lenses for all records in the given declaration quote. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareLenses [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   fooX, fooY :: <a>Lens'</a> Foo Int
--   </pre>
declareLenses :: DecsQ -> DecsQ

-- | Build lenses with a custom configuration.
makeLensesWith :: LensRules -> Name -> DecsQ

-- | Derive lenses and traversals, using a named wrapper class, and
--   specifying explicit pairings of <tt>(fieldName, traversalName)</tt>.
--   
--   Example usage:
--   
--   <pre>
--   <a>makeClassyFor</a> "HasFoo" "foo" [("_foo", "fooLens"), ("bar", "lbar")] ''Foo
--   </pre>
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ

-- | Derive lenses and traversals, specifying explicit pairings of
--   <tt>(fieldName, lensName)</tt>.
--   
--   If you map multiple names to the same label, and it is present in the
--   same constructor then this will generate a <a>Traversal</a>.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   <a>makeLensesFor</a> [("_foo", "fooLens"), ("baz", "lbaz")] ''Foo
--   <a>makeLensesFor</a> [("_barX", "bar"), ("_barY", "bar")] ''Bar
--   </pre>
makeLensesFor :: [(String, String)] -> Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments. Works the same as <a>makeClassy</a> except that
--   (a) it expects that record field names do not begin with an
--   underscore, (b) all record fields are made into lenses, and (c) the
--   resulting lens is prefixed with an underscore.
makeClassy_ :: Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data Foo = Foo { _fooX, _fooY :: <a>Int</a> }
--   <a>makeClassy</a> ''Foo
--   </pre>
--   
--   will create
--   
--   <pre>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--     fooX :: <a>Lens'</a> t <a>Int</a>
--     fooX = foo . go where go f (Foo x y) = (\x' -&gt; Foo x' y) &lt;$&gt; f x
--     fooY :: <a>Lens'</a> t <a>Int</a>
--     fooY = foo . go where go f (Foo x y) = (\y' -&gt; Foo x y') &lt;$&gt; f y
--   instance HasFoo Foo where
--     foo = id
--   </pre>
--   
--   <pre>
--   <a>makeClassy</a> = <a>makeLensesWith</a> <a>classyRules</a>
--   </pre>
makeClassy :: Name -> DecsQ

-- | Build lenses (and traversals) with a sensible default configuration.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBar
--     = Foo { _x, _y :: <a>Int</a> }
--     | Bar { _x :: <a>Int</a> }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   will create
--   
--   <pre>
--   x :: <a>Lens'</a> FooBar <a>Int</a>
--   x f (Foo a b) = (\a' -&gt; Foo a' b) &lt;$&gt; f a
--   x f (Bar a)   = Bar &lt;$&gt; f a
--   y :: <a>Traversal'</a> FooBar <a>Int</a>
--   y f (Foo a b) = (\b' -&gt; Foo a  b') &lt;$&gt; f b
--   y _ c@(Bar _) = pure c
--   </pre>
--   
--   <pre>
--   <a>makeLenses</a> = <a>makeLensesWith</a> <a>lensRules</a>
--   </pre>
makeLenses :: Name -> DecsQ

-- | A <a>LensRules</a> used by <a>makeClassy_</a>.
classyRules_ :: LensRules

-- | Rules for making lenses and traversals that precompose another
--   <a>Lens</a>.
classyRules :: LensRules

-- | Create a <a>FieldNamer</a> from a mapping function. If the function
--   returns <tt>[]</tt>, it creates no lens for the field.
mappingNamer :: (String -> [String]) -> FieldNamer

-- | Create a <a>FieldNamer</a> from explicit pairings of <tt>(fieldName,
--   lensName)</tt>.
lookingupNamer :: [(String, String)] -> FieldNamer

-- | Construct a <a>LensRules</a> value for generating top-level
--   definitions using the given map from field names to definition names.
lensRulesFor :: [(String, String)] -> LensRules

-- | A <a>FieldNamer</a> that strips the _ off of the field name,
--   lowercases the name, and skips the field if it doesn't start with an
--   '_'.
underscoreNoPrefixNamer :: FieldNamer

-- | Rules for making fairly simple partial lenses, ignoring the special
--   cases for isomorphisms and traversals, and not making any classes. It
--   uses <a>underscoreNoPrefixNamer</a>.
lensRules :: LensRules

-- | <a>Lens'</a> to access the option for naming "classy" lenses.
lensClass :: Lens' LensRules ClassyNamer

-- | <a>Lens'</a> to access the convention for naming fields in our
--   <a>LensRules</a>.
lensField :: Lens' LensRules FieldNamer

-- | Create the class if the constructor is <a>Simple</a> and the
--   <a>lensClass</a> rule matches.
createClass :: Lens' LensRules Bool

-- | Generate optics using lazy pattern matches. This can allow fields of
--   an undefined value to be initialized with lenses:
--   
--   <pre>
--   data Foo = Foo {_x :: Int, _y :: Bool}
--     deriving Show
--   
--   <a>makeLensesWith</a> (<a>lensRules</a> &amp; <a>generateLazyPatterns</a> .~ True) ''Foo
--   </pre>
--   
--   <pre>
--   &gt; undefined &amp; x .~ 8 &amp; y .~ True
--   Foo {_x = 8, _y = True}
--   </pre>
--   
--   The downside of this flag is that it can lead to space-leaks and
--   code-size/compile-time increases when generated for large records. By
--   default this flag is turned off, and strict optics are generated.
--   
--   When using lazy optics the strict optic can be recovered by composing
--   with <a>$!</a>:
--   
--   <pre>
--   strictOptic = ($!) . lazyOptic
--   </pre>
generateLazyPatterns :: Lens' LensRules Bool

-- | Generate "updateable" optics when <a>True</a>. When <a>False</a>,
--   <a>Fold</a>s will be generated instead of <a>Traversal</a>s and
--   <a>Getter</a>s will be generated instead of <a>Lens</a>es. This mode
--   is intended to be used for types with invariants which must be
--   maintained by "smart" constructors.
generateUpdateableOptics :: Lens' LensRules Bool

-- | Indicate whether or not to supply the signatures for the generated
--   lenses.
--   
--   Disabling this can be useful if you want to provide a more restricted
--   type signature or if you want to supply hand-written haddocks.
generateSignatures :: Lens' LensRules Bool

-- | Generate "simple" optics even when type-changing optics are possible.
--   (e.g. <a>Lens'</a> instead of <a>Lens</a>)
simpleLenses :: Lens' LensRules Bool

-- | Rules to construct lenses for data fields.
data LensRules

-- | The rule to create function names of lenses for data fields.
--   
--   Although it's sometimes useful, you won't need the first two arguments
--   most of the time.
type FieldNamer = Name -> [Name] -> Name -> [DefName]

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definiton name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | The optional rule to create a class and method around a monomorphic
--   data type. If this naming convention is provided, it generates a
--   "classy" lens.
type ClassyNamer = Name -> Maybe (Name, Name)

-- | Generate a <tt>Prism</tt> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz . _Foo
--     _Bar = _FooBarBaz . _Bar
--     _Baz = _FooBarBaz . _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
--   
--   In the event that the name of a data type is also the name of one of
--   its constructors, the name of the <tt>Prism</tt> generated for the
--   data type will be prefixed with an extra <tt>_</tt> (if the data type
--   name is prefix) or <tt>.</tt> (if the name is infix) to disambiguate
--   it from the <tt>Prism</tt> for the corresponding constructor. For
--   example, this code:
--   
--   <pre>
--   data Quux = Quux Int | Fred Bool
--   makeClassyPrisms ''Quux
--   </pre>
--   
--   will create:
--   
--   <pre>
--   class AsQuux s where
--     __Quux :: Prism' s Quux -- Data type prism
--     _Quux :: Prism' s Int   -- Constructor prism
--     _Fred :: Prism' s Bool
--   
--     _Quux = __Quux . _Quux
--     _Fred = __Quux . _Fred
--   
--   instance AsQuux Quux
--   </pre>
makeClassyPrisms :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ

-- | An indexed version of <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^@. iat 1
--   (1,Just "world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iat 1 %@~ (\i x -&gt; if odd i then Just "hello" else Nothing) $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iat 2 %@~ (\i x -&gt; if odd i then Just "hello" else Nothing) $ Map.empty
--   fromList []
--   </pre>
iat :: At m => Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))

-- | Delete the value associated with a key in a <a>Map</a>-like container
--   
--   <pre>
--   <a>sans</a> k = <a>at</a> k .~ Nothing
--   </pre>
sans :: At m => Index m -> m -> m

-- | A definition of <a>ix</a> for types with an <a>At</a> instance. This
--   is the default if you don't specify a definition for <a>ix</a>.
ixAt :: At m => Index m -> Traversal' m (IxValue m)

-- | An indexed version of <a>ix</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; iix 2 %@~ f'
--   fromList [a,b,f' 2 c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; iix 2 .@~ h
--   fromList [a,b,h 2,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^@? iix 2
--   Just (2,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^@? iix 2
--   Nothing
--   </pre>
iix :: Ixed m => Index m -> IndexedTraversal' (Index m) m (IxValue m)

-- | An indexed version of <a>contains</a>.
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^@. icontains 3
--   (3,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^@. icontains 5
--   (5,False)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; icontains 3 %@~ \i x -&gt; if odd i then not x else x
--   fromList [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; icontains 3 %@~ \i x -&gt; if even i then not x else x
--   fromList [1,2,3,4]
--   </pre>
icontains :: Contains m => Index m -> IndexedLens' (Index m) m Bool
type family Index s

-- | This class provides a simple <a>Lens</a> that lets you view (and
--   modify) information about whether or not a container contains a given
--   <a>Index</a>.
class Contains m

-- | <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 5
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
contains :: Contains m => Index m -> Lens' m Bool

-- | This provides a common notion of a value at an index that is shared by
--   both <a>Ixed</a> and <a>At</a>.
type family IxValue m

-- | Provides a simple <a>Traversal</a> lets you <a>traverse</a> the value
--   at a given key in a <a>Map</a> or element at an ordinal position in a
--   list or <a>Seq</a>.
class Ixed m

-- | <i>NB:</i> Setting the value of this <a>Traversal</a> will only set
--   the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 %~ f
--   fromList [a,b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 .~ e
--   fromList [a,b,e,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? ix 2
--   Just c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? ix 2
--   Nothing
--   </pre>
ix :: Ixed m => Index m -> Traversal' m (IxValue m)

-- | <a>At</a> provides a <a>Lens</a> that can be used to read, write or
--   delete the value associated with a key in a <a>Map</a>-like container
--   on an ad hoc basis.
--   
--   An instance of <a>At</a> should satisfy:
--   
--   <pre>
--   <a>ix</a> k ≡ <a>at</a> k <a>.</a> <a>traverse</a>
--   </pre>
class Ixed m => At m

-- | <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^.at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 ?~ "hello" $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <i>Note:</i> <a>Map</a>-like containers form a reasonable instance,
--   but not <a>Array</a>-like ones, where you cannot satisfy the
--   <a>Lens</a> laws.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Extract <a>each</a> element of a (potentially monomorphic) container.
--   
--   Notably, when applied to a tuple, this generalizes <a>both</a> to
--   arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3) &amp; each *~ 10
--   (10,20,30)
--   </pre>
--   
--   It can also be used on monomorphic containers like <a>Text</a> or
--   <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over each Char.toUpper ("hello"^.Text.packed)
--   "HELLO"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; each.each %~ Char.toUpper
--   ("HELLO","WORLD")
--   </pre>
class Each s t a b | s -> a, t -> b, s b -> t, t a -> s
each :: Each s t a b => Traversal s t a b

-- | Implement <a>plate</a> operation for a type using its <a>Generic1</a>
--   instance.
gplate1 :: forall k (f :: k -> Type) (a :: k). (Generic1 f, GPlated1 f (Rep1 f)) => Traversal' (f a) (f a)

-- | Implement <a>plate</a> operation for a type using its <a>Generic</a>
--   instance.
gplate :: (Generic a, GPlated a (Rep a)) => Traversal' a a

-- | The original <tt>uniplate</tt> combinator, implemented in terms of
--   <a>Plated</a> as a <a>Lens</a>.
--   
--   <pre>
--   <a>parts</a> ≡ <a>partsOf</a> <a>plate</a>
--   </pre>
--   
--   The resulting <a>Lens</a> is safer to use as it ignores
--   'over-application' and deals gracefully with under-application, but it
--   is only a proper <a>Lens</a> if you don't change the list
--   <a>length</a>!
parts :: Plated a => Lens' a [a]

-- | Fold the immediate children of a <a>Plated</a> container.
--   
--   <pre>
--   <a>composOpFold</a> z c f = <a>foldrOf</a> <a>plate</a> (c <a>.</a> f) z
--   </pre>
composOpFold :: Plated a => b -> (b -> b -> b) -> (a -> b) -> a -> b

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>para</a> ≡ <a>paraOf</a> <a>plate</a>
--   </pre>
para :: Plated a => (a -> [r] -> r) -> a -> r

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>paraOf</a> :: <a>Fold</a> a a -&gt; (a -&gt; [r] -&gt; r) -&gt; a -&gt; r
--   </pre>
paraOf :: Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r

-- | Extract one level of <a>holes</a> from a container in a region
--   specified by one <a>Traversal</a>, using another.
--   
--   <pre>
--   <a>holesOnOf</a> b l ≡ <a>holesOf</a> (b <a>.</a> l)
--   </pre>
--   
--   <pre>
--   <a>holesOnOf</a> :: <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>IndexedLens'</a> i a a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>IndexedTraversal'</a> i a a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOnOf :: Conjoined p => LensLike (Bazaar p r r) s t a b -> Over p (Bazaar p r r) a b r r -> s -> [Pretext p r r t]

-- | An alias for <a>holesOf</a>, provided for consistency with the other
--   combinators.
--   
--   <pre>
--   <a>holesOn</a> ≡ <a>holesOf</a>
--   </pre>
--   
--   <pre>
--   <a>holesOn</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOn</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOn :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | The one-level version of <a>context</a>. This extracts a list of the
--   immediate children as editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren x = <a>children</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>holes</a> l x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holes</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holes</a> = <a>holesOf</a> <a>plate</a>
--   </pre>
holes :: Plated a => a -> [Pretext ((->) :: Type -> Type -> Type) a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using another user-supplied
--   <a>Traversal</a> to walk each layer.
--   
--   <pre>
--   <a>contextsOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOnOf :: ATraversal s t a a -> ATraversal' a a -> s -> [Context a a t]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using <a>plate</a>.
--   
--   <pre>
--   <a>contextsOn</a> b ≡ <a>contextsOnOf</a> b <a>plate</a>
--   </pre>
--   
--   <pre>
--   <a>contextsOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOn :: Plated a => ATraversal s t a a -> s -> [Context a a t]

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively, using a user-specified <a>Traversal</a> to
--   walk each layer.
--   
--   <pre>
--   propUniverse l x = <a>universeOf</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>contextsOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contextsOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>contextsOf</a> :: <a>Traversal'</a> a a -&gt; a -&gt; [<a>Context</a> a a a]
--   </pre>
contextsOf :: ATraversal' a a -> a -> [Context a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively.
--   
--   <pre>
--   propUniverse x = <a>universe</a> x <a>==</a> <a>map</a> <a>pos</a> (<a>contexts</a> x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contexts</a> x]
--   </pre>
--   
--   <pre>
--   <a>contexts</a> ≡ <a>contextsOf</a> <a>plate</a>
--   </pre>
contexts :: Plated a => a -> [Context a a a]

-- | Transform every element in a tree that lies in a region indicated by a
--   supplied <a>Traversal</a>, walking with a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOnOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m b) -> s -> m t

-- | Transform every element in a tree using a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; a -&gt; m a
--   </pre>
transformMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m b) -> a -> m b

-- | Transform every element in the tree in a region indicated by a
--   supplied <a>Traversal</a>, in a bottom-up manner, monadically.
--   
--   <pre>
--   <a>transformMOn</a> :: (<a>Monad</a> m, <a>Plated</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m a) -> s -> m t

-- | Transform every element in the tree, in a bottom-up manner,
--   monadically.
transformM :: (Monad m, Plated a) => (a -> m a) -> a -> m a

-- | Transform every element in a region indicated by a <a>Setter</a> by
--   recursively applying another <a>Setter</a> in a bottom-up manner.
--   
--   <pre>
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> b) -> s -> t

-- | Transform every element by recursively applying a given <a>Setter</a>
--   in a bottom-up manner.
--   
--   <pre>
--   <a>transformOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; a -&gt; a
--   <a>transformOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; a -&gt; a
--   </pre>
transformOf :: ASetter a b a b -> (b -> b) -> a -> b

-- | Transform every element in the tree in a bottom-up manner over a
--   region indicated by a <a>Setter</a>.
--   
--   <pre>
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOn :: Plated a => ASetter s t a a -> (a -> a) -> s -> t

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = <a>transform</a> $ \x -&gt; case x of
--     Neg (Lit i) -&gt; Lit (<a>negate</a> i)
--     _           -&gt; x
--   </pre>
transform :: Plated a => (a -> a) -> a -> a

-- | Given a <a>Fold</a> that knows how to locate immediate children, fold
--   all of the transitive descendants of a node, including itself that lie
--   in a region indicated by another <a>Fold</a>.
--   
--   <pre>
--   <a>cosmosOnOf</a> :: <a>Fold</a> s a -&gt; <a>Fold</a> a a -&gt; <a>Fold</a> s a
--   </pre>
cosmosOnOf :: (Applicative f, Contravariant f) => LensLike' f s a -> LensLike' f a a -> LensLike' f s a

-- | Given a <a>Fold</a> that knows how to find <a>Plated</a> parts of a
--   container fold them and all of their descendants, recursively.
--   
--   <pre>
--   <a>cosmosOn</a> :: <a>Plated</a> a =&gt; <a>Fold</a> s a -&gt; <a>Fold</a> s a
--   </pre>
cosmosOn :: (Applicative f, Contravariant f, Plated a) => LensLike' f s a -> LensLike' f s a

-- | Given a <a>Fold</a> that knows how to locate immediate children, fold
--   all of the transitive descendants of a node, including itself.
--   
--   <pre>
--   <a>cosmosOf</a> :: <a>Fold</a> a a -&gt; <a>Fold</a> a a
--   </pre>
cosmosOf :: (Applicative f, Contravariant f) => LensLike' f a a -> LensLike' f a a

-- | Fold over all transitive descendants of a <a>Plated</a> container,
--   including itself.
cosmos :: Plated a => Fold a a

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including itself
--   that lie in a region indicated by another <a>Fold</a>.
--   
--   <pre>
--   <a>toListOf</a> l ≡ <a>universeOnOf</a> l <a>ignored</a>
--   </pre>
universeOnOf :: Getting [a] s a -> Getting [a] a a -> s -> [a]

-- | Given a <a>Fold</a> that knows how to find <a>Plated</a> parts of a
--   container retrieve them and all of their descendants, recursively.
universeOn :: Plated a => Getting [a] s a -> s -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including
--   itself.
--   
--   <pre>
--   <a>universeOf</a> :: <a>Fold</a> a a -&gt; a -&gt; [a]
--   </pre>
universeOf :: Getting [a] a a -> a -> [a]

-- | Retrieve all of the transitive descendants of a <a>Plated</a>
--   container, including itself.
universe :: Plated a => a -> [a]

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>, using a user-specified
--   <a>Traversal</a> for recursion. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> s -> m t

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>. Ensures that the rule
--   cannot be applied anywhere in the result.
rewriteMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m (Maybe a)) -> s -> m t

-- | Rewrite by applying a monadic rule everywhere you recursing with a
--   user-specified <a>Traversal</a>. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> a -> m b

-- | Rewrite by applying a monadic rule everywhere you can. Ensures that
--   the rule cannot be applied anywhere in the result.
rewriteM :: (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a

-- | Rewrite recursively over part of a larger structure using a specified
--   <a>Setter</a>.
--   
--   <pre>
--   <a>rewriteOnOf</a> :: <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Setter'</a> s a    -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> Maybe a) -> s -> t

-- | Rewrite recursively over part of a larger structure.
--   
--   <pre>
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>ASetter'</a> s a   -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOn :: Plated a => ASetter s t a a -> (a -> Maybe a) -> s -> t

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewriteOf l r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universeOf</a> l (<a>rewriteOf</a> l r x))
--   </pre>
--   
--   Usually <a>transformOf</a> is more appropriate, but <a>rewriteOf</a>
--   can give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>\a -&gt; f a
--   <a>&lt;|&gt;</a> g a</tt> which performs both rewrites until a fixed
--   point.
--   
--   <pre>
--   <a>rewriteOf</a> :: <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   </pre>
rewriteOf :: ASetter a b a b -> (b -> Maybe a) -> a -> b

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universe</a> (<a>rewrite</a> r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>\a -&gt; f a
--   <a>&lt;|&gt;</a> g a</tt> which performs both rewrites until a fixed
--   point.
rewrite :: Plated a => (a -> Maybe a) -> a -> a

-- | Extract the immediate descendants of a <a>Plated</a> container.
--   
--   <pre>
--   <a>children</a> ≡ <a>toListOf</a> <a>plate</a>
--   </pre>
children :: Plated a => a -> [a]

-- | Try to apply a traversal to all transitive descendants of a
--   <a>Plated</a> container, but do not recurse through matching
--   descendants.
--   
--   <pre>
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Fold</a> s a                 -&gt; <a>Fold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedFold</a> s a          -&gt; <a>IndexedFold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Traversal</a> s s a b        -&gt; <a>Traversal</a> s s a b
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedTraversal</a> s s a b -&gt; <a>IndexedTraversal</a> s s a b
--   </pre>
deep :: (Conjoined p, Applicative f, Plated s) => Traversing p f s s a b -> Over p f s s a b

-- | Compose through a plate
(...) :: forall k f c s t p (a :: k) b. (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
infixr 9 ...

-- | A <a>Plated</a> type is one where we know how to extract its immediate
--   self-similar children.
--   
--   <i>Example 1</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Expr
--     = Val <a>Int</a>
--     | Neg Expr
--     | Add Expr Expr
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>,<a>Typeable</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> f (Neg e) = Neg <a>&lt;$&gt;</a> f e
--     <a>plate</a> f (Add a b) = Add <a>&lt;$&gt;</a> f a <a>&lt;*&gt;</a> f b
--     <a>plate</a> _ a = <a>pure</a> a
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   <i>Example 2</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Tree a
--     = Bin (Tree a) (Tree a)
--     | Tip a
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>,<a>Typeable</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> (Tree a) where
--     <a>plate</a> f (Bin l r) = Bin <a>&lt;$&gt;</a> f l <a>&lt;*&gt;</a> f r
--     <a>plate</a> _ t = <a>pure</a> t
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Data</a> a =&gt; <a>Plated</a> (Tree a) where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   Note the big distinction between these two implementations.
--   
--   The former will only treat children directly in this tree as
--   descendents, the latter will treat trees contained in the values under
--   the tips also as descendants!
--   
--   When in doubt, pick a <a>Traversal</a> and just use the various
--   <tt>...Of</tt> combinators rather than pollute <a>Plated</a> with
--   orphan instances!
--   
--   If you want to find something unplated and non-recursive with
--   <a>biplate</a> use the <tt>...OnOf</tt> variant with <a>ignored</a>,
--   though those usecases are much better served in most cases by using
--   the existing <a>Lens</a> combinators! e.g.
--   
--   <pre>
--   <a>toListOf</a> <a>biplate</a> ≡ <a>universeOnOf</a> <a>biplate</a> <a>ignored</a>
--   </pre>
--   
--   This same ability to explicitly pass the <a>Traversal</a> in question
--   is why there is no analogue to uniplate's <tt>Biplate</tt>.
--   
--   Moreover, since we can allow custom traversals, we implement
--   reasonable defaults for polymorphic data types, that only
--   <a>traverse</a> into themselves, and <i>not</i> their polymorphic
--   arguments.
class Plated a

-- | <a>Traversal</a> of the immediate children of this structure.
--   
--   If you're using GHC 7.2 or newer and your type has a <a>Data</a>
--   instance, <a>plate</a> will default to <a>uniplate</a> and you can
--   choose to not override it with your own definition.
plate :: Plated a => Traversal' a a
class GPlated a (g :: k -> Type)
class GPlated1 (f :: k -> Type) (g :: k -> Type)

-- | This type family is used by <a>Zoom</a> to describe the common effect
--   type.
type family Zoomed (m :: Type -> Type) :: Type -> Type -> Type

-- | This type family is used by <a>Magnify</a> to describe the common
--   effect type.
type family Magnified (m :: Type -> Type) :: Type -> Type -> Type

-- | This class allows us to use <a>zoom</a> in, changing the <a>State</a>
--   supplied by many different <a>Monad</a> transformers, potentially
--   quite deep in a <a>Monad</a> transformer stack.
class (MonadState s m, MonadState t n) => Zoom (m :: Type -> Type) (n :: Type -> Type) s t | m -> s, n -> t, m t -> n, n s -> m

-- | Run a monadic action in a larger <a>State</a> than it was defined in,
--   using a <a>Lens'</a> or <a>Traversal'</a>.
--   
--   This is commonly used to lift actions in a simpler <a>State</a>
--   <a>Monad</a> into a <a>State</a> <a>Monad</a> with a larger
--   <a>State</a> type.
--   
--   When applied to a <a>Traversal'</a> over multiple values, the actions
--   for each target are executed sequentially and the results are
--   aggregated.
--   
--   This can be used to edit pretty much any <a>Monad</a> transformer
--   stack with a <a>State</a> in it!
--   
--   <pre>
--   &gt;&gt;&gt; flip State.evalState (a,b) $ zoom _1 $ use id
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.execState (a,b) $ zoom _1 $ id .= c
--   (c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.execState [(a,b),(c,d)] $ zoom traverse $ _2 %= f
--   [(a,f b),(c,f d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.runState [(a,b),(c,d)] $ zoom traverse $ _2 &lt;%= f
--   (f b &lt;&gt; f d &lt;&gt; mempty,[(a,f b),(c,f d)])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.evalState (a,b) $ zoom both (use id)
--   a &lt;&gt; b
--   </pre>
--   
--   <pre>
--   <a>zoom</a> :: <a>Monad</a> m             =&gt; <a>Lens'</a> s t      -&gt; <a>StateT</a> t m a -&gt; <a>StateT</a> s m a
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> c) =&gt; <a>Traversal'</a> s t -&gt; <a>StateT</a> t m c -&gt; <a>StateT</a> s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w)             =&gt; <a>Lens'</a> s t      -&gt; <a>RWST</a> r w t m c -&gt; <a>RWST</a> r w s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <a>Monoid</a> c) =&gt; <a>Traversal'</a> s t -&gt; <a>RWST</a> r w t m c -&gt; <a>RWST</a> r w s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <a>Error</a> e)  =&gt; <a>Lens'</a> s t      -&gt; <a>ErrorT</a> e (<a>RWST</a> r w t m) c -&gt; <a>ErrorT</a> e (<a>RWST</a> r w s m) c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <a>Monoid</a> c, <a>Error</a> e) =&gt; <a>Traversal'</a> s t -&gt; <a>ErrorT</a> e (<a>RWST</a> r w t m) c -&gt; <a>ErrorT</a> e (<a>RWST</a> r w s m) c
--   ...
--   </pre>
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
infixr 2 `zoom`

-- | This class allows us to use <a>magnify</a> part of the environment,
--   changing the environment supplied by many different <a>Monad</a>
--   transformers. Unlike <a>zoom</a> this can change the environment of a
--   deeply nested <a>Monad</a> transformer.
--   
--   Also, unlike <a>zoom</a>, this can be used with any valid
--   <a>Getter</a>, but cannot be used with a <a>Traversal</a> or
--   <a>Fold</a>.
class (Magnified m ~ Magnified n, MonadReader b m, MonadReader a n) => Magnify (m :: Type -> Type) (n :: Type -> Type) b a | m -> b, n -> a, m a -> n, n b -> m

-- | Run a monadic action in a larger environment than it was defined in,
--   using a <a>Getter</a>.
--   
--   This acts like <a>local</a>, but can in many cases change the type of
--   the environment as well.
--   
--   This is commonly used to lift actions in a simpler <a>Reader</a>
--   <a>Monad</a> into a <a>Monad</a> with a larger environment type.
--   
--   This can be used to edit pretty much any <a>Monad</a> transformer
--   stack with an environment in it:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; magnify _2 (+1)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip Reader.runReader (1,2) $ magnify _1 Reader.ask
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip Reader.runReader (1,2,[10..20]) $ magnify (_3._tail) Reader.ask
--   [11,12,13,14,15,16,17,18,19,20]
--   </pre>
--   
--   The type can be read as
--   
--   <pre>
--   magnify :: LensLike' (Magnified m c) a b -&gt; m c -&gt; n c
--   </pre>
--   
--   but the higher-rank constraints make it easier to apply
--   <tt>magnify</tt> to a <a>Getter</a> in highly-polymorphic code.
--   
--   <pre>
--   <a>magnify</a> :: <a>Getter</a> s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>magnify</a> :: <a>Monoid</a> r =&gt; <a>Fold</a> s a   -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>magnify</a> :: <a>Monoid</a> w                 =&gt; <a>Getter</a> s t -&gt; <a>RWS</a> t w st c -&gt; <a>RWS</a> s w st c
--   <a>magnify</a> :: (<a>Monoid</a> w, <a>Monoid</a> c) =&gt; <a>Fold</a> s a   -&gt; <a>RWS</a> a w st c -&gt; <a>RWS</a> s w st c
--   ...
--   </pre>
magnify :: Magnify m n b a => ((Functor (Magnified m c), Contravariant (Magnified m c)) => LensLike' (Magnified m c) a b) -> m c -> n c
infixr 2 `magnify`

-- | This combinator is based on <tt>ala'</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   alaf :: Rewrapping s t =&gt; (Unwrapped s -&gt; s) -&gt; ((r -&gt; t) -&gt; e -&gt; s) -&gt; (r -&gt; Unwrapped t) -&gt; e -&gt; Unwrapped s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; alaf Sum foldMap Prelude.length ["hello","world"]
--   10
--   </pre>
alaf :: (Functor f, Functor g, Rewrapping s t) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)

-- | This combinator is based on <tt>ala</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   &gt;&gt;&gt; ala Sum foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [False,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [True,False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Product foldMap [1,2,3,4]
--   24
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler, type.
--   
--   <pre>
--   ala :: Rewrapping s t =&gt; (Unwrapped s -&gt; s) -&gt; ((Unwrapped t -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; Unwrapped s
--   </pre>
ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)

-- | This is a convenient version of <a>_Unwrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Unwrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso (Unwrapped t) (Unwrapped s) t s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Wrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso s t (Unwrapped s) (Unwrapped t)

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Unwrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' (Unwrapped s) s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Wrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' s (Unwrapped s)

-- | Given the constructor for a <a>Wrapped</a> type, return a
--   deconstructor that is its inverse.
--   
--   Assuming the <a>Wrapped</a> instance is legal, these laws hold:
--   
--   <pre>
--   <a>op</a> f <a>.</a> f ≡ <a>id</a>
--   f <a>.</a> <a>op</a> f ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Identity (Identity 4)
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Const (Const "hello")
--   "hello"
--   </pre>
op :: Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
_Unwrapped :: Rewrapping s t => Iso (Unwrapped t) (Unwrapped s) t s

-- | Work under a newtype wrapper.
--   
--   <pre>
--   &gt;&gt;&gt; Const "hello" &amp; _Wrapped %~ Prelude.length &amp; getConst
--   5
--   </pre>
--   
--   <pre>
--   <a>_Wrapped</a>   ≡ <a>from</a> <a>_Unwrapped</a>
--   <a>_Unwrapped</a> ≡ <a>from</a> <a>_Wrapped</a>
--   </pre>
_Wrapped :: Rewrapping s t => Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapped' :: Wrapped s => Iso' (Unwrapped s) s

-- | Implement the <a>_Wrapped</a> operation for a type using its
--   <a>Generic</a> instance.
_GWrapped' :: forall s (d :: Meta) (c :: Meta) (s' :: Meta) a. (Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
pattern Wrapped :: Rewrapped s s => Unwrapped s -> s
pattern Unwrapped :: Rewrapped t t => t -> Unwrapped t
type family Unwrapped s

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where {
    type family Unwrapped s;
    type Unwrapped s = GUnwrapped Rep s;
}

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)
class Wrapped s => Rewrapped s t
class (Rewrapped s t, Rewrapped t s) => Rewrapping s t

-- | Attempt to extract the right-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "hello!")
--   Just ("hello",'!')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "")
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [b,c,a])
--   Just (fromList [b,c],a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [])
--   Nothing
--   </pre>
unsnoc :: Snoc s s a a => s -> Maybe (s, a)

-- | <a>snoc</a> an element onto the end of a container.
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList []) a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList [b, c]) a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (LazyT.pack "hello") '!'
--   "hello!"
--   </pre>
snoc :: Snoc s s a a => s -> a -> s
infixl 5 `snoc`

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] |&gt; a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [b, c] |&gt; a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; LazyT.pack "hello" |&gt; '!'
--   "hello!"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s
infixl 5 |>

-- | A <a>Traversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?!_last
--   c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _last %~ f
--   [a,b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
--   
--   This <a>Traversal</a> is not limited to lists, however. We can also
--   work with other containers, such as a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList "abcde" ^? _last
--   Just 'e'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.empty ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList "abcde" &amp; _last .~ 'Q') == Vector.fromList "abcdQ"
--   True
--   </pre>
--   
--   <pre>
--   <a>_last</a> :: <a>Traversal'</a> [a] a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_last :: Snoc s s a a => Traversal' s a

-- | A <a>Traversal</a> reading and replacing all but the a last element of
--   a <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d]^?_init
--   Just [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_init
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _init .~ [c,d,e]
--   [c,d,e,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _init .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d] &amp; _init.traverse %~ f
--   [f a,f b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?_init
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^?!_init
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._init
--   "hell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._init
--   ""
--   </pre>
--   
--   <pre>
--   <a>_init</a> :: <a>Traversal'</a> [a] [a]
--   <a>_init</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_init</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_init :: Snoc s s a a => Traversal' s s

-- | A <a>Traversal</a> reading and writing to the <a>tail</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _tail .~ [c,d,e]
--   [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d,e] &amp; _tail.traverse %~ f
--   [a,f b,f c,f d,f e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] &amp; _tail .~ [3,4,5]
--   [1,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?_tail
--   Just [b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?!_tail
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._tail
--   "ello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._tail
--   ""
--   </pre>
--   
--   This isn't limited to lists. For instance you can also <a>traverse</a>
--   the tail of a <a>Seq</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b] &amp; _tail .~ Seq.fromList [c,d,e]
--   fromList [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^? _tail
--   Just (fromList [b,c])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _tail
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>_tail</a> :: <a>Traversal'</a> [a] [a]
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_tail :: Cons s s a a => Traversal' s s

-- | A <a>Traversal</a> reading and writing to the <a>head</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head .~ d
--   [d,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head %~ f
--   [f a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head %~ f
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?!_head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _head .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _head .~ 2
--   [2,1]
--   </pre>
--   
--   This isn't limited to lists.
--   
--   For instance you can also <a>traverse</a> the head of a <a>Seq</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; _head %~ f
--   fromList [f a,b,c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   <a>_head</a> :: <a>Traversal'</a> [a] a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_head :: Cons s s a a => Traversal' s a

-- | <a>cons</a> an element onto a container.
--   
--   <pre>
--   &gt;&gt;&gt; cons a []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [])
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [b, c])
--   fromList [a,b,c]
--   </pre>
cons :: Cons s s a a => a -> s -> s
infixr 5 `cons`

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList []
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList [b, c]
--   fromList [a,b,c]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s
infixr 5 <|
pattern (:<) :: Cons b b a a => a -> b -> b
infixr 5 :<
pattern (:>) :: Snoc a a b b => a -> b -> a
infixl 5 :>

-- | This class provides a way to attach or detach elements on the left
--   side of a structure in a flexible manner.
class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Cons</a> :: <a>Prism</a> [a] [b] (a, [a]) (b, [b])
--   <a>_Cons</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (a, <a>Seq</a> a) (b, <a>Seq</a> b)
--   <a>_Cons</a> :: <a>Prism</a> (<a>Vector</a> a) (<a>Vector</a> b) (a, <a>Vector</a> a) (b, <a>Vector</a> b)
--   <a>_Cons</a> :: <a>Prism'</a> <a>String</a> (<a>Char</a>, <a>String</a>)
--   <a>_Cons</a> :: <a>Prism'</a> <a>Text</a> (<a>Char</a>, <a>Text</a>)
--   <a>_Cons</a> :: <a>Prism'</a> <a>ByteString</a> (<a>Word8</a>, <a>ByteString</a>)
--   </pre>
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)

-- | This class provides a way to attach or detach elements on the right
--   side of a structure in a flexible manner.
class Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Snoc</a> :: <a>Prism</a> [a] [b] ([a], a) ([b], b)
--   <a>_Snoc</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (<a>Seq</a> a, a) (<a>Seq</a> b, b)
--   <a>_Snoc</a> :: <a>Prism</a> (<a>Vector</a> a) (<a>Vector</a> b) (<a>Vector</a> a, a) (<a>Vector</a> b, b)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>String</a> (<a>String</a>, <a>Char</a>)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>Text</a> (<a>Text</a>, <a>Char</a>)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>ByteString</a> (<a>ByteString</a>, <a>Word8</a>)
--   </pre>
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)
pattern Empty :: AsEmpty s => s
class AsEmpty a

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: AsEmpty a => Prism' a ()

-- | Data types that are representationally equal are isomorphic.
--   
--   This is only available on GHC 7.8+
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b

-- | Lift an <a>Iso</a> into the second argument of a <a>Bifunctor</a>.
--   This is essentially the same as <a>mapping</a>, but it takes a
--   'Bifunctor p' constraint instead of a 'Functor (p a)' one.
--   
--   <pre>
--   seconding :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p x s) (p y t) (p x a) (p y b)
--   seconding :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p x s) (p x a)
--   </pre>
seconding :: forall (f :: Type -> Type -> Type) (g :: Type -> Type -> Type) s t a b x y. (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f x s) (g y t) (f x a) (g y b)

-- | Lift an <a>Iso</a> into the first argument of a <a>Bifunctor</a>.
--   
--   <pre>
--   firsting :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p s x) (p t y) (p a x) (p b y)
--   firsting :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p s x) (p a x)
--   </pre>
firsting :: forall (f :: Type -> Type -> Type) (g :: Type -> Type -> Type) s t a b x y. (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f s x) (g t y) (f a x) (g b y)

-- | Lift two <a>Iso</a>s into both arguments of a <a>Bifunctor</a>.
--   
--   <pre>
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p s s') (p t t') (p a a') (p b b')
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p s s') (p a a')
--   </pre>
bimapping :: forall (f :: Type -> Type -> Type) (g :: Type -> Type -> Type) s t a b s' t' a' b'. (Bifunctor f, Bifunctor g) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (f s s') (g t t') (f a a') (g b b')

-- | Lift an <a>Iso</a> covariantly into the right argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p x s) (p y t) (p x a) (p y b)
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p x s) (p x a)
--   </pre>
rmapping :: forall (p :: Type -> Type -> Type) (q :: Type -> Type -> Type) s t a b x y. (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p x s) (q y t) (p x a) (q y b)

-- | Lift an <a>Iso</a> contravariantly into the left argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p a x) (p b y) (p s x) (p t y)
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p a x) (p s x)
--   </pre>
lmapping :: forall (p :: Type -> Type -> Type) (q :: Type -> Type -> Type) s t a b x y. (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p a x) (q b y) (p s x) (q t y)

-- | Lift two <a>Iso</a>s into both arguments of a <a>Profunctor</a>
--   simultaneously.
--   
--   <pre>
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p a s') (p b t') (p s a') (p t b')
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p a s') (p s a')
--   </pre>
dimapping :: forall (p :: Type -> Type -> Type) (q :: Type -> Type -> Type) s t a b s' t' a' b'. (Profunctor p, Profunctor q) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (p a s') (q b t') (p s a') (q t b')

-- | Lift an <a>Iso</a> into a <a>Contravariant</a> functor.
--   
--   <pre>
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (f a) (f b) (f s) (f t)
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (f a) (f s)
--   </pre>
contramapping :: forall (f :: Type -> Type) s t a b. Contravariant f => AnIso s t a b -> Iso (f a) (f b) (f s) (f t)

-- | This isomorphism can be used to inspect an <a>IndexedTraversal</a> to
--   see how it associates the structure and it can also be used to bake
--   the <a>IndexedTraversal</a> into a <a>Magma</a> so that you can
--   traverse over it multiple times with access to the original indices.
imagma :: Over (Indexed i) (Molten i a b) s t a b -> Iso s t' (Magma i t b a) (Magma j t' c c)

-- | This isomorphism can be used to inspect a <a>Traversal</a> to see how
--   it associates the structure and it can also be used to bake the
--   <a>Traversal</a> into a <a>Magma</a> so that you can traverse over it
--   multiple times.
magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)

-- | Given a function that is its own inverse, this gives you an <a>Iso</a>
--   using it in both directions.
--   
--   <pre>
--   <a>involuted</a> ≡ <a>join</a> <a>iso</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. involuted reverse
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; involuted reverse %~ ('d':)
--   "lived"
--   </pre>
involuted :: (a -> a) -> Iso' a a

-- | An <a>Iso</a> between a list, <a>ByteString</a>, <a>Text</a> fragment,
--   etc. and its reversal.
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. reversed
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; reversed %~ ('d':)
--   "lived"
--   </pre>
reversed :: Reversing a => Iso' a a

-- | An <a>Iso</a> between the strict variant of a structure and its lazy
--   counterpart.
--   
--   <pre>
--   <a>lazy</a> = <a>from</a> <a>strict</a>
--   </pre>
--   
--   See <a>http://hackage.haskell.org/package/strict-base-types</a> for an
--   example use.
lazy :: Strict lazy strict => Iso' strict lazy

-- | The isomorphism for flipping a function.
--   
--   <pre>
--   &gt;&gt;&gt; ((,)^.flipped) 1 2
--   (2,1)
--   </pre>
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')

-- | The canonical isomorphism for uncurrying and currying a function.
--   
--   <pre>
--   <a>uncurried</a> = <a>iso</a> <a>uncurry</a> <a>curry</a>
--   </pre>
--   
--   <pre>
--   <a>uncurried</a> = <a>from</a> <a>curried</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ((+)^.uncurried) (1,2)
--   3
--   </pre>
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)

-- | The canonical isomorphism for currying and uncurrying a function.
--   
--   <pre>
--   <a>curried</a> = <a>iso</a> <a>curry</a> <a>uncurry</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (fst^.curried) 3 4
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view curried fst 3 4
--   3
--   </pre>
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)

-- | <tt><a>anon</a> a p</tt> generalizes <tt><a>non</a> a</tt> to take any
--   value and a predicate.
--   
--   This function assumes that <tt>p a</tt> holds <tt><a>True</a></tt> and
--   generates an isomorphism between <tt><a>Maybe</a> (a | <a>not</a> (p
--   a))</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . anon Map.empty Map.null . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . anon Map.empty Map.null . at "world" .~ Nothing
--   fromList []
--   </pre>
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a

-- | <tt><a>non'</a> p</tt> generalizes <tt><a>non</a> (p # ())</tt> to
--   take any unit <a>Prism</a>
--   
--   This function generates an isomorphism between <tt><a>Maybe</a> (a |
--   <a>isn't</a> p a)</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.singleton "hello" Map.empty &amp; at "hello" . non' _Empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . non' _Empty . at "world" .~ Nothing
--   fromList []
--   </pre>
non' :: APrism' a () -> Iso' (Maybe a) a

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a> ≡ <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 +~ 2
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 -~ 1
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" . non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" . non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . non Map.empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . non Map.empty . at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: forall (f :: Type -> Type) (g :: Type -> Type) s t a b. (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | This isomorphism can be used to convert to or from an instance of
--   <a>Enum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; LT^.from enum
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 97^.enum :: Char
--   'a'
--   </pre>
--   
--   Note: this is only an isomorphism from the numeric range actually used
--   and it is a bit of a pleasant fiction, since there are questionable
--   <a>Enum</a> instances for <a>Double</a>, and <a>Float</a> that exist
--   solely for <tt>[1.0 .. 4.0]</tt> sugar and the instances for those and
--   <a>Integer</a> don't cover all values in their range.
enum :: Enum a => Iso' Int a

-- | The opposite of working <a>over</a> a <a>Setter</a> is working
--   <a>under</a> an isomorphism.
--   
--   <pre>
--   <a>under</a> ≡ <a>over</a> <a>.</a> <a>from</a>
--   </pre>
--   
--   <pre>
--   <a>under</a> :: <a>Iso</a> s t a b -&gt; (t -&gt; s) -&gt; b -&gt; a
--   </pre>
under :: AnIso s t a b -> (t -> s) -> b -> a

-- | <tt><a>xplatf</a> = <a>auf</a> . <a>from</a></tt> but with a nicer
--   signature.
--   
--   <pre>
--   &gt;&gt;&gt; xplatf (_Unwrapping Sum) (foldMapOf both) Prelude.length ("hello","world")
--   10
--   </pre>
--   
--   <pre>
--   <a>xplatf</a> :: <a>Iso</a> s t a b -&gt; ((r -&gt; a) -&gt; e -&gt; b) -&gt; (r -&gt; s) -&gt; e -&gt; t
--   </pre>
xplatf :: forall k f g s (t :: k) a (b :: k). Optic (Costar f) g s t a b -> (f a -> g b) -> f s -> g t

-- | <tt><a>xplat</a> = <a>au</a> . <a>from</a></tt> but with a nicer
--   signature.
xplat :: forall k s g (t :: k) a (b :: k). Optic (Costar ((->) s :: Type -> Type)) g s t a b -> ((s -> a) -> g b) -> g t

-- | Based on <tt>ala'</tt> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   For a version you pass the name of the <tt>newtype</tt> constructor
--   to, see <a>alaf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; auf (_Wrapping Sum) (foldMapOf both) Prelude.length ("hello","world")
--   10
--   </pre>
--   
--   Mnemonically, the German <i>auf</i> plays a similar role to <i>à
--   la</i>, and the combinator is <a>au</a> with an extra function
--   argument:
--   
--   <pre>
--   <a>auf</a> :: <a>Iso</a> s t a b -&gt; ((r -&gt; t) -&gt; e -&gt; s) -&gt; (r -&gt; b) -&gt; e -&gt; a
--   </pre>
--   
--   but the signature is general.
--   
--   Note: The direction of the <a>Iso</a> required for this function
--   changed in <tt>lens</tt> 4.18 to match up with the behavior of
--   <a>au</a>. For the old behavior use <a>xplatf</a> or for a version
--   that is compatible across both old and new versions of <tt>lens</tt>
--   you can just use <a>coerce</a>!
auf :: (Functor f, Functor g) => AnIso s t a b -> (f t -> g s) -> f b -> g a

-- | Based on <a>ala</a> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum) foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler type:
--   
--   <pre>
--   au :: AnIso s t a b -&gt; ((b -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; a
--   </pre>
--   
--   <pre>
--   au = xplat . from
--   </pre>
au :: Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a

-- | Convert from <a>AnIso</a> back to any <a>Iso</a>.
--   
--   This is useful when you need to store an isomorphism as a data type
--   inside a container and later reconstitute it as an overloaded
--   function.
--   
--   See <a>cloneLens</a> or <a>cloneTraversal</a> for more information on
--   why you might want to do this.
cloneIso :: AnIso s t a b -> Iso s t a b

-- | Extract the two functions, one from <tt>s -&gt; a</tt> and one from
--   <tt>b -&gt; t</tt> that characterize an <a>Iso</a>.
withIso :: forall s t a b (rep :: RuntimeRep) (r :: TYPE rep). AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | Invert an isomorphism.
--   
--   <pre>
--   <a>from</a> (<a>from</a> l) ≡ l
--   </pre>
from :: AnIso s t a b -> Iso b a t s

-- | Build a simple isomorphism from a pair of inverse functions.
--   
--   <pre>
--   <a>view</a> (<a>iso</a> f g) ≡ f
--   <a>view</a> (<a>from</a> (<a>iso</a> f g)) ≡ g
--   <a>over</a> (<a>iso</a> f g) h ≡ g <a>.</a> h <a>.</a> f
--   <a>over</a> (<a>from</a> (<a>iso</a> f g)) h ≡ f <a>.</a> h <a>.</a> g
--   </pre>
iso :: (s -> a) -> (b -> t) -> Iso s t a b
pattern Strict :: Strict s t => t -> s
pattern Lazy :: Strict t s => t -> s
pattern Swapped :: forall p c d. Swapped p => p d c -> p c d
pattern Reversed :: Reversing t => t -> t
pattern List :: IsList l => [Item l] -> l

-- | When you see this as an argument to a function, it expects an
--   <a>Iso</a>.
type AnIso s t a b = Exchange a b a Identity b -> Exchange a b s Identity t

-- | A <a>Simple</a> <a>AnIso</a>.
type AnIso' s a = AnIso s s a a

-- | This class provides for symmetric bifunctors.
class Bifunctor p => Swapped (p :: Type -> Type -> Type)

-- | <pre>
--   <a>swapped</a> <a>.</a> <a>swapped</a> ≡ <a>id</a>
--   <a>first</a> f <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>second</a> f
--   <a>second</a> g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>first</a> g
--   <a>bimap</a> f g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>bimap</a> g f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^.swapped
--   (2,1)
--   </pre>
swapped :: Swapped p => Iso (p a b) (p c d) (p b a) (p d c)

-- | Ad hoc conversion between "strict" and "lazy" versions of a structure,
--   such as <a>Text</a> or <a>ByteString</a>.
class Strict lazy strict | lazy -> strict, strict -> lazy
strict :: Strict lazy strict => Iso' lazy strict

-- | A version of <a>substEq</a> that provides explicit, rather than
--   implicit, equality evidence.
withEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (rep :: RuntimeRep) (r :: TYPE rep). AnEquality s t a b -> ((s :~: a) -> (b :~: t) -> r) -> r

-- | Convert Leibniz equality to equality. Reverses <a>mapEq</a> in
--   <a>Simple</a> cases.
--   
--   The type should be understood as
--   
--   <pre>
--   fromLeibniz' :: (forall f. f s -&gt; f a) -&gt; Equality' s a
--   </pre>
fromLeibniz' :: forall k2 (s :: k2) (a :: k2). ((s :~: s) -> s :~: a) -> Equality' s a

-- | Convert a "profunctor lens" form of equality to an equality. Reverses
--   <a>overEquality</a>.
--   
--   The type should be understood as
--   
--   <pre>
--   fromLeibniz :: (forall p. p a b -&gt; p s t) -&gt; Equality s t a b
--   </pre>
fromLeibniz :: forall k1 k2 (a :: k1) (b :: k2) (s :: k1) (t :: k2). (Identical a b a b -> Identical a b s t) -> Equality s t a b

-- | The opposite of working <a>overEquality</a> is working
--   <a>underEquality</a>.
underEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) p. AnEquality s t a b -> p t s -> p b a

-- | Recover a "profunctor lens" form of equality. Reverses
--   <a>fromLeibniz</a>.
overEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) p. AnEquality s t a b -> p a b -> p s t

-- | A <a>Simple</a> version of <a>equality</a>
equality' :: forall k2 (a :: k2) (b :: k2). (a :~: b) -> Equality' a b

-- | Construct an <a>Equality</a> from explicit equality evidence.
equality :: forall k1 k2 (s :: k1) (a :: k1) (b :: k2) (t :: k2). (s :~: a) -> (b :~: t) -> Equality s t a b
cloneEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2). AnEquality s t a b -> Equality s t a b

-- | Composition with this isomorphism is occasionally useful when your
--   <a>Lens</a>, <a>Traversal</a> or <a>Iso</a> has a constraint on an
--   unused argument to force that argument to agree with the type of a
--   used argument and avoid <tt>ScopedTypeVariables</tt> or other
--   ugliness.
simple :: forall k2 (a :: k2). Equality' a a

-- | This is an adverb that can be used to modify many other <a>Lens</a>
--   combinators to make them require simple lenses, simple traversals,
--   simple prisms or simple isos as input.
simply :: forall k1 k2 p (f :: k1 -> k2) (s :: k1) (a :: k1) (rep :: RuntimeRep) (r :: TYPE rep). (Optic' p f s a -> r) -> Optic' p f s a -> r

-- | <a>Equality</a> is symmetric.
fromEq :: forall k2 k1 (s :: k2) (t :: k1) (a :: k2) (b :: k1). AnEquality s t a b -> Equality b a t s

-- | We can use <a>Equality</a> to do substitution into anything.
mapEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) f. AnEquality s t a b -> f s -> f a

-- | Substituting types with <a>Equality</a>.
substEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (rep :: RuntimeRep) (r :: TYPE rep). AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r

-- | Extract a witness of type <a>Equality</a>.
runEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2). AnEquality s t a b -> Identical s t a b

-- | Provides witness that <tt>(s ~ a, b ~ t)</tt> holds.
data Identical (a :: k) (b :: k1) (s :: k) (t :: k1)
[Identical] :: forall k k1 (a :: k) (b :: k1). Identical a b a b

-- | When you see this as an argument to a function, it expects an
--   <a>Equality</a>.
type AnEquality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = Identical a Proxy b a Proxy b -> Identical a Proxy b s Proxy t

-- | A <a>Simple</a> <a>AnEquality</a>.
type AnEquality' (s :: k2) (a :: k2) = AnEquality s s a a
itraverseByOf :: IndexedTraversal i s t a b -> (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> s -> f t
itraverseBy :: TraversableWithIndex i t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> t a -> f (t b)
ifoldMapByOf :: IndexedFold i t a -> (r -> r -> r) -> r -> (i -> a -> r) -> t -> r
ifoldMapBy :: FoldableWithIndex i t => (r -> r -> r) -> r -> (i -> a -> r) -> t a -> r

-- | Generalizes <a>mapAccumL</a> to add access to the index.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> ≡ <a>imapAccumL</a> <a>.</a> <a>const</a>
--   </pre>
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | Generalizes <a>mapAccumR</a> to add access to the index.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumR</a> ≡ <a>imapAccumR</a> <a>.</a> <a>const</a>
--   </pre>
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access its
--   position (and the arguments flipped).
--   
--   <pre>
--   <tt>forM</tt> a ≡ <a>iforM</a> a <a>.</a> <a>const</a>
--   <a>iforM</a> ≡ <a>flip</a> <a>imapM</a>
--   </pre>
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access the
--   index.
--   
--   When you don't need access to the index <a>mapM</a> is more liberal in
--   what it can accept.
--   
--   <pre>
--   <a>mapM</a> ≡ <a>imapM</a> <a>.</a> <a>const</a>
--   </pre>
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <tt>for</tt> a ≡ <a>ifor</a> a <a>.</a> <a>const</a>
--   <a>ifor</a> ≡ <a>flip</a> <a>itraverse</a>
--   </pre>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <a>toList</a> is more flexible in what it accepts.
--   
--   <pre>
--   <a>toList</a> ≡ <a>map</a> <a>snd</a> <a>.</a> <a>itoList</a>
--   </pre>
itoList :: FoldableWithIndex i f => f a -> [(i, a)]

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <a>foldlM</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlM</a> ≡ <a>ifoldlM</a> <a>.</a> <a>const</a>
--   </pre>
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <a>foldrM</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrM</a> ≡ <a>ifoldrM</a> <a>.</a> <a>const</a>
--   </pre>
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b

-- | Searches a container with a predicate that is also supplied the index,
--   returning the left-most element of the structure matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>find</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>find</a> ≡ <a>ifind</a> <a>.</a> <a>const</a>
--   </pre>
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)

-- | Concatenate the results of a function of the elements of an indexed
--   container with access to the index.
--   
--   When you don't need access to the index then <a>concatMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>concatMap</a> ≡ <a>iconcatMap</a> <a>.</a> <a>const</a>
--   <a>iconcatMap</a> ≡ <a>ifoldMap</a>
--   </pre>
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforM_</a> ≡ <a>flip</a> <a>imapM_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forMOf_</a> l a ≡ <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   </pre>
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>mapM_</a> ≡ <a>imapM</a> <a>.</a> <a>const</a>
--   </pre>
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>ifor_</a> ≡ <a>flip</a> <a>itraverse_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>for_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>for_</a> a ≡ <a>ifor_</a> a <a>.</a> <a>const</a>
--   </pre>
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <a>traverse_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>traverse_</a> l = <a>itraverse</a> <a>.</a> <a>const</a>
--   </pre>
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Determines whether no elements of the structure satisfy the predicate.
--   
--   <pre>
--   <a>none</a> f ≡ <a>not</a> <a>.</a> <a>any</a> f
--   </pre>
none :: Foldable f => (a -> Bool) -> f a -> Bool

-- | Return whether or not none of the elements in a container satisfy a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>none</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>none</a> ≡ <a>inone</a> <a>.</a> <a>const</a>
--   <a>inone</a> f ≡ <a>not</a> <a>.</a> <a>iany</a> f
--   </pre>
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not all elements in a container satisfy a predicate,
--   with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>all</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>all</a> ≡ <a>iall</a> <a>.</a> <a>const</a>
--   </pre>
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not any element in a container satisfies a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>any</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>any</a> ≡ <a>iany</a> <a>.</a> <a>const</a>
--   </pre>
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on an index.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^?traversed.index 2
--   Just "world"
--   </pre>
index :: (Indexable i p, Eq i, Applicative f) => i -> Optical' p (Indexed i) f a a

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on a predicate on
--   the indices.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^..traversed.indices even
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traversed.indices (&gt;0)) Prelude.reverse $ ["He","was","stressed","o_O"]
--   ["He","saw","desserts","O_o"]
--   </pre>
indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a

-- | Composition of <a>Indexed</a> functions with a user supplied function
--   for combining indices.
icompose :: Indexable p c => (i -> j -> p) -> (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> c a b -> r

-- | Composition of <a>Indexed</a> functions.
--   
--   Mnemonically, the <tt>&lt;</tt> and <tt>&gt;</tt> points to the fact
--   that we want to preserve the indices.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.&gt;itraversed).withIndex
--   [((1,10),"one,ten"),((1,20),"one,twenty"),((2,30),"two,thirty"),((2,40),"two,forty")]
--   </pre>
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
infixr 9 <.>

-- | Remap the index.
reindexed :: Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r

-- | Use a value itself as its own index. This is essentially an indexed
--   version of <a>id</a>.
--   
--   Note: When used to modify the value, this can break the index
--   requirements assumed by <a>indices</a> and similar, so this is only
--   properly an <a>IndexedGetter</a>, but it can be used as more.
--   
--   <pre>
--   <a>selfIndex</a> :: <a>IndexedGetter</a> a a b
--   </pre>
selfIndex :: Indexable a p => p a fb -> a -> fb

-- | Compose a non-indexed function with an <a>Indexed</a> function.
--   
--   Mnemonically, the <tt>&gt;</tt> points to the indexing we want to
--   preserve.
--   
--   This is the same as <tt>(<a>.</a>)</tt>.
--   
--   <tt>f <a>.</a> g</tt> (and <tt>f <a>.&gt;</a> g</tt>) gives you the
--   index of <tt>g</tt> unless <tt>g</tt> is index-preserving, like a
--   <a>Prism</a>, <a>Iso</a> or <a>Equality</a>, in which case it'll pass
--   through the index of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed.&gt;itraversed).withIndex
--   [(10,"one,ten"),(20,"one,twenty"),(30,"two,thirty"),(40,"two,forty")]
--   </pre>
(.>) :: (st -> r) -> (kab -> st) -> kab -> r
infixr 9 .>

-- | Compose an <a>Indexed</a> function with a non-indexed function.
--   
--   Mnemonically, the <tt>&lt;</tt> points to the indexing we want to
--   preserve.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.itraversed).withIndex
--   [(1,"one,ten"),(1,"one,twenty"),(2,"two,thirty"),(2,"two,forty")]
--   </pre>
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
infixr 9 <.

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g ≡ <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a) ≡ <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i (f :: Type -> Type) | f -> i

-- | Map with access to the index.
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b

-- | The <a>IndexedSetter</a> for a <a>FunctorWithIndex</a>.
--   
--   If you don't need access to the index, then <a>mapped</a> is more
--   flexible in what it accepts.
imapped :: FunctorWithIndex i f => IndexedSetter i (f a) (f b) a b

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i (f :: Type -> Type) | f -> i

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <a>const</a>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | The <a>IndexedFold</a> of a <a>FoldableWithIndex</a> container.
--   
--   <tt><a>ifolded</a> <a>.</a> <a>asIndex</a></tt> is a fold over the
--   keys of a <a>FoldableWithIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Map.fromList [(2, "hello"), (1, "world")]^..ifolded.asIndex
--   [1,2]
--   </pre>
ifolded :: FoldableWithIndex i f => IndexedFold i (f a) a

-- | Right-associative fold of an indexed container with access to the
--   index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>ifoldr</a> <a>.</a> <a>const</a>
--   </pre>
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Left-associative fold of an indexed container with access to the index
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldl</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>ifoldl</a> <a>.</a> <a>const</a>
--   </pre>
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | <i>Strictly</i> fold right over the elements of a structure with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>ifoldr'</a> <a>.</a> <a>const</a>
--   </pre>
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf'</a> l ≡ <a>ifoldlOf'</a> l <a>.</a> <a>const</a>
--   </pre>
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<a>const</a> <a>Identity</a>) ≡ <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g ≡ <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i (t :: Type -> Type) | t -> i

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <a>itraverseOf</a> <a>itraversed</a>
--   </pre>
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | The <a>IndexedTraversal</a> of a <a>TraversableWithIndex</a>
--   container.
itraversed :: TraversableWithIndex i t => IndexedTraversal i (t a) (t b) a b

-- | Reify a <a>Lens</a> so it can be stored safely in a container.
newtype ReifiedLens s t a b
Lens :: Lens s t a b -> ReifiedLens s t a b
[runLens] :: ReifiedLens s t a b -> Lens s t a b

-- | <pre>
--   type <a>ReifiedLens'</a> = <a>Simple</a> <a>ReifiedLens</a>
--   </pre>
type ReifiedLens' s a = ReifiedLens s s a a

-- | Reify an <a>IndexedLens</a> so it can be stored safely in a container.
newtype ReifiedIndexedLens i s t a b
IndexedLens :: IndexedLens i s t a b -> ReifiedIndexedLens i s t a b
[runIndexedLens] :: ReifiedIndexedLens i s t a b -> IndexedLens i s t a b

-- | <pre>
--   type <a>ReifiedIndexedLens'</a> i = <a>Simple</a> (<a>ReifiedIndexedLens</a> i)
--   </pre>
type ReifiedIndexedLens' i s a = ReifiedIndexedLens i s s a a

-- | Reify an <a>IndexedTraversal</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedTraversal i s t a b
IndexedTraversal :: IndexedTraversal i s t a b -> ReifiedIndexedTraversal i s t a b
[runIndexedTraversal] :: ReifiedIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | <pre>
--   type <a>ReifiedIndexedTraversal'</a> i = <a>Simple</a> (<a>ReifiedIndexedTraversal</a> i)
--   </pre>
type ReifiedIndexedTraversal' i s a = ReifiedIndexedTraversal i s s a a

-- | A form of <a>Traversal</a> that can be stored monomorphically in a
--   container.
newtype ReifiedTraversal s t a b
Traversal :: Traversal s t a b -> ReifiedTraversal s t a b
[runTraversal] :: ReifiedTraversal s t a b -> Traversal s t a b

-- | <pre>
--   type <a>ReifiedTraversal'</a> = <a>Simple</a> <a>ReifiedTraversal</a>
--   </pre>
type ReifiedTraversal' s a = ReifiedTraversal s s a a

-- | Reify a <a>Getter</a> so it can be stored safely in a container.
--   
--   This can also be useful when combining getters in novel ways, as
--   <a>ReifiedGetter</a> is isomorphic to '(-&gt;)' and provides similar
--   instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world","!!!")^.runGetter ((,) &lt;$&gt; Getter _2 &lt;*&gt; Getter (_1.to length))
--   ("world",5)
--   </pre>
newtype ReifiedGetter s a
Getter :: Getter s a -> ReifiedGetter s a
[runGetter] :: ReifiedGetter s a -> Getter s a

-- | Reify an <a>IndexedGetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedGetter i s a
IndexedGetter :: IndexedGetter i s a -> ReifiedIndexedGetter i s a
[runIndexedGetter] :: ReifiedIndexedGetter i s a -> IndexedGetter i s a

-- | Reify a <a>Fold</a> so it can be stored safely in a container.
--   
--   This can also be useful for creatively combining folds as
--   <tt><a>ReifiedFold</a> s</tt> is isomorphic to <tt>ReaderT s []</tt>
--   and provides similar instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^..runFold ((,) &lt;$&gt; Fold _2 &lt;*&gt; Fold both)
--   [("world","hello"),("world","world")]
--   </pre>
newtype ReifiedFold s a
Fold :: Fold s a -> ReifiedFold s a
[runFold] :: ReifiedFold s a -> Fold s a
newtype ReifiedIndexedFold i s a
IndexedFold :: IndexedFold i s a -> ReifiedIndexedFold i s a
[runIndexedFold] :: ReifiedIndexedFold i s a -> IndexedFold i s a

-- | Reify a <a>Setter</a> so it can be stored safely in a container.
newtype ReifiedSetter s t a b
Setter :: Setter s t a b -> ReifiedSetter s t a b
[runSetter] :: ReifiedSetter s t a b -> Setter s t a b

-- | <pre>
--   type <a>ReifiedSetter'</a> = <a>Simple</a> <a>ReifiedSetter</a>
--   </pre>
type ReifiedSetter' s a = ReifiedSetter s s a a

-- | Reify an <a>IndexedSetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedSetter i s t a b
IndexedSetter :: IndexedSetter i s t a b -> ReifiedIndexedSetter i s t a b
[runIndexedSetter] :: ReifiedIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | <pre>
--   type <a>ReifiedIndexedSetter'</a> i = <a>Simple</a> (<a>ReifiedIndexedSetter</a> i)
--   </pre>
type ReifiedIndexedSetter' i s a = ReifiedIndexedSetter i s s a a

-- | Reify an <a>Iso</a> so it can be stored safely in a container.
newtype ReifiedIso s t a b
Iso :: Iso s t a b -> ReifiedIso s t a b
[runIso] :: ReifiedIso s t a b -> Iso s t a b

-- | <pre>
--   type <a>ReifiedIso'</a> = <a>Simple</a> <a>ReifiedIso</a>
--   </pre>
type ReifiedIso' s a = ReifiedIso s s a a

-- | Reify a <a>Prism</a> so it can be stored safely in a container.
newtype ReifiedPrism s t a b
Prism :: Prism s t a b -> ReifiedPrism s t a b
[runPrism] :: ReifiedPrism s t a b -> Prism s t a b

-- | <pre>
--   type <a>ReifiedPrism'</a> = <a>Simple</a> <a>ReifiedPrism</a>
--   </pre>
type ReifiedPrism' s a = ReifiedPrism s s a a

-- | This provides a breadth-first <a>Traversal</a> or <a>Fold</a> of the
--   individual levels of any other <a>Traversal</a> or <a>Fold</a> via
--   iterative deepening depth-first search. The levels are returned to you
--   in a compressed format.
--   
--   This is similar to <a>levels</a>, but retains the index of the
--   original <a>IndexedTraversal</a>, so you can access it when traversing
--   the levels later on.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed).itraversed
--   [((0,0),'d'),((0,1),'o'),((1,0),'c'),((0,2),'g'),((1,1),'a'),((1,2),'t')]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the levels which is indexed by the
--   depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed)&lt;.&gt;itraversed
--   [((2,(0,0)),'d'),((3,(0,1)),'o'),((3,(1,0)),'c'),((4,(0,2)),'g'),((4,(1,1)),'a'),((5,(1,2)),'t')]
--   </pre>
--   
--   <pre>
--   <a>ilevels</a> :: <a>IndexedTraversal</a> i s t a b      -&gt; <a>IndexedTraversal</a> <a>Int</a> s t (<a>Level</a> i a) (<a>Level</a> i b)
--   <a>ilevels</a> :: <a>IndexedFold</a> i s a               -&gt; <a>IndexedFold</a> <a>Int</a> s (<a>Level</a> i a)
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
ilevels :: forall (f :: Type -> Type) i s t a b j. Applicative f => Traversing (Indexed i) f s t a b -> IndexedLensLike Int f s t (Level i a) (Level j b)

-- | This provides a breadth-first <a>Traversal</a> or <a>Fold</a> of the
--   individual <a>levels</a> of any other <a>Traversal</a> or <a>Fold</a>
--   via iterative deepening depth-first search. The levels are returned to
--   you in a compressed format.
--   
--   This can permit us to extract the <a>levels</a> directly:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse)
--   [Zero,Zero,One () 'h',Two 0 (One () 'e') (One () 'w'),Two 0 (One () 'l') (One () 'o'),Two 0 (One () 'l') (One () 'r'),Two 0 (One () 'o') (One () 'l'),One () 'd']
--   </pre>
--   
--   But we can also traverse them in turn:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse).traverse
--   "hewlolrold"
--   </pre>
--   
--   We can use this to traverse to a fixed depth in the tree of
--   (<a>&lt;*&gt;</a>) used in the <a>Traversal</a>:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse)).traverse %~ toUpper
--   ["HEllo","World"]
--   </pre>
--   
--   Or we can use it to traverse the first <tt>n</tt> elements in found in
--   that <a>Traversal</a> regardless of the depth at which they were
--   found.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse).traverse) %~ toUpper
--   ["HELlo","World"]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the <a>levels</a> which is indexed
--   by the depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..levels (traverse.traverse) &lt;. traverse
--   [(2,'d'),(3,'o'),(3,'c'),(4,'g'),(4,'a'),(5,'t')]
--   </pre>
--   
--   <pre>
--   <a>levels</a> :: <a>Traversal</a> s t a b      -&gt; <a>IndexedTraversal</a> <a>Int</a> s t (<a>Level</a> () a) (<a>Level</a> () b)
--   <a>levels</a> :: <a>Fold</a> s a               -&gt; <a>IndexedFold</a> <a>Int</a> s (<a>Level</a> () a)
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
levels :: forall (f :: Type -> Type) s t a b. Applicative f => Traversing ((->) :: Type -> Type -> Type) f s t a b -> IndexedLensLike Int f s t (Level () a) (Level () b)

-- | Sequence a container using a specified <a>Applicative</a>.
--   
--   This is like <a>traverseBy</a> where the <a>Traversable</a> instance
--   can be specified by any <a>Traversal</a>
--   
--   <pre>
--   <a>sequenceByOf</a> <a>traverse</a> ≡ <a>sequenceBy</a>
--   </pre>
sequenceByOf :: Traversal s t (f b) b -> (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> s -> f t

-- | Traverse a container using a specified <a>Applicative</a>.
--   
--   This is like <a>traverseBy</a> where the <a>Traversable</a> instance
--   can be specified by any <a>Traversal</a>
--   
--   <pre>
--   <a>traverseByOf</a> <a>traverse</a> ≡ <a>traverseBy</a>
--   </pre>
traverseByOf :: Traversal s t a b -> (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> s -> f t

-- | <a>Fuse</a> a <a>Traversal</a> by reassociating all of the
--   <tt>(<a>&lt;*&gt;</a>)</tt> operations to the left and fusing all of
--   the <a>fmap</a> calls into one. This is particularly useful when
--   constructing a <a>Traversal</a> using operations from
--   <a>GHC.Generics</a>.
--   
--   Given a pair of <a>Traversal</a>s <tt>foo</tt> and <tt>bar</tt>,
--   
--   <pre>
--   <a>confusing</a> (foo.bar) = foo.bar
--   </pre>
--   
--   However, <tt>foo</tt> and <tt>bar</tt> are each going to use the
--   <a>Applicative</a> they are given.
--   
--   <a>confusing</a> exploits the <a>Yoneda</a> lemma to merge their
--   separate uses of <a>fmap</a> into a single <a>fmap</a>. and it further
--   exploits an interesting property of the right Kan lift (or
--   <a>Curried</a>) to left associate all of the uses of
--   <tt>(<a>&lt;*&gt;</a>)</tt> to make it possible to fuse together more
--   fmaps.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Traversal</a>
--   <tt>foo.bar</tt> in the above description is recursive or complex
--   enough to prevent inlining.
--   
--   <a>fusing</a> is a version of this combinator suitable for fusing
--   lenses.
--   
--   <pre>
--   <a>confusing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
confusing :: Applicative f => LensLike (Curried (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b

-- | Try the second traversal. If it returns no entries, try again with all
--   entries from the first traversal, recursively.
--   
--   <pre>
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>Fold</a> s a                   -&gt; <a>Fold</a> s a
--   <a>deepOf</a> :: <a>Traversal'</a> s s    -&gt; <a>Traversal'</a> s a             -&gt; <a>Traversal'</a> s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>Traversal</a> s t a b          -&gt; <a>Traversal</a> s t a b
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   </pre>
deepOf :: (Conjoined p, Applicative f) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b

-- | Try the first <a>Traversal</a> (or <a>Fold</a>), falling back on the
--   second <a>Traversal</a> (or <a>Fold</a>) if it returns no entries.
--   
--   This is only a valid <a>Traversal</a> if the second <a>Traversal</a>
--   is disjoint from the result of the first or returns exactly the same
--   results. These conditions are trivially met when given a <a>Lens</a>,
--   <a>Iso</a>, <a>Getter</a>, <a>Prism</a> or "affine" Traversal -- one
--   that has 0 or 1 target.
--   
--   Mutatis mutandis for <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 1) (ix 2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 42) (ix 2)
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>failing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Prism</a> s t a b     -&gt; <a>Prism</a> s t a b     -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Fold</a> s a          -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>Lens</a> s t a b      -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Iso</a> s t a b       -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Equality</a> s t a b  -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Getter</a> s a        -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   If both of the inputs are indexed, the result is also indexed, so you
--   can apply this to a pair of indexed traversals or indexed folds,
--   obtaining an indexed traversal or indexed fold.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedLens</a> i s t a b      -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedGetter</a> i s a        -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
failing :: (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
infixl 5 `failing`

-- | Try to map a function which uses the index over this
--   <a>IndexedTraversal</a>, failing if the <a>IndexedTraversal</a> has no
--   targets.
--   
--   <pre>
--   <a>ifailover</a> :: Alternative m =&gt; IndexedTraversal i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; m t
--   </pre>
ifailover :: Alternative m => Over (Indexed i) ((,) Any) s t a b -> (i -> a -> b) -> s -> m t

-- | Try to map a function over this <a>Traversal</a>, failing if the
--   <a>Traversal</a> has no targets.
--   
--   <pre>
--   &gt;&gt;&gt; failover (element 3) (*2) [1,2] :: Maybe [Int]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Left (*2) (Right 4) :: Maybe (Either Int Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Right (*2) (Right 4) :: Maybe (Either Int Int)
--   Just (Right 8)
--   </pre>
--   
--   <pre>
--   <a>failover</a> :: Alternative m =&gt; Traversal s t a b -&gt; (a -&gt; b) -&gt; s -&gt; m t
--   </pre>
failover :: Alternative m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t

-- | Traverse elements of a <a>Traversable</a> container where their
--   ordinal positions match a predicate.
--   
--   <pre>
--   <a>elements</a> ≡ <a>elementsOf</a> <a>traverse</a>
--   </pre>
elements :: forall (t :: Type -> Type) a. Traversable t => (Int -> Bool) -> IndexedTraversal' Int (t a) a

-- | Traverse (or fold) selected elements of a <a>Traversal</a> (or
--   <a>Fold</a>) where their ordinal positions match a predicate.
--   
--   <pre>
--   <a>elementsOf</a> :: <a>Traversal'</a> s a -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementsOf</a> :: <a>Fold</a> s a       -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementsOf :: forall (f :: Type -> Type) s t a. Applicative f => LensLike (Indexing f) s t a a -> (Int -> Bool) -> IndexedLensLike Int f s t a a

-- | Traverse the <i>nth</i> element of a <a>Traversable</a> container.
--   
--   <pre>
--   <a>element</a> ≡ <a>elementOf</a> <a>traverse</a>
--   </pre>
element :: forall (t :: Type -> Type) a. Traversable t => Int -> IndexedTraversal' Int (t a) a

-- | Traverse the <i>nth</i> <a>elementOf</a> a <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a> if it exists.
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] &amp; elementOf (traverse.traverse) 1 .~ 5
--   [[1],[5,4]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] ^? elementOf (folded.folded) 1
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ ['a'..] ^?! elementOf folded 5
--   'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ take 10 $ elementOf traverse 3 .~ 16 $ [0..]
--   [0,1,2,16,4,5,6,7,8,9]
--   </pre>
--   
--   <pre>
--   <a>elementOf</a> :: <a>Traversal'</a> s a -&gt; <a>Int</a> -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementOf</a> :: <a>Fold</a> s a       -&gt; <a>Int</a> -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementOf :: forall (f :: Type -> Type) s t a. Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a

-- | This is the trivial empty <a>Traversal</a>.
--   
--   <pre>
--   <a>ignored</a> :: <a>IndexedTraversal</a> i s s a b
--   </pre>
--   
--   <pre>
--   <a>ignored</a> ≡ <a>const</a> <a>pure</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 &amp; ignored %~ absurd
--   6
--   </pre>
ignored :: Applicative f => pafb -> s -> f s

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed64 :: forall (f :: Type -> Type) a b. Traversable f => IndexedTraversal Int64 (f a) (f b) a b

-- | Traverse any <a>Traversable1</a> container. This is an
--   <a>IndexedTraversal1</a> that is indexed by ordinal position.
traversed1 :: forall (f :: Type -> Type) a b. Traversable1 f => IndexedTraversal1 Int (f a) (f b) a b

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed :: forall (f :: Type -> Type) a b. Traversable f => IndexedTraversal Int (f a) (f b) a b

-- | Generalizes <a>mapAccumL</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> l ≡ <a>imapAccumLOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumLOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumLOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumLOf :: Over (Indexed i) (State acc) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | Generalizes <a>mapAccumR</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> l ≡ <a>imapAccumROf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumROf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumROf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumROf :: Over (Indexed i) (Backwards (State acc)) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position (and the arguments flipped).
--   
--   <pre>
--   <a>forMOf</a> l a ≡ <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   <a>iforMOf</a> ≡ <a>flip</a> <a>.</a> <a>imapMOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a> i s t a b      -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   </pre>
iforMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> s -> (i -> a -> m b) -> m t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position.
--   
--   When you don't need access to the index <a>mapMOf</a> is more liberal
--   in what it can accept.
--   
--   <pre>
--   <a>mapMOf</a> l ≡ <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a>       i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a>  i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <tt>Bind</tt>  m =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
imapMOf :: Over (Indexed i) (WrappedMonad m) s t a b -> (i -> a -> m b) -> s -> m t

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <a>forOf</a> l a ≡ <a>iforOf</a> l a <a>.</a> <a>const</a>
--   <a>iforOf</a> ≡ <a>flip</a> <a>.</a> <a>itraverseOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <a>Apply</a> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   </pre>
iforOf :: (Indexed i a (f b) -> s -> f t) -> s -> (i -> a -> f b) -> f t

-- | Traversal with an index.
--   
--   <i>NB:</i> When you don't need access to the index then you can just
--   apply your <a>IndexedTraversal</a> directly as a function!
--   
--   <pre>
--   <a>itraverseOf</a> ≡ <a>withIndex</a>
--   <a>traverseOf</a> l = <a>itraverseOf</a> l <a>.</a> <a>const</a> = <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <a>Apply</a> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
itraverseOf :: (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t

-- | Clone an <a>IndexedTraversal1</a> yielding an <a>IndexedTraversal1</a>
--   with the same index.
cloneIndexedTraversal1 :: AnIndexedTraversal1 i s t a b -> IndexedTraversal1 i s t a b

-- | Clone a <a>Traversal1</a> yielding an <a>IndexPreservingTraversal1</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal1 :: ATraversal1 s t a b -> IndexPreservingTraversal1 s t a b

-- | A <a>Traversal1</a> is completely characterized by its behavior on a
--   <a>Bazaar1</a>.
cloneTraversal1 :: ATraversal1 s t a b -> Traversal1 s t a b

-- | Clone an <a>IndexedTraversal</a> yielding an <a>IndexedTraversal</a>
--   with the same index.
cloneIndexedTraversal :: AnIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | Clone a <a>Traversal</a> yielding an <a>IndexPreservingTraversal</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal :: ATraversal s t a b -> IndexPreservingTraversal s t a b

-- | A <a>Traversal</a> is completely characterized by its behavior on a
--   <a>Bazaar</a>.
--   
--   Cloning a <a>Traversal</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Fold</a> and can be used as a way to
--   pass around traversals that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Traversal</a> (or <a>Lens</a>). To
--   clone a <a>Lens</a> as such, use <a>cloneLens</a>.
--   
--   Note: It is usually better to use <a>ReifiedTraversal</a> and
--   <a>runTraversal</a> than to <a>cloneTraversal</a>. The former can
--   execute at full speed, while the latter needs to round trip through
--   the <a>Bazaar</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let foo l a = (view (getting (cloneTraversal l)) a, set (cloneTraversal l) 10 a)
--   
--   &gt;&gt;&gt; foo both ("hello","world")
--   ("helloworld",(10,10))
--   </pre>
--   
--   <pre>
--   <a>cloneTraversal</a> :: <a>LensLike</a> (<a>Bazaar</a> (-&gt;) a b) s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
cloneTraversal :: ATraversal s t a b -> Traversal s t a b

-- | Visit all but the first <i>n</i> targets of a <a>Traversal</a>,
--   <a>Fold</a>, <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") ^? dropping 1 both
--   Just "world"
--   </pre>
--   
--   Dropping works on infinite traversals as well:
--   
--   <pre>
--   &gt;&gt;&gt; [1..] ^? dropping 1 folded
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
dropping :: (Conjoined p, Applicative f) => Int -> Over p (Indexing f) s t a a -> Over p f s t a a

-- | Visit the first <i>n</i> targets of a <a>Traversal</a>, <a>Fold</a>,
--   <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [("hello","world"),("!!!","!!!")]^.. taking 2 (traverse.both)
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1..] ^.. taking 3 traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (taking 5 traverse) succ "hello world"
--   "ifmmp world"
--   </pre>
--   
--   <pre>
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a

-- | Apply a different <a>Traversal</a> or <a>Fold</a> to each side of a
--   <a>Bitraversable</a> container.
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (r s s') (r t t') a b
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Lens</a> s t a b                     -&gt; <a>Lens</a> s' t' a b                     -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Fold</a> s a                         -&gt; <a>Fold</a> s' a                          -&gt; <a>Fold</a> (s,s') a
--   <a>beside</a> :: <a>Getter</a> s a                       -&gt; <a>Getter</a> s' a                        -&gt; <a>Fold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedLens</a> i s t a b            -&gt; <a>IndexedLens</a> i s' t' a b            -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s' a                 -&gt; <a>IndexedFold</a> i (s,s') a
--   <a>beside</a> :: <a>IndexedGetter</a> i s a              -&gt; <a>IndexedGetter</a> i s' a               -&gt; <a>IndexedFold</a> i (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingLens</a> s t a b      -&gt; <a>IndexPreservingLens</a> s' t' a b      -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s' a           -&gt; <a>IndexPreservingFold</a> (s,s') a
--   <a>beside</a> :: <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingGetter</a> s' a         -&gt; <a>IndexPreservingFold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",["world","!!!"])^..beside id traverse
--   ["hello","world","!!!"]
--   </pre>
beside :: (Representable q, Applicative (Rep q), Applicative f, Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b

-- | Traverse both parts of a <a>Bitraversable1</a> container with matching
--   types.
--   
--   Usually that type will be a pair.
--   
--   <pre>
--   <a>both1</a> :: <a>Traversal1</a> (a, a)       (b, b)       a b
--   <a>both1</a> :: <a>Traversal1</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both1 :: forall (r :: Type -> Type -> Type) a b. Bitraversable1 r => Traversal1 (r a a) (r b b) a b

-- | Traverse both parts of a <a>Bitraversable</a> container with matching
--   types.
--   
--   Usually that type will be a pair. Use <a>each</a> to traverse the
--   elements of arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; both *~ 10
--   (10,20)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both length ("hello","world")
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.both
--   "helloworld"
--   </pre>
--   
--   <pre>
--   <a>both</a> :: <a>Traversal</a> (a, a)       (b, b)       a b
--   <a>both</a> :: <a>Traversal</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both :: forall (r :: Type -> Type -> Type) a b. Bitraversable r => Traversal (r a a) (r b b) a b

-- | The non-empty version of <a>holesOf</a>. This extract a non-empty list
--   of immediate children accroding to a given <a>Traversal1</a> as
--   editable contexts.
--   
--   <pre>
--   &gt;&gt;&gt; let head1 f s = runPretext (NonEmpty.head $ holes1Of traversed1 s) f
--   
--   &gt;&gt;&gt; ('a' :| "bc") ^. head1
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('a' :| "bc") &amp; head1 %~ toUpper
--   'A' :| "bc"
--   </pre>
--   
--   <pre>
--   <a>holes1Of</a> :: <a>Iso'</a> s a                 -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>Lens'</a> s a                -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>Traversal1'</a> s a          -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>IndexedLens'</a> i s a       -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (<a>Indexed</a> i) a s)
--   <a>holes1Of</a> :: <a>IndexedTraversal1'</a> i s a -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (<a>Indexed</a> i) a s)
--   </pre>
holes1Of :: Conjoined p => Over p (Bazaar1 p a a) s t a a -> s -> NonEmpty (Pretext p a a t)

-- | The one-level version of <a>contextsOf</a>. This extracts a list of
--   the immediate children according to a given <a>Traversal</a> as
--   editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren l x = <a>toListOf</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>holesOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holesOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holesOf</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   <a>holesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   </pre>
holesOf :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | This converts a <a>Traversal</a> that you "know" will target only one
--   element to a <a>Lens</a>. It can also be used to transform a
--   <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   <a>Traversal</a> targets nothing or more than one element.
--   
--   <pre>
--   &gt;&gt;&gt; Left (ErrorCall "unsafeSingular: empty traversal") &lt;- try (evaluate ([] &amp; unsafeSingular traverse .~ 0)) :: IO (Either ErrorCall [Integer])
--   </pre>
--   
--   <pre>
--   <a>unsafeSingular</a> :: <a>Traversal</a> s t a b          -&gt; <a>Lens</a> s t a b
--   <a>unsafeSingular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>unsafeSingular</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedLens</a> i s t a b
--   <a>unsafeSingular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
unsafeSingular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b

-- | This converts a <a>Traversal</a> that you "know" will target one or
--   more elements to a <a>Lens</a>. It can also be used to transform a
--   non-empty <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   supplied <a>Traversal</a> returns no results.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. singular _head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left (ErrorCall "singular: empty traversal") &lt;- try (evaluate ([] ^. singular _head)) :: IO (Either ErrorCall ())
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^. singular _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] ^. singular (ix 7)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; singular traverse .~ 0
--   []
--   </pre>
--   
--   <pre>
--   <a>singular</a> :: <a>Traversal</a> s t a a          -&gt; <a>Lens</a> s t a a
--   <a>singular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>singular</a> :: <a>IndexedTraversal</a> i s t a a -&gt; <a>IndexedLens</a> i s t a a
--   <a>singular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
singular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
iunsafePartsOf' :: forall i s t a b. Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -> IndexedLens [i] s t [a] [b]
unsafePartsOf' :: ATraversal s t a b -> Lens s t [a] [b]

-- | An indexed version of <a>unsafePartsOf</a> that receives the entire
--   list of indices as its index.
iunsafePartsOf :: (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a b -> Over p f s t [a] [b]

-- | <a>unsafePartsOf</a> turns a <a>Traversal</a> into a <a>uniplate</a>
--   (or <a>biplate</a>) family.
--   
--   If you do not need the types of <tt>s</tt> and <tt>t</tt> to be
--   different, it is recommended that you use <a>partsOf</a>.
--   
--   It is generally safer to traverse with the <a>Bazaar</a> rather than
--   use this combinator. However, it is sometimes convenient.
--   
--   This is unsafe because if you don't supply at least as many
--   <tt>b</tt>'s as you were given <tt>a</tt>'s, then the reconstruction
--   of <tt>t</tt> <i>will</i> result in an error!
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>
--   (and becomes safe).
--   
--   <pre>
--   <a>unsafePartsOf</a> :: <a>Iso</a> s t a b       -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Lens</a> s t a b      -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Traversal</a> s t a b -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Fold</a> s a          -&gt; <a>Getter</a> s [a]
--   <a>unsafePartsOf</a> :: <a>Getter</a> s a        -&gt; <a>Getter</a> s [a]
--   </pre>
unsafePartsOf :: Functor f => Traversing ((->) :: Type -> Type -> Type) f s t a b -> LensLike f s t [a] [b]

-- | A type-restricted version of <a>ipartsOf</a> that can only be used
--   with an <a>IndexedTraversal</a>.
ipartsOf' :: forall i p f s t a. (Indexable [i] p, Functor f) => Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -> Over p f s t [a] [a]

-- | A type-restricted version of <a>partsOf</a> that can only be used with
--   a <a>Traversal</a>.
partsOf' :: ATraversal s t a a -> Lens s t [a] [a]

-- | An indexed version of <a>partsOf</a> that receives the entire list of
--   indices as its index.
ipartsOf :: (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a a -> Over p f s t [a] [a]

-- | <a>partsOf</a> turns a <a>Traversal</a> into a <a>Lens</a> that
--   resembles an early version of the <a>uniplate</a> (or <a>biplate</a>)
--   type.
--   
--   <i>Note:</i> You should really try to maintain the invariant of the
--   number of children in the list.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y,z]
--   (x,y,z)
--   </pre>
--   
--   Any extras will be lost. If you do not supply enough, then the
--   remainder will come from the original structure.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [w,x,y,z]
--   (w,x,y)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y]
--   (x,y,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('b', 'a', 'd', 'c') &amp; partsOf each %~ sort
--   ('a','b','c','d')
--   </pre>
--   
--   So technically, this is only a <a>Lens</a> if you do not change the
--   number of results it returns.
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>.
--   
--   <pre>
--   <a>partsOf</a> :: <a>Iso'</a> s a       -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Traversal'</a> s a -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Fold</a> s a       -&gt; <a>Getter</a> s [a]
--   <a>partsOf</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s [a]
--   </pre>
partsOf :: Functor f => Traversing ((->) :: Type -> Type -> Type) f s t a a -> LensLike f s t [a] [a]

-- | This <a>IndexedTraversal</a> allows you to <a>traverse</a> the
--   individual stores in a <a>Bazaar</a> with access to their indices.
iloci :: IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b

-- | This <a>Traversal</a> allows you to <a>traverse</a> the individual
--   stores in a <a>Bazaar</a>.
loci :: Traversal (Bazaar ((->) :: Type -> Type -> Type) a c s) (Bazaar ((->) :: Type -> Type -> Type) b c s) a b

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanl1</a> ≡ <a>scanl1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanl1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanl1Of :: LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanr1</a> ≡ <a>scanr1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanr1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanr1Of :: LensLike (Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t

-- | This generalizes <a>mapAccumL</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumL</a> ≡ <a>mapAccumLOf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumLOf</a> accumulates <a>State</a> from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>LensLike</a> (<a>State</a> acc) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> l f acc0 s = <a>swap</a> (<a>runState</a> (l (a -&gt; <a>state</a> (acc -&gt; <a>swap</a> (f acc a))) s) acc0)
--   </pre>
mapAccumLOf :: LensLike (State acc) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This generalizes <a>mapAccumR</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumR</a> ≡ <a>mapAccumROf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumROf</a> accumulates <a>State</a> from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>LensLike</a> (<a>Backwards</a> (<a>State</a> acc)) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
mapAccumROf :: LensLike (Backwards (State acc)) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This generalizes <a>transpose</a> to an arbitrary <a>Traversal</a>.
--   
--   Note: <a>transpose</a> handles ragged inputs more intelligently, but
--   for non-ragged inputs:
--   
--   <pre>
--   &gt;&gt;&gt; transposeOf traverse [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   <pre>
--   <a>transpose</a> ≡ <a>transposeOf</a> <a>traverse</a>
--   </pre>
--   
--   Since every <a>Lens</a> is a <a>Traversal</a>, we can use this as a
--   form of monadic strength as well:
--   
--   <pre>
--   <a>transposeOf</a> <a>_2</a> :: (b, [a]) -&gt; [(b, a)]
--   </pre>
transposeOf :: LensLike ZipList s t [a] a -> s -> [t]

-- | Sequence the (monadic) effects targeted by a <a>Lens</a> in a
--   container from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf each ([1,2],[3,4],[5,6])
--   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
--   </pre>
--   
--   <pre>
--   <a>sequence</a> ≡ <a>sequenceOf</a> <a>traverse</a>
--   <a>sequenceOf</a> l ≡ <a>mapMOf</a> l <a>id</a>
--   <a>sequenceOf</a> l ≡ <a>unwrapMonad</a> <a>.</a> l <a>WrapMonad</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t (m b) b       -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t (m b) b      -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t (m b) b -&gt; s -&gt; m t
--   </pre>
sequenceOf :: LensLike (WrappedMonad m) s t (m b) b -> s -> m t

-- | <a>forMOf</a> is a flipped version of <a>mapMOf</a>, consistent with
--   the definition of <a>forM</a>.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf both (1,3) $ \x -&gt; [x, x + 1]
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>forM</a> ≡ <a>forMOf</a> <a>traverse</a>
--   <a>forMOf</a> l ≡ <a>flip</a> (<a>mapMOf</a> l)
--   <a>iforMOf</a> l s ≡ <a>forM</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   </pre>
forMOf :: LensLike (WrappedMonad m) s t a b -> s -> (a -> m b) -> m t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf both (\x -&gt; [x, x + 1]) (1,3)
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>mapM</a> ≡ <a>mapMOf</a> <a>traverse</a>
--   <a>imapMOf</a> l ≡ <a>forM</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
mapMOf :: LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t

-- | Evaluate each action in the structure from left to right, and collect
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf both ([1,2],[3,4])
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>sequenceA</a> ≡ <a>sequenceAOf</a> <a>traverse</a> ≡ <a>traverse</a> <a>id</a>
--   <a>sequenceAOf</a> l ≡ <a>traverseOf</a> l <a>id</a> ≡ l <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t (f b) b       -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t (f b) b      -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t (f b) b -&gt; s -&gt; f t
--   </pre>
sequenceAOf :: LensLike f s t (f b) b -> s -> f t

-- | A version of <a>traverseOf</a> with the arguments flipped, such that:
--   
--   <pre>
--   &gt;&gt;&gt; forOf each (1,2,3) print
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   This function is only provided for consistency, <a>flip</a> is
--   strictly more general.
--   
--   <pre>
--   <a>forOf</a> ≡ <a>flip</a>
--   <a>forOf</a> ≡ <a>flip</a> . <a>traverseOf</a>
--   </pre>
--   
--   <pre>
--   <a>for</a> ≡ <a>forOf</a> <a>traverse</a>
--   <a>ifor</a> l s ≡ <a>for</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   </pre>
forOf :: LensLike f s t a b -> s -> (a -> f b) -> f t

-- | Map each element of a structure targeted by a <a>Lens</a> or
--   <a>Traversal</a>, evaluate these actions from left to right, and
--   collect the results.
--   
--   This function is only provided for consistency, <a>id</a> is strictly
--   more general.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf each print (1,2,3)
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a> ≡ <a>id</a>
--   <a>itraverseOf</a> l ≡ <a>traverseOf</a> l <a>.</a> <a>Indexed</a>
--   <a>itraverseOf</a> <tt>itraversed</tt> ≡ <tt>itraverse</tt>
--   </pre>
--   
--   This yields the obvious law:
--   
--   <pre>
--   <a>traverse</a> ≡ <a>traverseOf</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a> :: <a>Functor</a> f     =&gt; <a>Iso</a> s t a b        -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Functor</a> f     =&gt; <a>Lens</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Apply</a> f       =&gt; <a>Traversal1</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b  -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal</a>.
type ATraversal s t a b = LensLike Bazaar (->) :: Type -> Type -> Type a b s t a b

-- | <pre>
--   type <a>ATraversal'</a> = <a>Simple</a> <a>ATraversal</a>
--   </pre>
type ATraversal' s a = ATraversal s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal1</a>.
type ATraversal1 s t a b = LensLike Bazaar1 (->) :: Type -> Type -> Type a b s t a b

-- | <pre>
--   type <a>ATraversal1'</a> = <a>Simple</a> <a>ATraversal1</a>
--   </pre>
type ATraversal1' s a = ATraversal1 s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal</a>.
type AnIndexedTraversal i s t a b = Over Indexed i Bazaar Indexed i a b s t a b

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal1</a>.
type AnIndexedTraversal1 i s t a b = Over Indexed i Bazaar1 Indexed i a b s t a b

-- | <pre>
--   type <a>AnIndexedTraversal'</a> = <a>Simple</a> (<a>AnIndexedTraversal</a> i)
--   </pre>
type AnIndexedTraversal' i s a = AnIndexedTraversal i s s a a

-- | <pre>
--   type <a>AnIndexedTraversal1'</a> = <a>Simple</a> (<a>AnIndexedTraversal1</a> i)
--   </pre>
type AnIndexedTraversal1' i s a = AnIndexedTraversal1 i s s a a

-- | When you see this as an argument to a function, it expects
--   
--   <ul>
--   <li>to be indexed if <tt>p</tt> is an instance of <a>Indexed</a>
--   i,</li>
--   <li>to be unindexed if <tt>p</tt> is <tt>(-&gt;)</tt>,</li>
--   <li>a <a>Traversal</a> if <tt>f</tt> is <a>Applicative</a>,</li>
--   <li>a <a>Getter</a> if <tt>f</tt> is only a <a>Functor</a> and
--   <a>Contravariant</a>,</li>
--   <li>a <a>Lens</a> if <tt>f</tt> is only a <a>Functor</a>,</li>
--   <li>a <a>Fold</a> if <tt>f</tt> is <a>Applicative</a> and
--   <a>Contravariant</a>.</li>
--   </ul>
type Traversing (p :: Type -> Type -> Type) (f :: Type -> Type) s t a b = Over p BazaarT p f a b s t a b
type Traversing1 (p :: Type -> Type -> Type) (f :: Type -> Type) s t a b = Over p BazaarT1 p f a b s t a b

-- | <pre>
--   type <a>Traversing'</a> f = <a>Simple</a> (<a>Traversing</a> f)
--   </pre>
type Traversing' (p :: Type -> Type -> Type) (f :: Type -> Type) s a = Traversing p f s s a a
type Traversing1' (p :: Type -> Type -> Type) (f :: Type -> Type) s a = Traversing1 p f s s a a

-- | Allows <a>IndexedTraversal</a> the value at the smallest index.
class Ord k => TraverseMin k (m :: Type -> Type) | m -> k

-- | <a>IndexedTraversal</a> of the element with the smallest index.
traverseMin :: TraverseMin k m => IndexedTraversal' k (m v) v

-- | Allows <a>IndexedTraversal</a> of the value at the largest index.
class Ord k => TraverseMax k (m :: Type -> Type) | m -> k

-- | <a>IndexedTraversal</a> of the element at the largest index.
traverseMax :: TraverseMax k m => IndexedTraversal' k (m v) v

-- | Fold a value using a specified <a>Fold</a> and <a>Monoid</a>
--   operations. This is like <a>foldMapBy</a> where the <a>Foldable</a>
--   instance can be manually specified.
--   
--   <pre>
--   <a>foldMapByOf</a> <a>folded</a> ≡ <a>foldMapBy</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapByOf</a> :: <a>Getter</a> s a     -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Fold</a> s a       -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMapByOf both (+) 0 length ("hello","world")
--   10
--   </pre>
foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r

-- | Fold a value using a specified <a>Fold</a> and <a>Monoid</a>
--   operations. This is like <a>foldBy</a> where the <a>Foldable</a>
--   instance can be manually specified.
--   
--   <pre>
--   <a>foldByOf</a> <a>folded</a> ≡ <a>foldBy</a>
--   </pre>
--   
--   <pre>
--   <a>foldByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldByOf both (++) [] ("hello","world")
--   "helloworld"
--   </pre>
foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a

-- | Obtain an <a>IndexedFold</a> by dropping elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: As with <a>droppingWhile</a> applying <a>idroppingWhile</a> to
--   an <a>IndexedLens</a> or <a>IndexedTraversal</a> will still allow you
--   to use it as a pseudo-<a>IndexedTraversal</a>, but if you change the
--   value of the first target to one where the predicate returns
--   <a>True</a>, then you will break the <a>Traversal</a> laws and
--   <a>Traversal</a> fusion will no longer be sound.
idroppingWhile :: (Indexable i p, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | Obtain an <a>IndexedFold</a> by taking elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: Applying <a>itakingWhile</a> to an <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> will still allow you to use it as a
--   pseudo-<a>IndexedTraversal</a>, but if you change the value of any
--   target to one where the predicate returns <a>False</a>, then you will
--   break the <a>Traversal</a> laws and <a>Traversal</a> fusion will no
--   longer be sound.
itakingWhile :: (Indexable i p, Profunctor q, Contravariant f, Applicative f) => (i -> a -> Bool) -> Optical' (Indexed i) q (Const (Endo (f s)) :: Type -> Type) s a -> Optical' p q f s a

-- | Filter an <a>IndexedFold</a> or <a>IndexedGetter</a>, obtaining an
--   <a>IndexedFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,0,0,5,5,5]^..traversed.ifiltered (\i a -&gt; i &lt;= a)
--   [0,5,5,5]
--   </pre>
--   
--   Compose with <a>ifiltered</a> to filter another <a>IndexedLens</a>,
--   <tt>IndexedIso</tt>, <a>IndexedGetter</a>, <a>IndexedFold</a> (or
--   <a>IndexedTraversal</a>) with access to both the value and the index.
--   
--   Note: As with <a>filtered</a>, this is <i>not</i> a legal
--   <a>IndexedTraversal</a>, unless you are very careful not to invalidate
--   the predicate on the target!
ifiltered :: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which satisfy a predicate.
--   
--   <pre>
--   <a>findIndices</a> ≡ <a>findIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndicesOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   <a>findIndicesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   </pre>
findIndicesOf :: IndexedGetting i (Endo [i]) s a -> (a -> Bool) -> s -> [i]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which satisfies a predicate.
--   
--   <pre>
--   <a>findIndex</a> ≡ <a>findIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndexOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   <a>findIndexOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
findIndexOf :: IndexedGetting i (First i) s a -> (a -> Bool) -> s -> Maybe i

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which are equal to a given value.
--   
--   <pre>
--   <a>elemIndices</a> ≡ <a>elemIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; [i]
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; [i]
--   </pre>
elemIndicesOf :: Eq a => IndexedGetting i (Endo [i]) s a -> a -> s -> [i]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which is equal to a given value.
--   
--   <pre>
--   <a>elemIndex</a> ≡ <a>elemIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
elemIndexOf :: Eq a => IndexedGetting i (First i) s a -> a -> s -> Maybe i

-- | Perform an *UNSAFE* <a>head</a> (with index) of an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> assuming that it is there.
--   
--   <pre>
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; (i, a)
--   </pre>
(^@?!) :: HasCallStack => s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)
infixl 8 ^@?!

-- | Perform a safe <a>head</a> (with index) of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> or retrieve <a>Just</a> the index and result
--   from an <a>IndexedGetter</a> or <a>IndexedLens</a>.
--   
--   When using a <a>IndexedTraversal</a> as a partial <a>IndexedLens</a>,
--   or an <a>IndexedFold</a> as a partial <a>IndexedGetter</a> this can be
--   a convenient way to extract the optional value.
--   
--   <pre>
--   (<a>^@?</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; <a>Maybe</a> (i, a)
--   </pre>
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)
infixl 8 ^@?

-- | An infix version of <a>itoListOf</a>.
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
infixl 8 ^@..

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <a>toListOf</a> is more flexible in what it accepts.
--   
--   <pre>
--   <a>toListOf</a> l ≡ <a>map</a> <a>snd</a> <a>.</a> <a>itoListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>itoListOf</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [(i,a)]
--   </pre>
itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <a>foldlMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlMOf</a> l ≡ <a>ifoldlMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldlMOf :: Monad m => IndexedGetting i (Endo (r -> m r)) s a -> (i -> r -> a -> m r) -> r -> s -> m r

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <a>foldrMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrMOf</a> l ≡ <a>ifoldrMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s a -> (i -> a -> r -> m r) -> r -> s -> m r

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf'</a> l ≡ <a>ifoldlOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf'</a> :: <a>IndexedGetter</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedFold</a> i s a         -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedLens'</a> i s a        -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedTraversal'</a> i s a   -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf' :: IndexedGetting i (Endo (r -> r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | <i>Strictly</i> fold right over the elements of a structure with an
--   index.
--   
--   When you don't need access to the index then <a>foldrOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf'</a> l ≡ <a>ifoldrOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf'</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf' :: IndexedGetting i (Dual (Endo (r -> r))) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | The <a>ifindMOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a monadic predicate that is also supplied the
--   index, a structure and returns in the monad the left-most element of
--   the structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   When you don't need access to the index then <a>findMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findMOf</a> l ≡ <a>ifindMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
ifindMOf :: Monad m => IndexedGetting i (Endo (m (Maybe a))) s a -> (i -> a -> m Bool) -> s -> m (Maybe a)

-- | The <a>ifindOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a predicate that is also supplied the index,
--   a structure and returns the left-most element of the structure
--   matching the predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findOf</a> l ≡ <a>ifindOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
ifindOf :: IndexedGetting i (Endo (Maybe a)) s a -> (i -> a -> Bool) -> s -> Maybe a

-- | Concatenate the results of a function of the elements of an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you don't need access to the index then <a>concatMapOf</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>concatMapOf</a> l ≡ <a>iconcatMapOf</a> l <a>.</a> <a>const</a>
--   <a>iconcatMapOf</a> ≡ <a>ifoldMapOf</a>
--   </pre>
--   
--   <pre>
--   <a>iconcatMapOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
iconcatMapOf :: IndexedGetting i [r] s a -> (i -> a -> [r]) -> s -> [r]

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforMOf_</a> ≡ <a>flip</a> <a>.</a> <a>imapMOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forMOf_</a> l a ≡ <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   </pre>
iforMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> s -> (i -> a -> m r) -> m ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>mapMOf_</a> l ≡ <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
imapMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> (i -> a -> m r) -> s -> m ()

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforOf_</a> ≡ <a>flip</a> <a>.</a> <a>itraverseOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forOf_</a> l a ≡ <a>iforOf_</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   </pre>
iforOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> s -> (i -> a -> f r) -> f ()

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <a>traverseOf_</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>traverseOf_</a> l ≡ <a>itraverseOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
itraverseOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> (i -> a -> f r) -> s -> f ()

-- | Return whether or not none of the elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>noneOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>noneOf</a> l ≡ <a>inoneOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>inoneOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
inoneOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not all elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>allOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>allOf</a> l ≡ <a>iallOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
iallOf :: IndexedGetting i All s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not any element viewed through an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> satisfy a predicate, with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>anyOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>anyOf</a> l ≡ <a>ianyOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
ianyOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Left-associative fold of the parts of a structure that are viewed
--   through an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access
--   to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldlOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf</a> l ≡ <a>ifoldlOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf :: IndexedGetting i (Dual (Endo r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Right-associative fold of parts of a structure that are viewed through
--   an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldrOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf</a> l ≡ <a>ifoldrOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf :: IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Fold an <a>IndexedFold</a> or <a>IndexedTraversal</a> by mapping
--   indices and values to an arbitrary <a>Monoid</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMapOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMapOf</a> l ≡ <a>ifoldMapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldMapOf</a> ::             <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> ::             <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   </pre>
ifoldMapOf :: IndexedGetting i m s a -> (i -> a -> m) -> s -> m

-- | This allows you to <a>traverse</a> the elements of a pretty much any
--   <a>LensLike</a> construction in the opposite order.
--   
--   This will preserve indexes on <a>Indexed</a> types and will give you
--   the elements of a (finite) <a>Fold</a> or <a>Traversal</a> in the
--   opposite order.
--   
--   This has no practical impact on a <a>Getter</a>, <a>Setter</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <i>NB:</i> To write back through an <a>Iso</a>, you want to use
--   <a>from</a>. Similarly, to write back through an <a>Prism</a>, you
--   want to use <a>re</a>.
backwards :: (Profunctor p, Profunctor q) => Optical p q (Backwards f) s t a b -> Optical p q f s t a b

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or a function of
--   <a>Just</a> the index and result from an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuses</a> = <a>uses</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreuses :: MonadState s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>) into the current state.
--   
--   <pre>
--   <a>preuses</a> = <a>uses</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
preuses :: MonadState s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> (or <a>Just</a> the index and result from
--   an <a>IndexedGetter</a> or <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuse</a> = <a>use</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreuse :: MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>) into
--   the current state.
--   
--   <pre>
--   <a>preuse</a> = <a>use</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or <a>Just</a> the
--   result from an <a>IndexedGetter</a> or <a>IndexedLens</a>). See also
--   (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreviews</a> = <a>views</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreviews</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreviews :: MonadReader s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>).
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
previews :: MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>). See also (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreview</a> = <a>view</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreview</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; <a>Maybe</a> (i, a)
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreview :: MonadReader s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>). See
--   also <a>firstOf</a> and <a>^?</a>, which are similar with some subtle
--   differences (explained below).
--   
--   <pre>
--   <a>listToMaybe</a> <a>.</a> <a>toList</a> ≡ <a>preview</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>preview</a> = <a>view</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   Unlike <a>^?</a>, this function uses a <a>MonadReader</a> to read the
--   value to be focused in on. This allows one to pass the value as the
--   last argument by using the <a>MonadReader</a> instance for <tt>(-&gt;)
--   s</tt> However, it may also be used as part of some deeply nested
--   transformer stack.
--   
--   <a>preview</a> uses a monoidal value to obtain the result. This means
--   that it generally has good performance, but can occasionally cause
--   space leaks or even stack overflows on some data types. There is
--   another function, <a>firstOf</a>, which avoids these issues at the
--   cost of a slight constant performance cost and a little less
--   flexibility.
--   
--   It may be helpful to think of <a>preview</a> as having one of the
--   following more specialized types:
--   
--   <pre>
--   <a>preview</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   <pre>
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)

-- | This converts an <a>IndexedFold</a> to an <a>IndexPreservingGetter</a>
--   that returns the first index and element, if they exist, as a
--   <a>Maybe</a>.
--   
--   <pre>
--   <a>ipre</a> :: <a>IndexedGetter</a> i s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedFold</a> i s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedTraversal'</a> i s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedLens'</a> i s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   </pre>
ipre :: IndexedGetting i (First (i, a)) s a -> IndexPreservingGetter s (Maybe (i, a))

-- | This converts a <a>Fold</a> to a <a>IndexPreservingGetter</a> that
--   returns the first element, if it exists, as a <a>Maybe</a>.
--   
--   <pre>
--   <a>pre</a> :: <a>Getter</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Fold</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Traversal'</a> s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Lens'</a> s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Iso'</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Prism'</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   </pre>
pre :: Getting (First a) s a -> IndexPreservingGetter s (Maybe a)

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> has no matches.
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Left 12)
--   False
--   </pre>
hasn't :: Getting All s a -> s -> Bool

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> matches 1 or more
--   entries.
--   
--   <pre>
--   &gt;&gt;&gt; has (element 0) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>has</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
--   
--   <pre>
--   <a>foldlM</a> ≡ <a>foldlMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldlMOf :: Monad m => Getting (Endo (r -> m r)) s a -> (r -> a -> m r) -> r -> s -> m r

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
--   
--   <pre>
--   <a>foldrM</a> ≡ <a>foldrMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldrMOf :: Monad m => Getting (Dual (Endo (r -> m r))) s a -> (a -> r -> m r) -> r -> s -> m r

-- | A variant of <a>foldlOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldl1Of'</a> l f ≡ <a>foldl1'</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldl1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of' :: HasCallStack => Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldrOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldr1Of</a> l f ≡ <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldr1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of' :: HasCallStack => Getting (Dual (Endo (Endo (Maybe a)))) s a -> (a -> a -> a) -> s -> a

-- | Fold over the elements of a structure, associating to the left, but
--   strictly.
--   
--   <pre>
--   <a>foldl'</a> ≡ <a>foldlOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf'</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf' :: Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | Strictly fold right over the elements of a structure.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>foldrOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf' :: Getting (Dual (Endo (Endo r))) s a -> (a -> r -> r) -> r -> s -> r

-- | A variant of <a>foldlOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> l f ≡ <a>foldl1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldl1</a> ≡ <a>foldl1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of :: HasCallStack => Getting (Dual (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldrOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> l f ≡ <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldr1</a> ≡ <a>foldr1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of :: HasCallStack => Getting (Endo (Maybe a)) s a -> (a -> a -> a) -> s -> a

-- | The <a>lookupOf</a> function takes a <a>Fold</a> (or <a>Getter</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a>, etc.), a key, and a
--   structure containing key/value pairs. It returns the first value
--   corresponding to the given key. This function generalizes
--   <a>lookup</a> to work on an arbitrary <a>Fold</a> instead of lists.
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf folded 4 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'b'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf each 2 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'a'
--   </pre>
--   
--   <pre>
--   <a>lookupOf</a> :: <a>Eq</a> k =&gt; <a>Fold</a> s (k,v) -&gt; k -&gt; s -&gt; <a>Maybe</a> v
--   </pre>
lookupOf :: Eq k => Getting (Endo (Maybe v)) s (k, v) -> k -> s -> Maybe v

-- | The <a>findMOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a monadic predicate and
--   a structure and returns in the monad the leftmost element of the
--   structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,4,6)
--   "Checking 1"
--   "Checking 3"
--   "Checking 4"
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,5,7)
--   "Checking 1"
--   "Checking 3"
--   "Checking 5"
--   "Checking 7"
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Getter</a> s a)     -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Fold</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Iso'</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Lens'</a> s a)      -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Traversal'</a> s a) -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> <a>folded</a> :: (Monad m, Foldable f) =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (Maybe a)
--   <a>ifindMOf</a> l ≡ <a>findMOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findMOf</a> :: Monad m =&gt; <a>Getting</a> (<a>Endo</a> (m (<a>Maybe</a> a))) s a -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> l p = <a>foldrOf</a> l (a y -&gt; p a &gt;&gt;= x -&gt; if x then return (<a>Just</a> a) else y) $ return <a>Nothing</a>
--   </pre>
findMOf :: Monad m => Getting (Endo (m (Maybe a))) s a -> (a -> m Bool) -> s -> m (Maybe a)

-- | The <a>findOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a predicate and a
--   structure and returns the leftmost element of the structure matching
--   the predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findOf each even (1,3,4,6)
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findOf folded even [1,3,5,7]
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   <pre>
--   <a>find</a> ≡ <a>findOf</a> <a>folded</a>
--   <a>ifindOf</a> l ≡ <a>findOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findOf</a> :: <a>Getting</a> (<a>Endo</a> (<a>Maybe</a> a)) s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> l p = <a>foldrOf</a> l (a y -&gt; if p a then <a>Just</a> a else y) <a>Nothing</a>
--   </pre>
findOf :: Getting (Endo (Maybe a)) s a -> (a -> Bool) -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a> or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   &gt;&gt;&gt; minimumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "ham"
--   </pre>
--   
--   <pre>
--   <a>minimumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>minimumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "mustard"
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   <a>maximumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>maximumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | Obtain the minimum element targeted by a <a>Fold1</a> or
--   <a>Traversal1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; minimum1Of traverse1 (1 :| [2..10])
--   1
--   </pre>
--   
--   <pre>
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
minimum1Of :: Ord a => Getting (Min a) s a -> s -> a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>minimumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>minimum</a> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <a>getMin</a>
--   (<a>foldMapOf</a> l <a>Min</a>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Obtain the maximum element targeted by a <a>Fold1</a> or
--   <a>Traversal1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximum1Of traverse1 (1 :| [2..10])
--   10
--   </pre>
--   
--   <pre>
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
maximum1Of :: Ord a => Getting (Max a) s a -> s -> a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>maximumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 6
--   </pre>
--   
--   <pre>
--   <a>maximum</a> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <a>getMax</a>
--   (<a>foldMapOf</a> l <a>Max</a>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has any
--   targets in the given container.
--   
--   A more "conversational" alias for this combinator is <a>has</a>.
--   
--   Note: <a>notNullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>True</a>.
--   
--   <pre>
--   <a>not</a> <a>.</a> <a>null</a> ≡ <a>notNullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <tt><a>not</a> <a>.</a>
--   <a>null</a></tt> check of many containers.
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf _1 (1,2)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf traverse [1..10]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf folded []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf (element 20) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notNullOf :: Getting Any s a -> s -> Bool

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has no
--   targets in the given container.
--   
--   Note: <a>nullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>False</a>.
--   
--   <pre>
--   <a>null</a> ≡ <a>nullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <a>null</a> check of
--   many containers.
--   
--   <pre>
--   &gt;&gt;&gt; nullOf _1 (1,2)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf ignored ()
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf traverse []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf (element 20) [1..10]
--   True
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
nullOf :: Getting All s a -> s -> Bool

-- | Retrieve the <a>Last</a> entry of a <a>Fold1</a> or <a>Traversal1</a>
--   or retrieve the result from a <a>Getter</a> or <a>Lens</a>.o
--   
--   <pre>
--   &gt;&gt;&gt; last1Of traverse1 (1 :| [2..10])
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last1Of both1 (1,2)
--   2
--   </pre>
--   
--   <pre>
--   <a>last1Of</a> :: <a>Getter</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Fold1</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Lens'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Iso'</a> s a        -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
last1Of :: Getting (Last a) s a -> s -> a

-- | Retrieve the <a>Last</a> entry of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><tt>ala</tt> <a>Last</a> <a>.</a> <a>foldMapOf</a></tt> and gives
--   you back access to the outermost <a>Just</a> constructor more quickly,
--   but may have worse constant factors.
--   
--   <pre>
--   &gt;&gt;&gt; lastOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf both (1,2)
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>lastOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
lastOf :: Getting (Rightmost a) s a -> s -> Maybe a

-- | Retrieve the <a>First</a> entry of a <a>Fold1</a> or <a>Traversal1</a>
--   or the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; first1Of traverse1 (1 :| [2..10])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first1Of both1 (1,2)
--   1
--   </pre>
--   
--   <i>Note:</i> this is different from <a>^.</a>.
--   
--   <pre>
--   &gt;&gt;&gt; first1Of traverse1 ([1,2] :| [[3,4],[5,6]])
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ([1,2] :| [[3,4],[5,6]]) ^. traverse1
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   <a>first1Of</a> :: <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
first1Of :: Getting (First a) s a -> s -> a

-- | Retrieve the <a>First</a> entry of a <a>Fold</a> or <a>Traversal</a>
--   or retrieve <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><a>preview</a></tt> or <tt>^?'</tt> and gives you back access to
--   the outermost <a>Just</a> constructor more quickly, but does so in a
--   way that builds an intermediate structure, and thus may have worse
--   constant factors. This also means that it can not be used in any
--   <a>MonadReader</a>, but must instead have <tt>s</tt> passed as its
--   last argument, unlike <a>preview</a>.
--   
--   Note: this could been named <tt>headOf</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; firstOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf both (1,2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>firstOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
firstOf :: Getting (Leftmost a) s a -> s -> Maybe a

-- | Perform an *UNSAFE* <a>head</a> of a <a>Fold</a> or <a>Traversal</a>
--   assuming that it is there.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?! _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^?! ix 3
--   'l'
--   </pre>
--   
--   <pre>
--   (<a>^?!</a>) :: s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Fold</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; a
--   </pre>
(^?!) :: HasCallStack => s -> Getting (Endo a) s a -> a
infixl 8 ^?!

-- | Perform a safe <a>head</a> of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   When using a <a>Traversal</a> as a partial <a>Lens</a>, or a
--   <a>Fold</a> as a partial <a>Getter</a> this can be a convenient way to
--   extract the optional value.
--   
--   Note: if you get stack overflows due to this, you may want to use
--   <a>firstOf</a> instead, which can deal more gracefully with heavily
--   left-biased trees. This is because <a>^?</a> works by using the
--   <a>First</a> monoid, which can occasionally cause space leaks.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?_Left
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 4 ^?_Left
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 3
--   Just 'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 20
--   Nothing
--   </pre>
--   
--   This operator works as an infix version of <a>preview</a>.
--   
--   <pre>
--   (<a>^?</a>) ≡ <a>flip</a> <a>preview</a>
--   </pre>
--   
--   It may be helpful to think of <a>^?</a> as having one of the following
--   more specialized types:
--   
--   <pre>
--   (<a>^?</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Fold</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; <a>Maybe</a> a
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a
infixl 8 ^?

-- | Calculate the number of targets there are for a <a>Fold</a> in a given
--   container.
--   
--   <i>Note:</i> This can be rather inefficient for large containers and
--   just like <a>length</a>, this will not terminate for infinite folds.
--   
--   <pre>
--   <a>length</a> ≡ <a>lengthOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf _1 ("hello",())
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf traverse [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf (traverse.traverse) [[1,2],[3,4],[5,6]]
--   6
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> (<a>folded</a> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a) -&gt; <a>Int</a>
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Int</a>
--   </pre>
lengthOf :: Getting (Endo (Endo Int)) s a -> s -> Int

-- | Concatenate all of the lists targeted by a <a>Fold</a> into a longer
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; concatOf both ("pan","ama")
--   "panama"
--   </pre>
--   
--   <pre>
--   <a>concat</a> ≡ <a>concatOf</a> <a>folded</a>
--   <a>concatOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>concatOf</a> :: <a>Getter</a> s [r]     -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Fold</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Iso'</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Lens'</a> s [r]      -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Traversal'</a> s [r] -&gt; s -&gt; [r]
--   </pre>
concatOf :: Getting [r] s [r] -> s -> [r]

-- | Map a function over all the targets of a <a>Fold</a> of a container
--   and concatenate the resulting lists.
--   
--   <pre>
--   &gt;&gt;&gt; concatMapOf both (\x -&gt; [x, x + 1]) (1,3)
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   <a>concatMap</a> ≡ <a>concatMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>concatMapOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
concatMapOf :: Getting [r] s a -> (a -> [r]) -> s -> [r]

-- | Does the element not occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'd' ('a','b','c')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'a' ('a','b','c')
--   False
--   </pre>
--   
--   <pre>
--   <a>notElem</a> ≡ <a>notElemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notElemOf :: Eq a => Getting All s a -> a -> s -> Bool

-- | Does the element occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; elemOf both "hello" ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>elem</a> ≡ <a>elemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
elemOf :: Eq a => Getting Any s a -> a -> s -> Bool

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; msumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>msum</a> ≡ <a>msumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m a
--   </pre>
msumOf :: MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>asum</a> ≡ <a>asumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f a
--   </pre>
asumOf :: Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a

-- | Evaluate each monadic action referenced by a <a>Fold</a> on the
--   structure from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequence_</a> ≡ <a>sequenceOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m ()
--   </pre>
sequenceOf_ :: Monad m => Getting (Sequenced a m) s (m a) -> s -> m ()

-- | <a>forMOf_</a> is <a>mapMOf_</a> with two of its arguments flipped.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>forM_</a> ≡ <a>forMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   </pre>
forMOf_ :: Monad m => Getting (Sequenced r m) s a -> s -> (a -> m r) -> m ()

-- | Map each target of a <a>Fold</a> on a structure to a monadic action,
--   evaluate these actions from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>mapM_</a> ≡ <a>mapMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
mapMOf_ :: Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()

-- | See <a>sequenceAOf_</a> and <a>traverse1Of_</a>.
--   
--   <pre>
--   <a>sequence1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s (f a) -&gt; s -&gt; f ()
--   </pre>
sequence1Of_ :: Functor f => Getting (TraversedF a f) s (f a) -> s -> f ()

-- | See <a>forOf_</a> and <a>traverse1Of_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for1Of_ both1 ("abc", "bcd") (\ks -&gt; Map.fromList [ (k, ()) | k &lt;- ks ])
--   fromList [('b',()),('c',())]
--   </pre>
--   
--   <pre>
--   <a>for1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   </pre>
for1Of_ :: Functor f => Getting (TraversedF r f) s a -> s -> (a -> f r) -> f ()

-- | Traverse over all of the targets of a <a>Fold1</a>, computing an
--   <a>Apply</a> based answer.
--   
--   As long as you have <a>Applicative</a> or <a>Functor</a> effect you
--   are better using <a>traverseOf_</a>. The <a>traverse1Of_</a> is useful
--   only when you have genuine <a>Apply</a> effect.
--   
--   <pre>
--   &gt;&gt;&gt; traverse1Of_ both1 (\ks -&gt; Map.fromList [ (k, ()) | k &lt;- ks ]) ("abc", "bcd")
--   fromList [('b',()),('c',())]
--   </pre>
--   
--   <pre>
--   <a>traverse1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
traverse1Of_ :: Functor f => Getting (TraversedF r f) s a -> (a -> f r) -> s -> f ()

-- | Evaluate each action in observed by a <a>Fold</a> on a structure from
--   left to right, ignoring the results.
--   
--   <pre>
--   <a>sequenceA_</a> ≡ <a>sequenceAOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f ()
--   </pre>
sequenceAOf_ :: Functor f => Getting (Traversed a f) s (f a) -> s -> f ()

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>forOf</a> do not construct a new structure. <a>forOf_</a>
--   generalizes <a>for_</a> to work over any <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>forOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>forOf_</a> requires
--   an <a>Applicative</a>.
--   
--   <pre>
--   <a>for_</a> ≡ <a>forOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; forOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   The rather specific signature of <a>forOf_</a> allows it to be used as
--   if the signature was any of:
--   
--   <pre>
--   <a>iforOf_</a> l s ≡ <a>forOf_</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   </pre>
forOf_ :: Functor f => Getting (Traversed r f) s a -> s -> (a -> f r) -> f ()

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>traverseOf</a> do not construct a new structure.
--   <a>traverseOf_</a> generalizes <a>traverse_</a> to work over any
--   <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>traverseOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>traverseOf_</a>
--   requires an <a>Applicative</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>traverse_</a> ≡ <a>traverseOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf_</a> <tt>_2</tt> :: <a>Functor</a> f =&gt; (c -&gt; f r) -&gt; (d, c) -&gt; f ()
--   <a>traverseOf_</a> <a>_Left</a> :: <a>Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a>Either</a> a c -&gt; f ()
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> l ≡ <a>traverseOf_</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   The rather specific signature of <a>traverseOf_</a> allows it to be
--   used as if the signature was any of:
--   
--   <pre>
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
traverseOf_ :: Functor f => Getting (Traversed r f) s a -> (a -> f r) -> s -> f ()

-- | Calculate the <a>Sum</a> of every number targeted by a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf both (5,6)
--   11
--   
--   &gt;&gt;&gt; sumOf folded [1,2,3,4]
--   10
--   
--   &gt;&gt;&gt; sumOf (folded.both) [(1,2),(3,4)]
--   10
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; sumOf biplate [(1::Int,[]),(2,[(3::Int,4::Int)])] :: Int
--   10
--   </pre>
--   
--   <pre>
--   <a>sum</a> ≡ <a>sumOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <a>Sum</a> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>sumOf</a> <tt>_1</tt> :: <a>Num</a> a =&gt; (a, b) -&gt; a
--   <a>sumOf</a> (<a>folded</a> <a>.</a> <a>_1</a>) :: (<a>Foldable</a> f, <a>Num</a> a) =&gt; f (a, b) -&gt; a
--   </pre>
--   
--   <pre>
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
sumOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Calculate the <a>Product</a> of every number targeted by a
--   <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; productOf both (4,5)
--   20
--   
--   &gt;&gt;&gt; productOf folded [1,2,3,4,5]
--   120
--   </pre>
--   
--   <pre>
--   <a>product</a> ≡ <a>productOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <a>Product</a> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
productOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf both (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a> ≡ <a>allOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> l = <a>allOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>allOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf both (=='x') ('x','y')
--   True
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; anyOf biplate (== "world") (((),2::Int),"hello",("world",11::Int))
--   True
--   </pre>
--   
--   <pre>
--   <a>any</a> ≡ <a>anyOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> l ≡ <a>anyOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; orOf both (True,False)
--   True
--   
--   &gt;&gt;&gt; orOf both (False,False)
--   False
--   </pre>
--   
--   <pre>
--   <a>or</a> ≡ <a>orOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>orOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
orOf :: Getting Any s Bool -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; andOf both (True,False)
--   False
--   
--   &gt;&gt;&gt; andOf both (True,True)
--   True
--   </pre>
--   
--   <pre>
--   <a>and</a> ≡ <a>andOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>andOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
andOf :: Getting All s Bool -> s -> Bool

-- | A convenient infix (flipped) version of <a>toListOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [[1,2],[3]]^..id
--   [[[1,2],[3]]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse
--   [[1,2],[3]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse.traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^..both
--   [1,2]
--   </pre>
--   
--   <pre>
--   <a>toList</a> xs ≡ xs <a>^..</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
--   
--   <pre>
--   (<a>^..</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>a</a> :: s -&gt; <a>Fold</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Lens'</a> s a      -&gt; <a>a</a> :: s -&gt; <a>Iso'</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Traversal'</a> s a -&gt; <a>a</a> :: s -&gt; <a>Prism'</a> s a     -&gt; [a]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]
infixl 8 ^..

-- | Extract a <a>NonEmpty</a> of the targets of <a>Fold1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmptyOf both1 ("hello", "world")
--   "hello" :| ["world"]
--   </pre>
--   
--   <pre>
--   <a>toNonEmptyOf</a> :: <a>Getter</a> s a      -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Fold1</a> s a       -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Lens'</a> s a       -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Iso'</a> s a        -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Prism'</a> s a      -&gt; s -&gt; NonEmpty a
--   </pre>
toNonEmptyOf :: Getting (NonEmptyDList a) s a -> s -> NonEmpty a

-- | Extract a list of the targets of a <a>Fold</a>. See also (<a>^..</a>).
--   
--   <pre>
--   <a>toList</a> ≡ <a>toListOf</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
toListOf :: Getting (Endo [a]) s a -> s -> [a]

-- | Left-associative fold of the parts of a structure that are viewed
--   through a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>foldlOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Prism'</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf :: Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | Right-associative fold of parts of a structure that are viewed through
--   a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>foldrOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> l ≡ <a>foldrOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getting</a> (<a>Endo</a> r) s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf :: Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r

-- | Combine the elements of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> using a monoid.
--   
--   <pre>
--   &gt;&gt;&gt; foldOf (folded.folded) [[Sum 1,Sum 4],[Sum 8, Sum 8],[Sum 21]]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>fold</a> = <a>foldOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a> ::             <a>Getter</a> s m     -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Lens'</a> s m      -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Iso'</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Prism'</a> s m     -&gt; s -&gt; m
--   </pre>
foldOf :: Getting a s a -> s -> a

-- | Map each part of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> to a monoid and combine
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMapOf (folded . both . _Just) Sum [(Just 21, Just 21)]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>foldMap</a> = <a>foldMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> ≡ <a>views</a>
--   <a>ifoldMapOf</a> l = <a>foldMapOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> ::                <a>Getter</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Fold</a> s a        -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Semigroup</a> r =&gt; <a>Fold1</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::                <a>Lens'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::                <a>Iso'</a> s a        -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Traversal'</a> s a  -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Semigroup</a> r =&gt; <a>Traversal1'</a> s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Prism'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> :: <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
foldMapOf :: Getting r s a -> (a -> r) -> s -> r

-- | A <a>Fold</a> over the individual <a>lines</a> of a <a>String</a>.
--   
--   <pre>
--   <a>lined</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>lined</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   newline characters while traversing, and if your original
--   <a>String</a> contains only isolated newline characters.
lined :: forall (f :: Type -> Type). Applicative f => IndexedLensLike' Int f String String

-- | A <a>Fold</a> over the individual <a>words</a> of a <a>String</a>.
--   
--   <pre>
--   <a>worded</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>worded</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   whitespace characters while traversing, and if your original
--   <a>String</a> contains only isolated space characters (and no other
--   characters that count as space, such as non-breaking spaces).
worded :: forall (f :: Type -> Type). Applicative f => IndexedLensLike' Int f String String

-- | Obtain a <a>Fold</a> by dropping elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>dropWhile</a> p ≡ <a>toListOf</a> (<a>droppingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1..6]
--   [4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1,6,1]
--   [6,1]
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a                -- see notes
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingTraversal'</a> s a    -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingLens'</a> s a         -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingFold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s a
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: Many uses of this combinator will yield something that meets the
--   types, but not the laws of a valid <a>Traversal</a> or
--   <a>IndexedTraversal</a>. The <a>Traversal</a> and
--   <a>IndexedTraversal</a> laws are only satisfied if the new values you
--   assign to the first target also does not pass the predicate! Otherwise
--   subsequent traversals will visit fewer elements and <a>Traversal</a>
--   fusion is not sound.
--   
--   So for any traversal <tt>t</tt> and predicate <tt>p</tt>,
--   <tt><a>droppingWhile</a> p t</tt> may not be lawful, but
--   <tt>(<a>dropping</a> 1 . <a>droppingWhile</a> p) t</tt> is. For
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; let l  :: Traversal' [Int] Int; l  = droppingWhile (&lt;= 1) traverse
--   
--   &gt;&gt;&gt; let l' :: Traversal' [Int] Int; l' = dropping 1 l
--   </pre>
--   
--   <tt>l</tt> is not a lawful setter because <tt><a>over</a> l f .
--   <a>over</a> l g ≢ <a>over</a> l (f . g)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; l .~ 0 &amp; l .~ 4
--   [1,0,0]
--   
--   &gt;&gt;&gt; [1,2,3] &amp; l .~ 4
--   [1,4,4]
--   </pre>
--   
--   <tt>l'</tt> on the other hand behaves lawfully:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; l' .~ 0 &amp; l' .~ 4
--   [1,2,4]
--   
--   &gt;&gt;&gt; [1,2,3] &amp; l' .~ 4
--   [1,2,4]
--   </pre>
droppingWhile :: (Conjoined p, Profunctor q, Applicative f) => (a -> Bool) -> Optical p q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | Obtain a <a>Fold</a> by taking elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>takeWhile</a> p ≡ <a>toListOf</a> (<a>takingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ toListOf (takingWhile (&lt;=3) folded) [1..]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   <i>Note:</i> When applied to a <a>Traversal</a>, <a>takingWhile</a>
--   yields something that can be used as if it were a <a>Traversal</a>,
--   but which is not a <a>Traversal</a> per the laws, unless you are
--   careful to ensure that you do not invalidate the predicate when
--   writing back through it.
takingWhile :: (Conjoined p, Applicative f) => (a -> Bool) -> Over p (TakingWhile p f a a) s t a a -> Over p f s t a a

-- | Obtain a potentially empty <a>IndexedTraversal</a> by taking the first
--   element from another, potentially empty <a>Fold</a> and using it as an
--   index.
--   
--   The resulting optic can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   <pre>
--   &gt;&gt;&gt; [(Just 2, 3), (Nothing, 4)] &amp; mapped . filteredBy (_1 . _Just) &lt;. _2 %@~ (*) :: [(Maybe Int, Int)]
--   [(Just 2,6),(Nothing,4)]
--   </pre>
--   
--   <pre>
--   <a>filteredBy</a> :: <a>Fold</a> a i -&gt; <a>IndexedTraversal'</a> i a a
--   </pre>
--   
--   Note: As with <a>filtered</a>, this is <i>not</i> a legal
--   <a>IndexedTraversal</a>, unless you are very careful not to invalidate
--   the predicate on the target!
filteredBy :: (Indexable i p, Applicative f) => Getting (First i) a i -> p a (f a) -> a -> f a

-- | Obtain a <a>Fold</a> that can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   Note: This is <i>not</i> a legal <a>Traversal</a>, unless you are very
--   careful not to invalidate the predicate on the target.
--   
--   Note: This is also <i>not</i> a legal <a>Prism</a>, unless you are
--   very careful not to inject a value that fails the predicate.
--   
--   As a counter example, consider that given <tt>evens = <a>filtered</a>
--   <a>even</a></tt> the second <a>Traversal</a> law is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   <pre>
--   &gt;&gt;&gt; [1..10]^..folded.filtered even
--   [2,4,6,8,10]
--   </pre>
--   
--   This will preserve an index if it is present.
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a

-- | <tt>x <a>^.</a> <a>iterated</a> f</tt> returns an infinite
--   <a>Fold1</a> of repeated applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   <a>toListOf</a> (<a>iterated</a> f) a ≡ <a>iterate</a> f a
--   </pre>
--   
--   <pre>
--   <a>iterated</a> :: (a -&gt; a) -&gt; <a>Fold1</a> a a
--   </pre>
iterated :: Apply f => (a -> a) -> LensLike' f a a

-- | Build a <a>Fold</a> that unfolds its values from a seed.
--   
--   <pre>
--   <a>unfoldr</a> ≡ <a>toListOf</a> <a>.</a> <a>unfolded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10^..unfolded (\b -&gt; if b == 0 then Nothing else Just (b, b-1))
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfolded :: (b -> Maybe (a, b)) -> Fold b a

-- | Transform a non-empty <a>Fold</a> into a <a>Fold1</a> that loops over
--   its elements over and over.
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1,2,3]^..taking 7 (cycled traverse)
--   [1,2,3,1,2,3,1]
--   </pre>
--   
--   <pre>
--   <a>cycled</a> :: <a>Fold1</a> s a -&gt; <a>Fold1</a> s a
--   </pre>
cycled :: Apply f => LensLike f s t a b -> LensLike f s t a b

-- | A <a>Fold</a> that replicates its input <tt>n</tt> times.
--   
--   <pre>
--   <a>replicate</a> n ≡ <a>toListOf</a> (<a>replicated</a> n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^..replicated 20
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
replicated :: Int -> Fold a a

-- | Form a <a>Fold1</a> by repeating the input forever.
--   
--   <pre>
--   <a>repeat</a> ≡ <a>toListOf</a> <a>repeated</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ 5^..taking 20 repeated
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
--   
--   <pre>
--   <a>repeated</a> :: <a>Fold1</a> a a
--   </pre>
repeated :: Apply f => LensLike' f a a

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
folded64 :: forall (f :: Type -> Type) a. Foldable f => IndexedFold Int64 (f a) a

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
--   
--   <pre>
--   &gt;&gt;&gt; Just 3^..folded
--   [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing^..folded
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(1,2),(3,4)]^..folded.both
--   [1,2,3,4]
--   </pre>
folded :: forall (f :: Type -> Type) a. Foldable f => IndexedFold Int (f a) a

-- | Obtain <tt>FoldWithIndex</tt> by lifting <a>ifoldr</a> like function.
ifoldring :: (Indexable i p, Contravariant f, Applicative f) => ((i -> a -> f a -> f a) -> f a -> s -> f a) -> Over p f s t a b

-- | Obtain a <a>Fold</a> by lifting <a>foldr</a> like function.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..foldring foldr
--   [1,2,3,4]
--   </pre>
foldring :: (Contravariant f, Applicative f) => ((a -> f a -> f a) -> f a -> s -> f a) -> LensLike f s t a b
ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) => (s -> f (i, a)) -> Over p g s t a b

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..folding tail
--   [2,3,4]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a

-- | This is an improper prism for text formatting based on <a>Read</a> and
--   <a>Show</a>.
--   
--   This <a>Prism</a> is "improper" in the sense that it normalizes the
--   text formatting, but round tripping is idempotent given sane
--   <a>Read</a>/<a>Show</a> instances.
--   
--   <pre>
--   &gt;&gt;&gt; _Show # 2
--   "2"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "EQ" ^? _Show :: Maybe Ordering
--   Just EQ
--   </pre>
--   
--   <pre>
--   <a>_Show</a> ≡ <a>prism'</a> <a>show</a> <tt>readMaybe</tt>
--   </pre>
_Show :: (Read a, Show a) => Prism' String a

-- | This <a>Prism</a> compares for approximate equality with a given value
--   and a predicate for testing, an example where the value is the empty
--   list and the predicate checks that a list is empty (same as
--   <a>_Empty</a> with the <a>AsEmpty</a> list instance):
--   
--   <pre>
--   &gt;&gt;&gt; nearly [] null # ()
--   []
--   
--   &gt;&gt;&gt; [1,2,3,4] ^? nearly [] null
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>nearly</a> [] <a>null</a> :: <a>Prism'</a> [a] ()
--   </pre>
--   
--   To comply with the <a>Prism</a> laws the arguments you supply to
--   <tt>nearly a p</tt> are somewhat constrained.
--   
--   We assume <tt>p x</tt> holds iff <tt>x ≡ a</tt>. Under that assumption
--   then this is a valid <a>Prism</a>.
--   
--   This is useful when working with a type where you can test equality
--   for only a subset of its values, and the prism selects such a value.
nearly :: a -> (a -> Bool) -> Prism' a ()

-- | This <a>Prism</a> compares for exact equality with a given value.
--   
--   <pre>
--   &gt;&gt;&gt; only 4 # ()
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^? only 4
--   Nothing
--   </pre>
only :: Eq a => a -> Prism' a ()

-- | <a>Void</a> is a logically uninhabited data type.
--   
--   This is a <a>Prism</a> that will always fail to match.
_Void :: Prism s s a Void

-- | This <a>Prism</a> provides the <a>Traversal</a> of a <a>Nothing</a> in
--   a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Nothing
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just () ^? _Nothing
--   Nothing
--   </pre>
--   
--   But you can turn it around and use it to construct <a>Nothing</a> as
--   well:
--   
--   <pre>
--   &gt;&gt;&gt; _Nothing # ()
--   Nothing
--   </pre>
_Nothing :: Prism' (Maybe a) ()

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the target
--   of the value of <a>Just</a> in a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over _Just (+1) (Just 2)
--   Just 3
--   </pre>
--   
--   Unlike <a>traverse</a> this is a <a>Prism</a>, and so you can use it
--   to inject as well:
--   
--   <pre>
--   &gt;&gt;&gt; _Just # 5
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Just
--   Just 5
--   </pre>
--   
--   Interestingly,
--   
--   <pre>
--   m <tt>^?</tt> <a>_Just</a> ≡ m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just x ^? _Just
--   Just x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Just
--   Nothing
--   </pre>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Left 2)
--   Left 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Right 2)
--   Right 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello" ^._Right
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Right :: [Double]
--   []
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Right # 5
--   Right 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Right
--   Right 5
--   </pre>
_Right :: Prism (Either c a) (Either c b) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Left 2)
--   Left 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Right 2)
--   Right 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 42 ^._Left :: String
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Left
--   "hello"
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
_Left :: Prism (Either a c) (Either b c) a b

-- | Retrieve the value targeted by a <a>Prism</a> or return the original
--   value while allowing the type to change if it does not match.
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Just 12)
--   Right 12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Nothing :: Maybe Int) :: Either (Maybe Bool) Int
--   Left Nothing
--   </pre>
matching :: APrism s t a b -> s -> Either t a

-- | Check to see if this <a>Prism</a> doesn't match.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Left 12)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Empty []
--   False
--   </pre>
--   
--   <pre>
--   <a>isn't</a> = <a>not</a> . <a>is</a>
--   <a>isn't</a> = <tt>hasn't</tt>
--   </pre>
isn't :: APrism s t a b -> s -> Bool

-- | <tt>lift</tt> a <a>Prism</a> through a <a>Traversable</a> functor,
--   giving a Prism that matches only if all the elements of the container
--   match the <a>Prism</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [Left 1, Right "foo", Left 4, Right "woot"]^..below _Right
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [Right "hail hydra!", Right "foo", Right "blah", Right "woot"]^..below _Right
--   [["hail hydra!","foo","blah","woot"]]
--   </pre>
below :: forall (f :: Type -> Type) s a. Traversable f => APrism' s a -> Prism' (f s) (f a)

-- | Use a <a>Prism</a> to work over part of a structure.
aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)

-- | Given a pair of prisms, project sums.
--   
--   Viewing a <a>Prism</a> as a co-<a>Lens</a>, this combinator can be
--   seen to be dual to <a>alongside</a>.
without :: APrism s t a b -> APrism u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)

-- | Use a <a>Prism</a> as a kind of first-class pattern.
--   
--   <pre>
--   <a>outside</a> :: <a>Prism</a> s t a b -&gt; <a>Lens</a> (t -&gt; r) (s -&gt; r) (b -&gt; r) (a -&gt; r)
--   </pre>
outside :: forall (p :: Type -> Type -> Type) s t a b r. Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)

-- | This is usually used to build a <a>Prism'</a>, when you have to use an
--   operation like <a>cast</a> which already returns a <a>Maybe</a>.
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b

-- | Build a <a>Prism</a>.
--   
--   <tt><a>Either</a> t a</tt> is used instead of <tt><a>Maybe</a> a</tt>
--   to permit the types of <tt>s</tt> and <tt>t</tt> to differ.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | Clone a <a>Prism</a> so that you can reuse the same monomorphically
--   typed <a>Prism</a> for different purposes.
--   
--   See <a>cloneLens</a> and <a>cloneTraversal</a> for examples of why you
--   might want to do this.
clonePrism :: APrism s t a b -> Prism s t a b

-- | Convert <a>APrism</a> to the pair of functions that characterize it.
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Prism</a>.
type APrism s t a b = Market a b a Identity b -> Market a b s Identity t

-- | <pre>
--   type APrism' = <a>Simple</a> <a>APrism</a>
--   </pre>
type APrism' s a = APrism s s a a

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> the current state through it the other way, applying a
--   function.
--   
--   <pre>
--   <a>reuses</a> ≡ <a>uses</a> <a>.</a> <a>re</a>
--   <a>reuses</a> (<a>unto</a> f) g ≡ <a>gets</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuses _Left isLeft) (5 :: Int)
--   True
--   </pre>
--   
--   <pre>
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reuses :: MonadState b m => AReview t b -> (t -> r) -> m r

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>reuse</a> ≡ <a>use</a> <a>.</a> <a>re</a>
--   <a>reuse</a> <a>.</a> <a>unto</a> ≡ <a>gets</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse _Left) 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse (unto succ)) 5
--   6
--   </pre>
--   
--   <pre>
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   </pre>
reuse :: MonadState b m => AReview t b -> m t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way, applying a function.
--   
--   <pre>
--   <a>reviews</a> ≡ <a>views</a> <a>.</a> <a>re</a>
--   <a>reviews</a> (<a>unto</a> f) g ≡ g <a>.</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews _Left isRight "mustard"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews (unto succ) (*2) 3
--   8
--   </pre>
--   
--   Usually this function is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; a -&gt; r
--   <a>reviews</a> :: <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; a -&gt; r
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reviews :: MonadReader b m => AReview t b -> (t -> r) -> m r

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x ≡ f x
--   l # x ≡ x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t
infixr 8 #

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>review</a> ≡ <a>view</a> <a>.</a> <a>re</a>
--   <a>review</a> . <a>unto</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review _Left "mustard"
--   Left "mustard"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review (unto succ) 5
--   6
--   </pre>
--   
--   Usually <a>review</a> is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>Iso'</a> s a   -&gt; a -&gt; s
--   <a>review</a> :: <a>Prism'</a> s a -&gt; a -&gt; s
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   </pre>
review :: MonadReader b m => AReview t b -> m t

-- | Turn a <a>Prism</a> or <a>Iso</a> around to build a <a>Getter</a>.
--   
--   If you have an <a>Iso</a>, <a>from</a> is a more powerful version of
--   this function that will return an <a>Iso</a> instead of a mere
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^.re _Left
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 ^.re (_Left.unto succ)
--   Left 7
--   </pre>
--   
--   <pre>
--   <a>review</a>  ≡ <a>view</a>  <a>.</a> <a>re</a>
--   <a>reviews</a> ≡ <a>views</a> <a>.</a> <a>re</a>
--   <a>reuse</a>   ≡ <a>use</a>   <a>.</a> <a>re</a>
--   <a>reuses</a>  ≡ <a>uses</a>  <a>.</a> <a>re</a>
--   </pre>
--   
--   <pre>
--   <a>re</a> :: <a>Prism</a> s t a b -&gt; <a>Getter</a> b t
--   <a>re</a> :: <a>Iso</a> s t a b   -&gt; <a>Getter</a> b t
--   </pre>
re :: AReview t b -> Getter b t

-- | Turn a <a>Getter</a> around to get a <a>Review</a>
--   
--   <pre>
--   <a>un</a> = <a>unto</a> . <a>view</a>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; un (to length) # [1,2,3]
--   3
--   </pre>
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s

-- | An analogue of <a>to</a> for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> :: (b -&gt; t) -&gt; <tt>Review'</tt> t b
--   </pre>
--   
--   <pre>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
unto :: (Profunctor p, Bifunctor p, Functor f) => (b -> t) -> Optic p f s t a b

-- | Coerce a <a>Getter</a>-compatible <a>Optical</a> to an
--   <a>Optical'</a>. This is useful when using a <a>Traversal</a> that is
--   not simple as a <a>Getter</a> or a <a>Fold</a>.
--   
--   <pre>
--   <a>getting</a> :: <a>Traversal</a> s t a b          -&gt; <a>Fold</a> s a
--   <a>getting</a> :: <a>Lens</a> s t a b               -&gt; <a>Getter</a> s a
--   <a>getting</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedFold</a> i s a
--   <a>getting</a> :: <a>IndexedLens</a> i s t a b      -&gt; <a>IndexedGetter</a> i s a
--   </pre>
getting :: (Profunctor p, Profunctor q, Functor f, Contravariant f) => Optical p q f s t a b -> Optical' p q f s a

-- | View the index and value of an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>.
--   
--   This is the same operation as <a>iview</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   (<a>^@.</a>) :: s -&gt; <a>IndexedGetter</a> i s a -&gt; (i, a)
--   (<a>^@.</a>) :: s -&gt; <a>IndexedLens'</a> i s a  -&gt; (i, a)
--   </pre>
--   
--   The result probably doesn't have much meaning when applied to an
--   <a>IndexedFold</a>.
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)
infixl 8 ^@.

-- | Use a function of the index and value of an <a>IndexedGetter</a> into
--   the current state.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
iuses :: MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | Use the index and value of an <a>IndexedGetter</a> into the current
--   state as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iuse :: MonadState s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | View a function of the index and value of an <a>IndexedGetter</a> into
--   the current environment.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
--   
--   <pre>
--   <a>iviews</a> ≡ <a>ifoldMapOf</a>
--   </pre>
iviews :: MonadReader s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | View the index and value of an <a>IndexedGetter</a> into the current
--   environment as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iview :: MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> w u     -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> w u      -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedFold</a> w u       -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedTraversal'</a> w u -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
ilistenings :: MonadWriter w m => IndexedGetting i v w u -> (i -> u -> v) -> m a -> m (a, v)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Fold</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Traversal'</a> w u -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Prism'</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
listenings :: MonadWriter w m => Getting v w u -> (u -> v) -> m a -> m (a, v)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> i w u     -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> i w u      -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedFold</a> i w u       -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedTraversal'</a> i w u -&gt; m a -&gt; m (a, (i, u))
--   </pre>
ilistening :: MonadWriter w m => IndexedGetting i (i, u) w u -> m a -> m (a, (i, u))

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Fold</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Traversal'</a> w u -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Prism'</a> w u     -&gt; m a -&gt; m (a, u)
--   </pre>
listening :: MonadWriter w m => Getting u w u -> m a -> m (a, u)

-- | Use the target of a <a>Lens</a>, <a>Iso</a> or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (uses _1 length) ("hello","world")
--   5
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m =&gt; <a>Getting</a> r s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
uses :: MonadState s m => LensLike' (Const r :: Type -> Type) s a -> (a -> r) -> m r

-- | Use the target of a <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) (a,b)
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) ("hello","world")
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s r       -&gt; m r
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s r -&gt; m r
--   </pre>
use :: MonadState s m => Getting a s a -> m a

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | View a function of the value pointed to by a <a>Getter</a> or
--   <a>Lens</a> or the result of folding over the result of mapping the
--   targets of a <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>views</a> l f ≡ <a>view</a> (l <a>.</a> <a>to</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views (to f) g a
--   g (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views _2 length (1,"hello")
--   5
--   </pre>
--   
--   As <a>views</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>views</a> ::             <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m) -&gt; s -&gt; m
--   <a>views</a> ::             <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> ::             <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m) -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m =&gt; <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
views :: MonadReader s m => LensLike' (Const r :: Type -> Type) s a -> (a -> r) -> m r

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | <pre>
--   <a>ilike</a> :: i -&gt; a -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ilike :: (Indexable i p, Contravariant f, Functor f) => i -> a -> Over' p f s a

-- | Build an constant-valued (index-preserving) <a>Getter</a> from an
--   arbitrary Haskell value.
--   
--   <pre>
--   <a>like</a> a <a>.</a> <a>like</a> b ≡ <a>like</a> b
--   a <a>^.</a> <a>like</a> b ≡ b
--   a <a>^.</a> <a>like</a> b ≡ a <a>^.</a> <a>to</a> (<a>const</a> b)
--   </pre>
--   
--   This can be useful as a second case <tt>failing</tt> a <a>Fold</a>
--   e.g. <tt>foo <tt>failing</tt> <a>like</a> 0</tt>
--   
--   <pre>
--   <a>like</a> :: a -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
like :: (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a

-- | <pre>
--   <a>ito</a> :: (s -&gt; (i, a)) -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Over' p f s a

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g ≡ <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f ≡ f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a

-- | When you see this in a type signature it indicates that you can pass
--   the function a <a>Lens</a>, <a>Getter</a>, <a>Traversal</a>,
--   <a>Fold</a>, <a>Prism</a>, <a>Iso</a>, or one of the indexed variants,
--   and it will just "do the right thing".
--   
--   Most <a>Getter</a> combinators are able to be used with both a
--   <a>Getter</a> or a <a>Fold</a> in limited situations, to do so, they
--   need to be monomorphic in what we are going to extract with
--   <a>Const</a>. To be compatible with <a>Lens</a>, <a>Traversal</a> and
--   <a>Iso</a> we also restricted choices of the irrelevant <tt>t</tt> and
--   <tt>b</tt> parameters.
--   
--   If a function accepts a <tt><a>Getting</a> r s a</tt>, then when
--   <tt>r</tt> is a <a>Monoid</a>, then you can pass a <a>Fold</a> (or
--   <a>Traversal</a>), otherwise you can only pass this a <a>Getter</a> or
--   <a>Lens</a>.
type Getting r s a = a -> Const r a -> s -> Const r s

-- | Used to consume an <a>IndexedFold</a>.
type IndexedGetting i m s a = Indexed i a Const m a -> s -> Const m s

-- | This is a convenient alias used when consuming (indexed) getters and
--   (indexed) folds in a highly general fashion.
type Accessing (p :: Type -> Type -> Type) m s a = p a Const m a -> s -> Const m s

-- | Strict version of <a>_19</a>
_19' :: Field19 s t a b => Lens s t a b

-- | Strict version of <a>_18</a>
_18' :: Field18 s t a b => Lens s t a b

-- | Strict version of <a>_17</a>
_17' :: Field17 s t a b => Lens s t a b

-- | Strict version of <a>_16</a>
_16' :: Field16 s t a b => Lens s t a b

-- | Strict version of <a>_15</a>
_15' :: Field15 s t a b => Lens s t a b

-- | Strict version of <a>_14</a>
_14' :: Field14 s t a b => Lens s t a b

-- | Strict version of <a>_13</a>
_13' :: Field13 s t a b => Lens s t a b

-- | Strict version of <a>_12</a>
_12' :: Field12 s t a b => Lens s t a b

-- | Strict version of <a>_11</a>
_11' :: Field11 s t a b => Lens s t a b

-- | Strict version of <a>_10</a>
_10' :: Field10 s t a b => Lens s t a b

-- | Strict version of <a>_9</a>
_9' :: Field9 s t a b => Lens s t a b

-- | Strict version of <a>_8</a>
_8' :: Field8 s t a b => Lens s t a b

-- | Strict version of <a>_7</a>
_7' :: Field7 s t a b => Lens s t a b

-- | Strict version of <a>_6</a>
_6' :: Field6 s t a b => Lens s t a b

-- | Strict version of <a>_5</a>
_5' :: Field5 s t a b => Lens s t a b

-- | Strict version of <a>_4</a>
_4' :: Field4 s t a b => Lens s t a b

-- | Strict version of <a>_3</a>
_3' :: Field3 s t a b => Lens s t a b

-- | Strict version of <a>_2</a>
_2' :: Field2 s t a b => Lens s t a b

-- | Strict version of <a>_1</a>
_1' :: Field1 s t a b => Lens s t a b

-- | Provides access to 1st field of a tuple.
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Provides access to the 2nd field of a tuple.
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Provides access to the 3rd field of a tuple.
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 3rd field of a tuple.
_3 :: Field3 s t a b => Lens s t a b

-- | Provide access to the 4th field of a tuple.
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 4th field of a tuple.
_4 :: Field4 s t a b => Lens s t a b

-- | Provides access to the 5th field of a tuple.
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 5th field of a tuple.
_5 :: Field5 s t a b => Lens s t a b

-- | Provides access to the 6th element of a tuple.
class Field6 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 6th field of a tuple.
_6 :: Field6 s t a b => Lens s t a b

-- | Provide access to the 7th field of a tuple.
class Field7 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 7th field of a tuple.
_7 :: Field7 s t a b => Lens s t a b

-- | Provide access to the 8th field of a tuple.
class Field8 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 8th field of a tuple.
_8 :: Field8 s t a b => Lens s t a b

-- | Provides access to the 9th field of a tuple.
class Field9 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 9th field of a tuple.
_9 :: Field9 s t a b => Lens s t a b

-- | Provides access to the 10th field of a tuple.
class Field10 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 10th field of a tuple.
_10 :: Field10 s t a b => Lens s t a b

-- | Provides access to the 11th field of a tuple.
class Field11 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 11th field of a tuple.
_11 :: Field11 s t a b => Lens s t a b

-- | Provides access to the 12th field of a tuple.
class Field12 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 12th field of a tuple.
_12 :: Field12 s t a b => Lens s t a b

-- | Provides access to the 13th field of a tuple.
class Field13 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 13th field of a tuple.
_13 :: Field13 s t a b => Lens s t a b

-- | Provides access to the 14th field of a tuple.
class Field14 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 14th field of a tuple.
_14 :: Field14 s t a b => Lens s t a b

-- | Provides access to the 15th field of a tuple.
class Field15 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 15th field of a tuple.
_15 :: Field15 s t a b => Lens s t a b

-- | Provides access to the 16th field of a tuple.
class Field16 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 16th field of a tuple.
_16 :: Field16 s t a b => Lens s t a b

-- | Provides access to the 17th field of a tuple.
class Field17 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 17th field of a tuple.
_17 :: Field17 s t a b => Lens s t a b

-- | Provides access to the 18th field of a tuple.
class Field18 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 18th field of a tuple.
_18 :: Field18 s t a b => Lens s t a b

-- | Provides access to the 19th field of a tuple.
class Field19 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 19th field of a tuple.
_19 :: Field19 s t a b => Lens s t a b

-- | Fuse a composition of lenses using <a>Yoneda</a> to provide
--   <a>fmap</a> fusion.
--   
--   In general, given a pair of lenses <tt>foo</tt> and <tt>bar</tt>
--   
--   <pre>
--   fusing (foo.bar) = foo.bar
--   </pre>
--   
--   however, <tt>foo</tt> and <tt>bar</tt> are either going to <a>fmap</a>
--   internally or they are trivial.
--   
--   <a>fusing</a> exploits the <a>Yoneda</a> lemma to merge these separate
--   uses into a single <a>fmap</a>.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Lens</a> <tt>foo.bar</tt> in
--   the above description is recursive or complex enough to prevent
--   inlining.
--   
--   <pre>
--   <a>fusing</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> s t a b
--   </pre>
fusing :: Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b

-- | A <a>Lens</a> focusing on the last element of a <a>Traversable1</a>
--   container.
--   
--   <pre>
--   &gt;&gt;&gt; 2 :| [3, 4] &amp; last1 +~ 10
--   2 :| [3,14]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Node 'a' [Node 'b' [], Node 'c' []] ^. last1
--   'c'
--   </pre>
last1 :: forall (t :: Type -> Type) a. Traversable1 t => Lens' (t a) a

-- | A <a>Lens</a> focusing on the first element of a <a>Traversable1</a>
--   container.
--   
--   <pre>
--   &gt;&gt;&gt; 2 :| [3, 4] &amp; head1 +~ 10
--   12 :| [3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Identity True ^. head1
--   True
--   </pre>
head1 :: forall (t :: Type -> Type) a. Traversable1 t => Lens' (t a) a

-- | We can always retrieve a <tt>()</tt> from any type.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.united
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &amp; united .~ ()
--   "hello"
--   </pre>
united :: Lens' a ()

-- | There is a field for every type in the <a>Void</a>. Very zen.
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; mapped.devoid +~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; mapped.devoid %~ abs
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>devoid</a> :: <a>Lens'</a> <a>Void</a> a
--   </pre>
devoid :: forall k p f (a :: k) b. Over p f Void Void a b

-- | A version of (<a>&lt;.=</a>) that works on <a>ALens</a>.
(<#=) :: MonadState s m => ALens s s a b -> b -> m b
infix 4 <#=

-- | A version of (<a>&lt;.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 &lt;#~ "world"
--   ("world",("hello","world"))
--   </pre>
(<#~) :: ALens s t a b -> b -> s -> (b, t)
infixr 4 <#~

-- | A version of (<a>%%=</a>) that works on <a>ALens</a>.
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r
infix 4 #%%=

-- | A version of (<a>&lt;%=</a>) that works on <a>ALens</a>.
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b
infix 4 <#%=

-- | A version of (<a>&lt;%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 &lt;#%~ length
--   (5,("hello",5))
--   </pre>
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)
infixr 4 <#%~

-- | A version of (<a>%=</a>) that works on <a>ALens</a>.
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()
infix 4 #%=

-- | A version of (<a>.=</a>) that works on <a>ALens</a>.
(#=) :: MonadState s m => ALens s s a b -> b -> m ()
infix 4 #=

-- | A version of (<a>%%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%%~ \x -&gt; (length x, x ++ "!")
--   (5,("hello","world!"))
--   </pre>
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t
infixr 4 #%%~

-- | A version of (<a>%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%~ length
--   ("hello",5)
--   </pre>
(#%~) :: ALens s t a b -> (a -> b) -> s -> t
infixr 4 #%~

-- | A version of (<a>.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 #~ "world"
--   ("hello","world")
--   </pre>
(#~) :: ALens s t a b -> b -> s -> t
infixr 4 #~

-- | A version of <a>set</a> that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; storing _2 "world" ("hello","there")
--   ("hello","world")
--   </pre>
storing :: ALens s t a b -> b -> s -> t

-- | A version of (<a>^.</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^#_2
--   "world"
--   </pre>
(^#) :: s -> ALens s t a b -> a
infixl 8 ^#

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> within the
--   current state, and return a monoidal summary of the old values.
--   
--   <pre>
--   (<a>&lt;&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   (<a>&lt;&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   </pre>
(<<%@=) :: MonadState s m => Over (Indexed i) ((,) a) s s a b -> (i -> a -> b) -> m a
infix 4 <<%@=

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   intermediate results.
--   
--   <pre>
--   (<a>&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   (<a>&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   </pre>
(<%@=) :: MonadState s m => Over (Indexed i) ((,) b) s s a b -> (i -> a -> b) -> m b
infix 4 <%@=

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   supplementary results.
--   
--   <pre>
--   l <a>%%@=</a> f ≡ <a>state</a> (l <a>%%@~</a> f)
--   </pre>
--   
--   <pre>
--   (<a>%%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   (<a>%%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   </pre>
(%%@=) :: MonadState s m => Over (Indexed i) ((,) r) s s a b -> (i -> a -> (r, b)) -> m r
infix 4 %%@=

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary of the supplementary results and the answer.
--   
--   <pre>
--   (<a>%%@~</a>) ≡ <a>withIndex</a>
--   </pre>
--   
--   <pre>
--   (<a>%%@~</a>) :: <a>Functor</a> f =&gt; <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%@~</a>) :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   In particular, it is often useful to think of this function as having
--   one of these even more restricted type signatures:
--   
--   <pre>
--   (<a>%%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%@~</a>) :: <a>Monoid</a> r =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   </pre>
(%%@~) :: forall k i f s (t :: k) a (b :: k). Over (Indexed i) f s t a b -> (i -> a -> f b) -> s -> f t
infixr 4 %%@~

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> and return a
--   monoidal summary of the old values along with the answer.
--   
--   <pre>
--   (<a>&lt;&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%@~</a>) :: <a>Monoid</a> a =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%@~) :: Over (Indexed i) ((,) a) s t a b -> (i -> a -> b) -> s -> (a, t)
infixr 4 <<%@~

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary along with the answer.
--   
--   <pre>
--   l <a>&lt;%~</a> f ≡ l <a>&lt;%@~</a> <a>const</a> f
--   </pre>
--   
--   When you do not need access to the index then (<a>&lt;%~</a>) is more
--   liberal in what it can accept.
--   
--   If you do not need the intermediate result, you can use (<a>%@~</a>)
--   or even (<a>%~</a>).
--   
--   <pre>
--   (<a>&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%@~</a>) :: <a>Monoid</a> b =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%@~) :: Over (Indexed i) ((,) b) s t a b -> (i -> a -> b) -> s -> (b, t)
infixr 4 <%@~

-- | <a>over</a> for Arrows.
--   
--   Unlike <a>over</a>, <a>overA</a> can't accept a simple <a>Setter</a>,
--   but requires a full lens, or close enough.
--   
--   <pre>
--   &gt;&gt;&gt; overA _1 ((+1) *** (+2)) ((1,2),6)
--   ((2,4),6)
--   </pre>
--   
--   <pre>
--   overA :: Arrow ar =&gt; Lens s t a b -&gt; ar a b -&gt; ar s t
--   </pre>
overA :: Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t

-- | <a>mappend</a> a monoidal value onto the end of the target of a
--   <a>Lens</a> into your <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
(<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r
infix 4 <<>=

-- | <a>mappend</a> a monoidal value onto the end of the target of a
--   <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;~</a>)
--   is more flexible.
(<<>~) :: Monoid m => LensLike ((,) m) s t m m -> m -> s -> (m, t)
infixr 4 <<>~

-- | Run a monadic action, and set the target of <a>Lens</a> to its result.
--   
--   <pre>
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b   -&gt; m b -&gt; m b
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b  -&gt; m b -&gt; m b
--   </pre>
--   
--   NB: This is limited to taking an actual <a>Lens</a> than admitting a
--   <a>Traversal</a> because there are potential loss of state issues
--   otherwise.
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b
infixr 2 <<~

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   <a>mappend</a>ing a value and return the <i>old</i> value that was
--   replaced.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Lens'</a> s r -&gt; r -&gt; m r
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Iso'</a> s r -&gt; r -&gt; m r
--   </pre>
(<<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r
infix 4 <<<>=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>&amp;&amp;</a> with a value and return the
--   <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <<&&=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>||</a> with a value and return the <i>old</i>
--   value that was replaced.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <<||=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an arbitrary power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<**=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an integral power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <<^^=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by a non-negative power and return the <i>old</i> value
--   that was replaced.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <<^=

-- | Modify the target of a <a>Lens</a> into your <a>Monad</a>s state by
--   dividing by a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<//=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   multipling a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>*=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<*=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   subtracting a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>-=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<-=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   adding a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<+=

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with <a>Just</a> a user supplied value and return the <i>old</i> value
--   that was replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>?=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;?=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s t a (Maybe b)      -&gt; b -&gt; m a
--   (<a>&lt;&lt;?=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s t a (Maybe b)       -&gt; b -&gt; m a
--   (<a>&lt;&lt;?=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a (Maybe b) -&gt; b -&gt; m a
--   </pre>
(<<?=) :: MonadState s m => LensLike ((,) a) s s a (Maybe b) -> b -> m a
infix 4 <<?=

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with a user supplied value and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>.=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a
infix 4 <<.=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m =&gt; <a>LensLike</a> ((,)a) s s a b -&gt; (a -&gt; b) -&gt; m a
--   </pre>
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
infix 4 <<%=

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <&&=

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <||=

-- | Raise the target of a floating-point valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <**=

-- | Raise the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an <a>Integral</a> power and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Iso'</a> s a  -&gt; e -&gt; m a
--   </pre>
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <^^=

-- | Raise the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to a non-negative <a>Integral</a> power and
--   return the result.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <^=

-- | Divide the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the division, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <//=

-- | Multiply the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the multiplication, (<a>*=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <*=

-- | Subtract from the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the subtraction, (<a>-=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <-=

-- | Add to the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the addition, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <+=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the result.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the intermediate results.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
(<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
infix 4 <%=

-- | Modify the target of a monoidally valued <a>Lens</a> by
--   <a>mappend</a>ing a new value and return the old value.
--   
--   When you do not need the old value, (<a>&lt;&gt;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&lt;&lt;&gt;~ Sum c
--   (Sum {getSum = a},(Sum {getSum = a + c},b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;&lt;&lt;&gt;~ ", 007" $ ("James", "Bond")
--   ("Bond",("James","Bond, 007"))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Monoid</a> r =&gt; <a>Lens'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Monoid</a> r =&gt; <a>Iso'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   </pre>
(<<<>~) :: Monoid r => LensLike' ((,) r) s r -> r -> s -> (r, s)
infixr 4 <<<>~

-- | Logically <a>&amp;&amp;</a> the target of a <a>Bool</a>-valued
--   <a>Lens</a> and return the old value.
--   
--   When you do not need the old value, (<a>&amp;&amp;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;&amp;&amp;~ True
--   (False,(False,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;&amp;&amp;~ False
--   (True,("hello",False))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   </pre>
(<<&&~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
infixr 4 <<&&~

-- | Logically <a>||</a> the target of a <a>Bool</a>-valued <a>Lens</a> and
--   return the old value.
--   
--   When you do not need the old value, (<a>||~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;||~ True
--   (False,(True,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;||~ False
--   (True,("hello",True))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<<||~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
infixr 4 <<||~

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the old value.
--   
--   When you do not need the old value, (<a>**~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;**~ c
--   (a,(a**c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;**~ c
--   (b,(a,b**c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<**~) :: Floating a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<**~

-- | Raise the target of a fractionally valued <a>Lens</a> to an integral
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; S -&gt; (a, s)
--   </pre>
(<<^^~) :: (Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
infixr 4 <<^^~

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<<^~) :: (Num a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
infixr 4 <<^~

-- | Divide the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>//~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;//~ c
--   (a,(a / c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 &lt;&lt;//~ 2
--   (10.0,("Hawaii",5.0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<//~) :: Fractional a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<//~

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;*~ c
--   (a,(a * c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;*~ c
--   (b,(a,b * c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<*~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<*~

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;-~ c
--   (a,(a - c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;-~ c
--   (b,(a,b - c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<-~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<-~

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>+~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;+~ c
--   (a,(a + c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;+~ c
--   (b,(a,b + c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<+~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<+~

-- | Replace the target of a <a>Lens</a> with a <a>Just</a> value, but
--   return the old value.
--   
--   If you do not need the old value (<a>?~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;&lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   (Nothing,(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<?~) :: LensLike ((,) a) s t a (Maybe b) -> b -> s -> (a, t)
infixr 4 <<?~

-- | Replace the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>.~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.~</a>) ::             <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) ::             <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<.~) :: LensLike ((,) a) s t a b -> b -> s -> (a, t)
infixr 4 <<.~

-- | Modify the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>%~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%~) :: LensLike ((,) a) s t a b -> (a -> b) -> s -> (a, t)
infixr 4 <<%~

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;~</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<&&~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
infixr 4 <&&~

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>||~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<||~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
infixr 4 <||~

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<**~) :: Floating a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <**~

-- | Raise the target of a fractionally valued <a>Lens</a> to an
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^^~) :: (Fractional a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
infixr 4 <^^~

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^~) :: (Num a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
infixr 4 <^~

-- | Divide the target of a fractionally valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the division, (<a>//~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<//~) :: Fractional a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <//~

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the multiplication, (<a>*~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<*~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <*~

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the subtraction, (<a>-~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<-~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <-~

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the addition, (<a>+~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<+~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <+~

-- | Modify the target of a <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>%~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) :: <a>Monoid</a> b =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%~) :: LensLike ((,) b) s t a b -> (a -> b) -> s -> (b, t)
infixr 4 <%~

-- | Clone an <a>IndexedLens</a> as an <a>IndexedLens</a> with the same
--   index.
cloneIndexedLens :: AnIndexedLens i s t a b -> IndexedLens i s t a b

-- | Clone a <a>Lens</a> as an <tt>IndexedPreservingLens</tt> that just
--   passes through whatever index is on any <a>IndexedLens</a>,
--   <a>IndexedFold</a>, <a>IndexedGetter</a> or <a>IndexedTraversal</a> it
--   is composed with.
cloneIndexPreservingLens :: ALens s t a b -> IndexPreservingLens s t a b

-- | Cloning a <a>Lens</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Traversal</a> and can be used as a way
--   to pass around lenses that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let example l x = set (cloneLens l) (x^.cloneLens l + 1) x in example _2 ("hello",1,"you")
--   ("hello",2,"you")
--   </pre>
cloneLens :: ALens s t a b -> Lens s t a b

-- | This <a>Lens</a> lets you <tt>view</tt> the current <tt>pos</tt> of
--   any indexed store comonad and <tt>seek</tt> to a new position. This
--   reduces the API for working these instances to a single <a>Lens</a>.
--   
--   <pre>
--   <a>ipos</a> w ≡ w <a>^.</a> <a>locus</a>
--   <a>iseek</a> s w ≡ w <a>&amp;</a> <a>locus</a> <a>.~</a> s
--   <a>iseeks</a> f w ≡ w <a>&amp;</a> <a>locus</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   <a>locus</a> :: <a>Lens'</a> (<a>Context'</a> a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>Pretext'</a> p a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>PretextT'</a> p g a s) a
--   </pre>
locus :: forall (p :: Type -> Type -> Type -> Type) a c s b. IndexedComonadStore p => Lens (p a c s) (p b c s) a b

-- | <a>alongside</a> makes a <a>Lens</a> from two other lenses or a
--   <a>Getter</a> from two other getters by executing them on their
--   respective halves of a product.
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b)^.alongside chosen chosen
--   (a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b) &amp; alongside chosen chosen .~ (c,d)
--   (Left c,Right d)
--   </pre>
--   
--   <pre>
--   <a>alongside</a> :: <a>Lens</a>   s t a b -&gt; <a>Lens</a>   s' t' a' b' -&gt; <a>Lens</a>   (s,s') (t,t') (a,a') (b,b')
--   <a>alongside</a> :: <a>Getter</a> s   a   -&gt; <a>Getter</a> s'    a'    -&gt; <a>Getter</a> (s,s')        (a,a')
--   </pre>
alongside :: LensLike (AlongsideLeft f b') s t a b -> LensLike (AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')

-- | This is a <a>Lens</a> that updates either side of an <a>Either</a>,
--   where both sides have the same type.
--   
--   <pre>
--   <a>chosen</a> ≡ <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello"^.chosen
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a &amp; chosen *~ b
--   Right (a * b)
--   </pre>
--   
--   <pre>
--   <a>chosen</a> :: <a>Lens</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   <a>chosen</a> f (<a>Left</a> a)  = <a>Left</a> <a>&lt;$&gt;</a> f a
--   <a>chosen</a> f (<a>Right</a> a) = <a>Right</a> <a>&lt;$&gt;</a> f a
--   </pre>
chosen :: IndexPreservingLens (Either a a) (Either b b) a b

-- | Merge two lenses, getters, setters, folds or traversals.
--   
--   <pre>
--   <a>chosen</a> ≡ <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>choosing</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s' a     -&gt; <a>Getter</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Fold</a> s a       -&gt; <a>Fold</a> s' a       -&gt; <a>Fold</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s' a      -&gt; <a>Lens'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> s' a -&gt; <a>Traversal'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Setter'</a> s a    -&gt; <a>Setter'</a> s' a    -&gt; <a>Setter'</a> (<a>Either</a> s s') a
--   </pre>
choosing :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b

-- | Lift a <a>Lens</a> so it can run under a function (or other
--   corepresentable profunctor).
--   
--   <pre>
--   <a>inside</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> (e -&gt; s) (e -&gt; t) (e -&gt; a) (e -&gt; b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (\x -&gt; (x-1,x+1)) ^. inside _1 $ 5
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runState (modify (1:) &gt;&gt; modify (2:)) ^. (inside _2) $ []
--   [2,1]
--   </pre>
inside :: forall (p :: Type -> Type -> Type) s t a b e. Corepresentable p => ALens s t a b -> Lens (p e s) (p e t) (p e a) (p e b)

-- | This is convenient to <a>flip</a> argument order of composite
--   functions defined as:
--   
--   <pre>
--   fab ?? a = fmap ($ a) fab
--   </pre>
--   
--   For the <a>Functor</a> instance <tt>f = ((-&gt;) r)</tt> you can
--   reason about this function as if the definition was <tt>(<a>??</a>) ≡
--   <a>flip</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (h ?? x) a
--   h a x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState ?? [] $ modify (1:)
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _2 ?? ("hello","world") $ length
--   ("hello",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over ?? length ?? ("hello","world") $ _2
--   ("hello",5)
--   </pre>
(??) :: Functor f => f (a -> b) -> a -> f b
infixl 1 ??

-- | Modify the target of a <a>Lens</a> in the current state returning some
--   extra information of type <tt>r</tt> or modify all targets of a
--   <a>Traversal</a> in the current state, extracting extra information of
--   type <tt>r</tt> and return a monoidal summary of the changes.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 %%= \x -&gt; (f x, g x)) (a,b)
--   (f a,(g a,b))
--   </pre>
--   
--   <pre>
--   (<a>%%=</a>) ≡ (<a>state</a> <a>.</a>)
--   </pre>
--   
--   It may be useful to think of (<a>%%=</a>), instead, as having either
--   of the following more restricted type signatures:
--   
--   <pre>
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; (r, b)) -&gt; m r
--   </pre>
(%%=) :: forall k s m p r (a :: k) b. MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
infix 4 %%=

-- | (<a>%%~</a>) can be used in one of two scenarios:
--   
--   When applied to a <a>Lens</a>, it can edit the target of the
--   <a>Lens</a> in a structure, extracting a functorial result.
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting an applicative summary of its actions.
--   
--   <pre>
--   &gt;&gt;&gt; [66,97,116,109,97,110] &amp; each %%~ \a -&gt; ("na", chr a)
--   ("nananananana","Batman")
--   </pre>
--   
--   For all that the definition of this combinator is just:
--   
--   <pre>
--   (<a>%%~</a>) ≡ <a>id</a>
--   </pre>
--   
--   It may be beneficial to think about it as if it had these even more
--   restricted types, however:
--   
--   <pre>
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Iso</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Lens</a> s t a b      -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting a supplemental monoidal summary of its actions,
--   by choosing <tt>f = ((,) m)</tt>
--   
--   <pre>
--   (<a>%%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) :: <a>Monoid</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; (m, b)) -&gt; s -&gt; (m, t)
--   </pre>
(%%~) :: forall k f s (t :: k) a (b :: k). LensLike f s t a b -> (a -> f b) -> s -> f t
infixr 4 %%~

-- | This can be used to chain lens operations using <tt>op=</tt> syntax
--   rather than <tt>op~</tt> syntax for simple non-type-changing cases.
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ 30 &amp; _2 .~ 40
--   (30,40)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp;~ do _1 .= 30; _2 .= 40
--   (30,40)
--   </pre>
--   
--   This does not support type-changing assignment, <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ "hello"
--   ("hello",20)
--   </pre>
(&~) :: s -> State s a -> s
infixl 1 &~

-- | Build an <a>IndexedLens</a> from a <a>Getter</a> and a <a>Setter</a>.
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IndexedLens i s t a b

-- | Build an index-preserving <a>Lens</a> from a <a>Getter</a> and a
--   <a>Setter</a>.
iplens :: (s -> a) -> (s -> b -> t) -> IndexPreservingLens s t a b

-- | Obtain a getter and a setter from a lens, reversing <a>lens</a>.
withLens :: forall s t a b (rep :: RuntimeRep) (r :: TYPE rep). ALens s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | When you see this as an argument to a function, it expects a
--   <a>Lens</a>.
--   
--   This type can also be used when you need to store a <a>Lens</a> in a
--   container, since it is rank-1. You can turn them back into a
--   <a>Lens</a> with <a>cloneLens</a>, or use it directly with combinators
--   like <a>storing</a> and (<a>^#</a>).
type ALens s t a b = LensLike Pretext (->) :: Type -> Type -> Type a b s t a b

-- | <pre>
--   type <a>ALens'</a> = <a>Simple</a> <a>ALens</a>
--   </pre>
type ALens' s a = ALens s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedLens</a>
type AnIndexedLens i s t a b = Optical Indexed i (->) :: Type -> Type -> Type Pretext Indexed i a b s t a b

-- | <pre>
--   type <a>AnIndexedLens'</a> = <a>Simple</a> (<a>AnIndexedLens</a> i)
--   </pre>
type AnIndexedLens' i s a = AnIndexedLens i s s a a

-- | Map with index. (Deprecated alias for <a>iover</a>).
--   
--   When you do not need access to the index, then <a>mapOf</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>mapOf</a> l ≡ <a>imapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapOf</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
imapOf :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | <a>mapOf</a> is a deprecated alias for <a>over</a>.
mapOf :: ASetter s t a b -> (a -> b) -> s -> t

-- | Run an arrow command and use the output to set all the targets of a
--   <a>Lens</a>, <a>Setter</a> or <a>Traversal</a> to the result.
--   
--   <a>assignA</a> can be used very similarly to (<a>&lt;~</a>), except
--   that the type of the object being modified can change; for example:
--   
--   <pre>
--   runKleisli action ((), (), ()) where
--     action =      assignA _1 (Kleisli (const getVal1))
--              &gt;&gt;&gt; assignA _2 (Kleisli (const getVal2))
--              &gt;&gt;&gt; assignA _3 (Kleisli (const getVal3))
--     getVal1 :: Either String Int
--     getVal1 = ...
--     getVal2 :: Either String Bool
--     getVal2 = ...
--     getVal3 :: Either String Char
--     getVal3 = ...
--   </pre>
--   
--   has the type <tt><a>Either</a> <a>String</a> (<a>Int</a>, <a>Bool</a>,
--   <a>Char</a>)</tt>
--   
--   <pre>
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Iso</a> s t a b       -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Lens</a> s t a b      -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Traversal</a> s t a b -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Setter</a> s t a b    -&gt; p s b -&gt; p s t
--   </pre>
assignA :: Arrow p => ASetter s t a b -> p s b -> p s t

-- | Replace every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>.=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.=</a> b ≡ l <a>.@=</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; m ()
--   </pre>
(.@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> b) -> m ()
infix 4 .@=

-- | This is an alias for (<a>%@=</a>).
imodifying :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()

-- | Adjust every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>%=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%=</a> f ≡ l <a>%@=</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   </pre>
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
infix 4 %@=

-- | Replace every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>.@~</a>) ≡ <a>iset</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>.~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.~</a> b ≡ l <a>.@~</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
(.@~) :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
infixr 4 .@~

-- | Adjust every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>%@~</a>) ≡ <a>iover</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>%~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%~</a> f ≡ l <a>%@~</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
infixr 4 %@~

-- | Build an <a>IndexedSetter</a> from an <a>imap</a>-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a> ≡ <a>id</a>
--   f g <a>.</a> f h ≡ f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>isets</a> <a>.</a> <a>iover</a> ≡ <a>id</a>
--   <a>iover</a> <a>.</a> <a>isets</a> ≡ <a>id</a>
--   </pre>
--   
--   Another way to view <a>isets</a> is that it takes a "semantic editor
--   combinator" which has been modified to carry an index and transforms
--   it into a <a>IndexedSetter</a>.
isets :: ((i -> a -> b) -> s -> t) -> IndexedSetter i s t a b

-- | Set with index. Equivalent to <a>iover</a> with the current value
--   ignored.
--   
--   When you do not need access to the index, then <a>set</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>set</a> l ≡ <a>iset</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iset</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
iset :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t

-- | Map with index. This is an alias for <a>imapOf</a>.
--   
--   When you do not need access to the index, then <a>over</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>over</a> l ≡ <a>iover</a> l <a>.</a> <a>const</a>
--   <a>iover</a> l ≡ <a>over</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>iover</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
iover :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | This is a generalization of <a>locally</a> that allows one to make
--   indexed <a>local</a> changes to a <tt>Reader</tt> environment
--   associated with the target of a <a>Setter</a>, <a>Lens</a>, or
--   <a>Traversal</a>.
--   
--   <pre>
--   <a>locally</a> l f ≡ <a>ilocally</a> l f . const
--   <a>ilocally</a> l f ≡ <a>locally</a> l f . <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   ilocally :: MonadReader s m =&gt; <a>IndexedLens</a> s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   ilocally :: MonadReader s m =&gt; <a>IndexedTraversal</a> s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   ilocally :: MonadReader s m =&gt; <a>IndexedSetter</a> s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   </pre>
ilocally :: MonadReader s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m r -> m r

-- | Modify the value of the <tt>Reader</tt> environment associated with
--   the target of a <a>Setter</a>, <a>Lens</a>, or <a>Traversal</a>.
--   
--   <pre>
--   <a>locally</a> l <a>id</a> a ≡ a
--   <a>locally</a> l f <a>.</a> locally l g ≡ <a>locally</a> l (f <a>.</a> g)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,1) &amp; locally _1 (+1) (uncurry (+))
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "," &amp; locally ($) ("Hello" &lt;&gt;) (&lt;&gt; " world!")
--   "Hello, world!"
--   </pre>
--   
--   <pre>
--   locally :: MonadReader s m =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Setter</a> s s a b    -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   </pre>
locally :: MonadReader s m => ASetter s s a b -> (a -> b) -> m r -> m r

-- | This is a generalization of <a>censor</a> that allows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>, with
--   access to the index of an <a>IndexedSetter</a>.
icensoring :: MonadWriter w m => IndexedSetter i w w u v -> (i -> u -> v) -> m a -> m a

-- | This is a generalization of <a>censor</a> that allows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>.
censoring :: MonadWriter w m => Setter w w u v -> (u -> v) -> m a -> m a

-- | This is a generalization of <a>pass</a> that allows you to modify just
--   a portion of the resulting <a>MonadWriter</a> with access to the index
--   of an <a>IndexedSetter</a>.
ipassing :: MonadWriter w m => IndexedSetter i w w u v -> m (a, i -> u -> v) -> m a

-- | This is a generalization of <a>pass</a> that allows you to modify just
--   a portion of the resulting <a>MonadWriter</a>.
passing :: MonadWriter w m => Setter w w u v -> m (a, u -> v) -> m a

-- | Write to a fragment of a larger <tt>Writer</tt> format.
scribe :: (MonadWriter t m, Monoid s) => ASetter s t a b -> b -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by <a>mappend</a>ing a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &lt;&gt;= Sum c; _2 &lt;&gt;= Product d) (Sum a,Product b)
--   (Sum {getSum = a + c},Product {getProduct = b * d})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;&gt;= "!!!") ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Setter'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(<>=) :: (MonadState s m, Monoid a) => ASetter' s a -> a -> m ()
infix 4 <>=

-- | Modify the target of a monoidally valued by <a>mappend</a>ing another
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,Sum b) &amp; both &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},Sum {getSum = b + c})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;&gt;~ "!!!" $ ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(<>~) :: Monoid a => ASetter s t a a -> a -> s -> t
infixr 4 <>~

-- | Set <a>Just</a> a value with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>at</a> "foo" <a>&lt;?=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a (<a>Maybe</a> b)    -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a (<a>Maybe</a> b)       -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a (<a>Maybe</a> b)      -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a (<a>Maybe</a> b) -&gt; b -&gt; m b
--   </pre>
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b
infix 4 <?=

-- | Set with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>_2</a> <a>&lt;.=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; b -&gt; m b
--   </pre>
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b
infix 4 <.=

-- | Run a monadic action, and set all of the targets of a <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to its result.
--   
--   <pre>
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; m b -&gt; m ()
--   </pre>
--   
--   As a reasonable mnemonic, this lets you store the result of a monadic
--   action in a <a>Lens</a> rather than in a local variable.
--   
--   <pre>
--   do foo &lt;- bar
--      ...
--   </pre>
--   
--   will store the result in a variable, while
--   
--   <pre>
--   do foo <a>&lt;~</a> bar
--      ...
--   </pre>
--   
--   will store the result in a <a>Lens</a>, <a>Setter</a>, or
--   <a>Traversal</a>.
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
infixr 2 <~

-- | Modify the target(s) of a <a>Lens'</a>, 'Iso, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>||</a> with a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ||= True; _2 ||= False; _3 ||= True; _4 ||= False) (True,True,False,False)
--   (True,True,True,False)
--   </pre>
--   
--   <pre>
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
infix 4 ||=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>&amp;&amp;</a> with a
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &amp;&amp;= True; _2 &amp;&amp;= False; _3 &amp;&amp;= True; _4 &amp;&amp;= False) (True,True,False,False)
--   (True,False,False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
infix 4 &&=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an arbitrary power
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 **= c; _2 **= d) (a,b)
--   (a**c,b**d)
--   </pre>
--   
--   <pre>
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()
infix 4 **=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()
infix 4 ^^=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()
infix 4 ^=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by dividing by a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 //= c; _2 //= d) (a,b)
--   (a / c,b / d)
--   </pre>
--   
--   <pre>
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()
infix 4 //=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by multiplying by value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 *= c; _2 *= d) (a,b)
--   (a * c,b * d)
--   </pre>
--   
--   <pre>
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 *=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by subtracting a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 -= c; _2 -= d) (a,b)
--   (a - c,b - d)
--   </pre>
--   
--   <pre>
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 -=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by adding a value.
--   
--   Example:
--   
--   <pre>
--   <tt>fresh</tt> :: <a>MonadState</a> <a>Int</a> m =&gt; m <a>Int</a>
--   <tt>fresh</tt> = do
--     <a>id</a> <a>+=</a> 1
--     <a>use</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 += c; _2 += d) (a,b)
--   (a + c,b + d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1.at 1.non 0 += 10) (Map.fromList [(2,100)],"hello")
--   (fromList [(1,10),(2,100)],"hello")
--   </pre>
--   
--   <pre>
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 +=

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with
--   <a>Just</a> a new value, irrespective of the old.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do at 1 ?= a; at 2 ?= b) Map.empty
--   fromList [(1,a),(2,b)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ?= b; _2 ?= c) (Just a, Nothing)
--   (Just b,Just c)
--   </pre>
--   
--   <pre>
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s (<a>Maybe</a> a)       -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s (<a>Maybe</a> a)      -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s (<a>Maybe</a> a) -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s (<a>Maybe</a> a)    -&gt; a -&gt; m ()
--   </pre>
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
infix 4 ?=

-- | This is an alias for (<a>%=</a>).
modifying :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()

-- | Map over the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 %= f;_2 %= g) (a,b)
--   (f a,g b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do both %= f) (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; m ()
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>ASetter</a> s s a b -&gt; (a -&gt; b) -&gt; m ()
--   </pre>
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
infix 4 %=

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an infix version of <a>assign</a>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .= c; _2 .= d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
--   
--   <i>It puts the state in the monad or it gets the hose again.</i>
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
infix 4 .=

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an alias for (<a>.=</a>).
--   
--   <pre>
--   &gt;&gt;&gt; execState (do assign _1 c; assign _2 d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
assign :: MonadState s m => ASetter s s a b -> b -> m ()

-- | Logically <a>&amp;&amp;</a> the target(s) of a <a>Bool</a>-valued
--   <a>Lens</a> or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ True $ (False, True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ False $ (False, True)
--   (False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 &&~

-- | Logically <a>||</a> the target(s) of a <a>Bool</a>-valued <a>Lens</a>
--   or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ True $ (False,True)
--   (True,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ False $ (False,True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   (<a>||~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 ||~

-- | Raise the target(s) of a floating-point valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an arbitrary power.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 **~ c
--   (a**c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both **~ c
--   (a**c,b**c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 **~ 10 $ (3,2)
--   (3,1024.0)
--   </pre>
--   
--   <pre>
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(**~) :: Floating a => ASetter s t a a -> a -> s -> t
infixr 4 **~

-- | Raise the target(s) of a fractionally valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 ^^~ (-1)
--   (1,0.5)
--   </pre>
--   
--   <pre>
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t
infixr 4 ^^~

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,3) &amp; _2 ^~ 2
--   (1,9)
--   </pre>
--   
--   <pre>
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t
infixr 4 ^~

-- | Divide the target(s) of a numerically valued <a>Lens</a>, <a>Iso</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 //~ c
--   (a / c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both //~ c
--   (a / c,b / c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 //~ 2
--   ("Hawaii",5.0)
--   </pre>
--   
--   <pre>
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
infixr 4 //~

-- | Decrement the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 -~ c
--   (a - c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both -~ c
--   (a - c,b - c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 -~ 2 $ (1,2)
--   (-1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapped.mapped -~ 1 $ [[4,5],[6,7]]
--   [[3,4],[5,6]]
--   </pre>
--   
--   <pre>
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(-~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 -~

-- | Multiply the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 *~ c
--   (a * c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both *~ c
--   (a * c,b * c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 *~ 4
--   (1,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just 24 &amp; mapped *~ 2
--   Just 48
--   </pre>
--   
--   <pre>
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(*~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 *~

-- | Increment the target(s) of a numerically valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 +~ c
--   (a + c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both +~ c
--   (a + c,b + c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 +~ 1
--   (1,3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(a,b),(c,d)] &amp; traverse.both +~ e
--   [(a + e,b + e),(c + e,d + e)]
--   </pre>
--   
--   <pre>
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(+~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 +~

-- | Set to <a>Just</a> a value with pass-through.
--   
--   This is mostly present for consistency, but may be useful for for
--   chaining assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?~</a> d</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   ("world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)
infixr 4 <?~

-- | Set with pass-through.
--   
--   This is mostly present for consistency, but may be useful for chaining
--   assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.~</a> t</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;.~ c
--   (c,(c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("good","morning","vietnam") &amp; _3 &lt;.~ "world"
--   ("world",("good","morning","world"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,Map.fromList [("goodnight","gracie")]) &amp; _2.at "hello" &lt;.~ Just "world"
--   (Just "world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<.~) :: ASetter s t a b -> b -> s -> (b, t)
infixr 4 <.~

-- | Set the target of a <a>Lens</a>, <a>Traversal</a> or <a>Setter</a> to
--   <a>Just</a> a value.
--   
--   <pre>
--   l <a>?~</a> t ≡ <a>set</a> l (<a>Just</a> t)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; id ?~ a
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ x
--   fromList [(3,x)]
--   </pre>
--   
--   <a>?~</a> can be used type-changily:
--   
--   <pre>
--   &gt;&gt;&gt; ('a', ('b', 'c')) &amp; _2.both ?~ 'x'
--   ('a',(Just 'x',Just 'x'))
--   </pre>
--   
--   <pre>
--   (<a>?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; t
--   </pre>
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
infixr 4 ?~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a ≡ <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f ≡ <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter'</a> or <a>Traversal</a> with a constant value, without
--   changing its type.
--   
--   This is a type restricted version of <a>set</a>, which retains the
--   type of the original.
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped x [a,b,c,d]
--   [x,x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' _2 "hello" (1,"world")
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped 0 [1,2,3,4]
--   [0,0,0,0]
--   </pre>
--   
--   Note: Attempting to adjust <a>set'</a> a <a>Fold</a> or <a>Getter</a>
--   will fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set'</a> :: <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
set' :: ASetter' s a -> a -> s -> s

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   <pre>
--   (<a>&lt;$</a>) ≡ <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _2 "hello" (1,())
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped () [1,2,3,4]
--   [(),(),(),()]
--   </pre>
--   
--   Note: Attempting to <a>set</a> a <a>Fold</a> or <a>Getter</a> will
--   fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set</a> :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
set :: ASetter s t a b -> b -> s -> t

-- | Modify the target of a <a>Lens</a> or all the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a function.
--   
--   <pre>
--   <a>fmap</a> ≡ <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a> ≡ <a>over</a> <a>traverse</a>
--   <a>sets</a> <a>.</a> <a>over</a> ≡ <a>id</a>
--   <a>over</a> <a>.</a> <a>sets</a> ≡ <a>id</a>
--   </pre>
--   
--   Given any valid <a>Setter</a> <tt>l</tt>, you can also rely on the
--   law:
--   
--   <pre>
--   <a>over</a> l f <a>.</a> <a>over</a> l g = <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (over mapped g [a,b,c]) == over mapped (f . g) [a,b,c]
--   True
--   </pre>
--   
--   Another way to view <a>over</a> is to say that it transforms a
--   <a>Setter</a> into a "semantic editor combinator".
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (Just a)
--   Just (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (*10) [1,2,3]
--   [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 show (10,20)
--   ("10",20)
--   </pre>
--   
--   <pre>
--   <a>over</a> :: <a>Setter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   <a>over</a> :: <a>ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | Clone an <a>IndexedSetter</a>.
cloneIndexedSetter :: AnIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | Build an <a>IndexPreservingSetter</a> from any <a>Setter</a>.
cloneIndexPreservingSetter :: ASetter s t a b -> IndexPreservingSetter s t a b

-- | Restore <a>ASetter</a> to a full <a>Setter</a>.
cloneSetter :: ASetter s t a b -> Setter s t a b

-- | Build a <a>Setter</a>, <a>IndexedSetter</a> or
--   <a>IndexPreservingSetter</a> depending on your choice of
--   <a>Profunctor</a>.
--   
--   <pre>
--   <a>sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b

-- | Build an index-preserving <a>Setter</a> from a map-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a> ≡ <a>id</a>
--   f g <a>.</a> f h ≡ f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>setting</a> <a>.</a> <a>over</a> ≡ <a>id</a>
--   <a>over</a> <a>.</a> <a>setting</a> ≡ <a>id</a>
--   </pre>
--   
--   Another way to view <a>sets</a> is that it takes a "semantic editor
--   combinator" and transforms it into a <a>Setter</a>.
--   
--   <pre>
--   <a>setting</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
setting :: ((a -> b) -> s -> t) -> IndexPreservingSetter s t a b

-- | This <a>Setter</a> can be used to map over the input of a
--   <a>Profunctor</a>.
--   
--   The most common <a>Profunctor</a> to use this with is
--   <tt>(-&gt;)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) g x
--   g (f x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ show) length [1,2,3]
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) h x y
--   h (f x) y
--   </pre>
--   
--   Map over the argument of the result of a function -- i.e., its second
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; (mapped.argument %~ f) h x y
--   h x (f y)
--   </pre>
--   
--   <pre>
--   <a>argument</a> :: <a>Setter</a> (b -&gt; r) (a -&gt; r) a b
--   </pre>
argument :: forall (p :: Type -> Type -> Type) b r a. Profunctor p => Setter (p b r) (p a r) a b

-- | This <a>Setter</a> can be used to map over all of the inputs to a
--   <a>Contravariant</a>.
--   
--   <pre>
--   <a>contramap</a> ≡ <a>over</a> <a>contramapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getPredicate (over contramapped (*2) (Predicate even)) 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getOp (over contramapped (*5) (Op show)) 100
--   "500"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Prelude.map ($ 1) $ over (mapped . _Unwrapping' Op . contramapped) (*12) [(*2),(+1),(^3)]
--   [24,13,1728]
--   </pre>
contramapped :: forall (f :: Type -> Type) b a. Contravariant f => Setter (f b) (f a) a b

-- | This <tt>setter</tt> can be used to modify all of the values in a
--   <a>Monad</a>.
--   
--   You sometimes have to use this rather than <a>mapped</a> -- due to
--   temporary insanity <a>Functor</a> was not a superclass of <a>Monad</a>
--   until GHC 7.10.
--   
--   <pre>
--   <a>liftM</a> ≡ <a>over</a> <a>lifted</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over lifted f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set lifted b (Just a)
--   Just b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>liftM</a></tt>.
lifted :: forall (m :: Type -> Type) a b. Monad m => Setter (m a) (m b) a b

-- | This <a>Setter</a> can be used to map over all of the values in a
--   <a>Functor</a>.
--   
--   <pre>
--   <a>fmap</a> ≡ <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a> ≡ <a>over</a> <a>traverse</a>
--   (<a>&lt;$</a>) ≡ <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (+1) [1,2,3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped x [a,b,c]
--   [x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[a,b],[c]] &amp; mapped.mapped +~ x
--   [[a + x,b + x],[c + x]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (mapped._2) length [("hello","world"),("leaders","!!!")]
--   [("hello",5),("leaders",3)]
--   </pre>
--   
--   <pre>
--   <a>mapped</a> :: <a>Functor</a> f =&gt; <a>Setter</a> (f a) (f b) a b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>fmap</a></tt>.
mapped :: forall (f :: Type -> Type) a b. Functor f => Setter (f a) (f b) a b

-- | Running a <a>Setter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type ASetter s t a b = a -> Identity b -> s -> Identity t

-- | This is a useful alias for use when consuming a <a>Setter'</a>.
--   
--   Most user code will never have to use this type.
--   
--   <pre>
--   type <a>ASetter'</a> = <a>Simple</a> <a>ASetter</a>
--   </pre>
type ASetter' s a = ASetter s s a a

-- | Running an <a>IndexedSetter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type AnIndexedSetter i s t a b = Indexed i a Identity b -> s -> Identity t

-- | <pre>
--   type <a>AnIndexedSetter'</a> i = <a>Simple</a> (<a>AnIndexedSetter</a> i)
--   </pre>
type AnIndexedSetter' i s a = AnIndexedSetter i s s a a

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter</a> and <a>AnIndexedSetter</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting (p :: Type -> Type -> Type) s t a b = p a Identity b -> s -> Identity t

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter'</a> and <a>AnIndexedSetter'</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting' (p :: Type -> Type -> Type) s a = Setting p s s a a

-- | A <a>Lens</a> is actually a lens family as described in
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   With great power comes great responsibility and a <a>Lens</a> is
--   subject to the three common sense <a>Lens</a> laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l v s)  ≡ v
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>set</a> l (<a>view</a> l s) s  ≡ s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>set</a> l v' (<a>set</a> l v s) ≡ <a>set</a> l v' s
--   </pre>
--   
--   These laws are strong enough that the 4 type parameters of a
--   <a>Lens</a> cannot vary fully independently. For more on how they
--   interact, read the "Why is it a Lens Family?" section of
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   There are some emergent properties of these laws:
--   
--   1) <tt><a>set</a> l s</tt> must be injective for every <tt>s</tt> This
--   is a consequence of law #1
--   
--   2) <tt><a>set</a> l</tt> must be surjective, because of law #2, which
--   indicates that it is possible to obtain any <tt>v</tt> from some
--   <tt>s</tt> such that <tt><a>set</a> s v = s</tt>
--   
--   3) Given just the first two laws you can prove a weaker form of law #3
--   where the values <tt>v</tt> that you are setting match:
--   
--   <pre>
--   <a>set</a> l v (<a>set</a> l v s) ≡ <a>set</a> l v s
--   </pre>
--   
--   Every <a>Lens</a> can be used directly as a <a>Setter</a> or
--   <a>Traversal</a>.
--   
--   You can also use a <a>Lens</a> for <a>Getting</a> as if it were a
--   <a>Fold</a> or <a>Getter</a>.
--   
--   Since every <a>Lens</a> is a valid <a>Traversal</a>, the
--   <a>Traversal</a> laws are required of any <a>Lens</a> you create:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (l f) <tt>.</tt> l g ≡ <a>getCompose</a> <tt>.</tt> l (<a>Compose</a> <tt>.</tt> <a>fmap</a> f <tt>.</tt> g)
--   </pre>
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; <a>LensLike</a> f s t a b
--   </pre>
type Lens s t a b = forall (f :: Type -> Type). Functor f => a -> f b -> s -> f t

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | Every <a>IndexedLens</a> is a valid <a>Lens</a> and a valid
--   <a>IndexedTraversal</a>.
type IndexedLens i s t a b = forall (f :: Type -> Type) (p :: Type -> Type -> Type). (Indexable i p, Functor f) => p a f b -> s -> f t

-- | <pre>
--   type <a>IndexedLens'</a> i = <a>Simple</a> (<a>IndexedLens</a> i)
--   </pre>
type IndexedLens' i s a = IndexedLens i s s a a

-- | An <a>IndexPreservingLens</a> leaves any index it is composed with
--   alone.
type IndexPreservingLens s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Functor f) => p a f b -> p s f t

-- | <pre>
--   type <a>IndexPreservingLens'</a> = <a>Simple</a> <a>IndexPreservingLens</a>
--   </pre>
type IndexPreservingLens' s a = IndexPreservingLens s s a a

-- | A <a>Traversal</a> can be used directly as a <a>Setter</a> or a
--   <a>Fold</a> (but not as a <a>Lens</a>) and provides the ability to
--   both read and update multiple fields, subject to some relatively weak
--   <a>Traversal</a> laws.
--   
--   These have also been known as multilenses, but they have the signature
--   and spirit of
--   
--   <pre>
--   <a>traverse</a> :: <a>Traversable</a> f =&gt; <a>Traversal</a> (f a) (f b) a b
--   </pre>
--   
--   and the more evocative name suggests their application.
--   
--   Most of the time the <a>Traversal</a> you will want to use is just
--   <a>traverse</a>, but you can also pass any <a>Lens</a> or <a>Iso</a>
--   as a <a>Traversal</a>, and composition of a <a>Traversal</a> (or
--   <a>Lens</a> or <a>Iso</a>) with a <a>Traversal</a> (or <a>Lens</a> or
--   <a>Iso</a>) using (<tt>.</tt>) forms a valid <a>Traversal</a>.
--   
--   The laws for a <a>Traversal</a> <tt>t</tt> follow from the laws for
--   <a>Traversable</a> as stated in "The Essence of the Iterator Pattern".
--   
--   <pre>
--   t <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (t f) <tt>.</tt> t g ≡ <a>getCompose</a> <tt>.</tt> t (<a>Compose</a> <tt>.</tt> <a>fmap</a> f <tt>.</tt> g)
--   </pre>
--   
--   One consequence of this requirement is that a <a>Traversal</a> needs
--   to leave the same number of elements as a candidate for subsequent
--   <a>Traversal</a> that it started with. Another testament to the
--   strength of these laws is that the caveat expressed in section 5.5 of
--   the "Essence of the Iterator Pattern" about exotic <a>Traversable</a>
--   instances that <a>traverse</a> the same entry multiple times was
--   actually already ruled out by the second law in that same paper!
type Traversal s t a b = forall (f :: Type -> Type). Applicative f => a -> f b -> s -> f t

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a
type Traversal1 s t a b = forall (f :: Type -> Type). Apply f => a -> f b -> s -> f t
type Traversal1' s a = Traversal1 s s a a

-- | Every <a>IndexedTraversal</a> is a valid <a>Traversal</a> or
--   <a>IndexedFold</a>.
--   
--   The <a>Indexed</a> constraint is used to allow an
--   <a>IndexedTraversal</a> to be used directly as a <a>Traversal</a>.
--   
--   The <a>Traversal</a> laws are still required to hold.
--   
--   In addition, the index <tt>i</tt> should satisfy the requirement that
--   it stays unchanged even when modifying the value <tt>a</tt>, otherwise
--   traversals like <tt>indices</tt> break the <a>Traversal</a> laws.
type IndexedTraversal i s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Applicative f) => p a f b -> s -> f t

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a
type IndexedTraversal1 i s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Apply f) => p a f b -> s -> f t
type IndexedTraversal1' i s a = IndexedTraversal1 i s s a a

-- | An <a>IndexPreservingLens</a> leaves any index it is composed with
--   alone.
type IndexPreservingTraversal s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Applicative f) => p a f b -> p s f t

-- | <pre>
--   type <a>IndexPreservingTraversal'</a> = <a>Simple</a> <a>IndexPreservingTraversal</a>
--   </pre>
type IndexPreservingTraversal' s a = IndexPreservingTraversal s s a a
type IndexPreservingTraversal1 s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Apply f) => p a f b -> p s f t
type IndexPreservingTraversal1' s a = IndexPreservingTraversal1 s s a a

-- | The only <a>LensLike</a> law that can apply to a <a>Setter</a>
--   <tt>l</tt> is that
--   
--   <pre>
--   <a>set</a> l y (<a>set</a> l x a) ≡ <a>set</a> l y a
--   </pre>
--   
--   You can't <a>view</a> a <a>Setter</a> in general, so the other two
--   laws are irrelevant.
--   
--   However, two <a>Functor</a> laws apply to a <a>Setter</a>:
--   
--   <pre>
--   <a>over</a> l <tt>id</tt> ≡ <tt>id</tt>
--   <a>over</a> l f <tt>.</tt> <a>over</a> l g ≡ <a>over</a> l (f <tt>.</tt> g)
--   </pre>
--   
--   These can be stated more directly:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l f <tt>.</tt> <a>untainted</a> <tt>.</tt> l g ≡ l (f <tt>.</tt> <a>untainted</a> <tt>.</tt> g)
--   </pre>
--   
--   You can compose a <a>Setter</a> with a <a>Lens</a> or a
--   <a>Traversal</a> using (<tt>.</tt>) from the <tt>Prelude</tt> and the
--   result is always only a <a>Setter</a> and nothing more.
--   
--   <pre>
--   &gt;&gt;&gt; over traverse f [a,b,c,d]
--   [f a,f b,f c,f d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse._1) f [(a,b),(c,d)]
--   [(f a,b),(f c,d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both f (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse.both) f [(a,b),(c,d)]
--   [(f a,f b),(f c,f d)]
--   </pre>
type Setter s t a b = forall (f :: Type -> Type). Settable f => a -> f b -> s -> f t

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <tt>Char</tt>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Simple</a> <a>Setter</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | Every <a>IndexedSetter</a> is a valid <a>Setter</a>.
--   
--   The <a>Setter</a> laws are still required to hold.
type IndexedSetter i s t a b = forall (f :: Type -> Type) (p :: Type -> Type -> Type). (Indexable i p, Settable f) => p a f b -> s -> f t

-- | <pre>
--   type <a>IndexedSetter'</a> i = <a>Simple</a> (<a>IndexedSetter</a> i)
--   </pre>
type IndexedSetter' i s a = IndexedSetter i s s a a

-- | An <a>IndexPreservingSetter</a> can be composed with a
--   <a>IndexedSetter</a>, <a>IndexedTraversal</a> or <a>IndexedLens</a>
--   and leaves the index intact, yielding an <a>IndexedSetter</a>.
type IndexPreservingSetter s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Settable f) => p a f b -> p s f t

-- | <pre>
--   type <tt>IndexedPreservingSetter'</tt> i = <a>Simple</a> <tt>IndexedPreservingSetter</tt>
--   </pre>
type IndexPreservingSetter' s a = IndexPreservingSetter s s a a

-- | Isomorphism families can be composed with another <a>Lens</a> using
--   (<tt>.</tt>) and <tt>id</tt>.
--   
--   Since every <a>Iso</a> is both a valid <a>Lens</a> and a valid
--   <a>Prism</a>, the laws for those types imply the following laws for an
--   <a>Iso</a> <tt>f</tt>:
--   
--   <pre>
--   f <tt>.</tt> <a>from</a> f ≡ <tt>id</tt>
--   <a>from</a> f <tt>.</tt> f ≡ <tt>id</tt>
--   </pre>
--   
--   Note: Composition with an <a>Iso</a> is index- and measure-
--   preserving.
type Iso s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Profunctor p, Functor f) => p a f b -> p s f t

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | This is a limited form of a <a>Prism</a> that can only be used for
--   <tt>re</tt> operations.
--   
--   Like with a <a>Getter</a>, there are no laws to state for a
--   <a>Review</a>.
--   
--   You can generate a <a>Review</a> by using <tt>unto</tt>. You can also
--   use any <a>Prism</a> or <a>Iso</a> directly as a <a>Review</a>.
type Review t b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Choice p, Bifunctor p, Settable f) => Optic' p f t b

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Review</a> (in practice, this usually means a
--   <a>Prism</a>).
type AReview t b = Optic' Tagged :: Type -> Type -> Type Identity t b

-- | A <a>Prism</a> <tt>l</tt> is a <a>Traversal</a> that can also be
--   turned around with <a>re</a> to obtain a <a>Getter</a> in the opposite
--   direction.
--   
--   There are three laws that a <a>Prism</a> should satisfy:
--   
--   First, if I <a>re</a> or <a>review</a> a value with a <a>Prism</a> and
--   then <a>preview</a> or use (<a>^?</a>), I will get it back:
--   
--   <pre>
--   <a>preview</a> l (<a>review</a> l b) ≡ <tt>Just</tt> b
--   </pre>
--   
--   Second, if you can extract a value <tt>a</tt> using a <a>Prism</a>
--   <tt>l</tt> from a value <tt>s</tt>, then the value <tt>s</tt> is
--   completely described by <tt>l</tt> and <tt>a</tt>:
--   
--   <pre>
--   <a>preview</a> l s ≡ <tt>Just</tt> a ⟹ <a>review</a> l a ≡ s
--   </pre>
--   
--   Third, if you get non-match <tt>t</tt>, you can convert it result back
--   to <tt>s</tt>:
--   
--   <pre>
--   <a>matching</a> l s ≡ <tt>Left</tt> t ⟹ <a>matching</a> l t ≡ <tt>Left</tt> s
--   </pre>
--   
--   The first two laws imply that the <a>Traversal</a> laws hold for every
--   <a>Prism</a> and that we <a>traverse</a> at most 1 element:
--   
--   <pre>
--   <a>lengthOf</a> l x <tt>&lt;=</tt> 1
--   </pre>
--   
--   It may help to think of this as an <a>Iso</a> that can be partial in
--   one direction.
--   
--   Every <a>Prism</a> is a valid <a>Traversal</a>.
--   
--   Every <a>Iso</a> is a valid <a>Prism</a>.
--   
--   For example, you might have a <tt><a>Prism'</a> <tt>Integer</tt>
--   <a>Natural</a></tt> allows you to always go from a <a>Natural</a> to
--   an <tt>Integer</tt>, and provide you with tools to check if an
--   <tt>Integer</tt> is a <a>Natural</a> and/or to edit one if it is.
--   
--   <pre>
--   <tt>nat</tt> :: <a>Prism'</a> <tt>Integer</tt> <a>Natural</a>
--   <tt>nat</tt> = <a>prism</a> <tt>toInteger</tt> <tt>$</tt> \ i -&gt;
--      if i <tt>&lt;</tt> 0
--      then <tt>Left</tt> i
--      else <tt>Right</tt> (<tt>fromInteger</tt> i)
--   </pre>
--   
--   Now we can ask if an <tt>Integer</tt> is a <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5^?nat
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-5)^?nat
--   Nothing
--   </pre>
--   
--   We can update the ones that are:
--   
--   <pre>
--   &gt;&gt;&gt; (-3,4) &amp; both.nat *~ 2
--   (-3,8)
--   </pre>
--   
--   And we can then convert from a <a>Natural</a> to an <tt>Integer</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^. re nat -- :: Natural
--   5
--   </pre>
--   
--   Similarly we can use a <a>Prism</a> to <a>traverse</a> the
--   <tt>Left</tt> half of an <tt>Either</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" &amp; _Left %~ length
--   Left 5
--   </pre>
--   
--   or to construct an <tt>Either</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
--   
--   such that if you query it with the <a>Prism</a>, you will get your
--   original input back.
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left ^? _Left
--   Just 5
--   </pre>
--   
--   Another interesting way to think of a <a>Prism</a> is as the
--   categorical dual of a <a>Lens</a> -- a co-<a>Lens</a>, so to speak.
--   This is what permits the construction of <a>outside</a>.
--   
--   Note: Composition with a <a>Prism</a> is index-preserving.
type Prism s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Choice p, Applicative f) => p a f b -> p s f t

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | A witness that <tt>(a ~ s, b ~ t)</tt>.
--   
--   Note: Composition with an <a>Equality</a> is index-preserving.
type Equality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = forall k3 (p :: k1 -> k3 -> Type) (f :: k2 -> k3). () => p a f b -> p s f t

-- | A <a>Simple</a> <a>Equality</a>.
type Equality' (s :: k2) (a :: k2) = Equality s s a a

-- | Composable <tt>asTypeOf</tt>. Useful for constraining excess
--   polymorphism, <tt>foo . (id :: As Int) . bar</tt>.
type As (a :: k2) = Equality' a a

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall (f :: Type -> Type). (Contravariant f, Functor f) => a -> f a -> s -> f s

-- | Every <a>IndexedGetter</a> is a valid <a>IndexedFold</a> and can be
--   used for <a>Getting</a> like a <a>Getter</a>.
type IndexedGetter i s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Contravariant f, Functor f) => p a f a -> s -> f s

-- | An <a>IndexPreservingGetter</a> can be used as a <a>Getter</a>, but
--   when composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a>, <a>IndexedFold</a> or
--   <a>IndexedGetter</a> respectively.
type IndexPreservingGetter s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Contravariant f, Functor f) => p a f a -> p s f s

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall (f :: Type -> Type). (Contravariant f, Applicative f) => a -> f a -> s -> f s

-- | Every <a>IndexedFold</a> is a valid <a>Fold</a> and can be used for
--   <a>Getting</a>.
type IndexedFold i s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Contravariant f, Applicative f) => p a f a -> s -> f s

-- | An <a>IndexPreservingFold</a> can be used as a <a>Fold</a>, but when
--   composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a> respectively.
type IndexPreservingFold s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Contravariant f, Applicative f) => p a f a -> p s f s

-- | A relevant Fold (aka <a>Fold1</a>) has one or more targets.
type Fold1 s a = forall (f :: Type -> Type). (Contravariant f, Apply f) => a -> f a -> s -> f s
type IndexedFold1 i s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Contravariant f, Apply f) => p a f a -> s -> f s
type IndexPreservingFold1 s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Contravariant f, Apply f) => p a f a -> p s f s

-- | A <a>Simple</a> <a>Lens</a>, <a>Simple</a> <a>Traversal</a>, ... can
--   be used instead of a <a>Lens</a>,<a>Traversal</a>, ... whenever the
--   type variables don't change upon setting a value.
--   
--   <pre>
--   <a>_imagPart</a> :: <a>Simple</a> <a>Lens</a> (<a>Complex</a> a) a
--   <a>traversed</a> :: <a>Simple</a> (<a>IndexedTraversal</a> <tt>Int</tt>) [a] a
--   </pre>
--   
--   Note: To use this alias in your own code with <tt><a>LensLike</a>
--   f</tt> or <a>Setter</a>, you may have to turn on
--   <tt>LiberalTypeSynonyms</tt>.
--   
--   This is commonly abbreviated as a "prime" marker, <i>e.g.</i>
--   <a>Lens'</a> = <a>Simple</a> <a>Lens</a>.
type Simple (f :: k1 -> k1 -> k2 -> k2 -> k) (s :: k1) (a :: k2) = f s s a a

-- | A valid <a>Optic</a> <tt>l</tt> should satisfy the laws:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l (<tt>Procompose</tt> f g) = <tt>Procompose</tt> (l f) (l g)
--   </pre>
--   
--   This gives rise to the laws for <a>Equality</a>, <a>Iso</a>,
--   <a>Prism</a>, <a>Lens</a>, <a>Traversal</a>, <a>Traversal1</a>,
--   <a>Setter</a>, <a>Fold</a>, <a>Fold1</a>, and <a>Getter</a> as well
--   along with their index-preserving variants.
--   
--   <pre>
--   type <a>LensLike</a> f s t a b = <a>Optic</a> (-&gt;) f s t a b
--   </pre>
type Optic (p :: k -> k1 -> Type) (f :: k2 -> k1) (s :: k) (t :: k2) (a :: k) (b :: k2) = p a f b -> p s f t

-- | <pre>
--   type <a>Optic'</a> p f s a = <a>Simple</a> (<a>Optic</a> p f) s a
--   </pre>
type Optic' (p :: k -> k1 -> Type) (f :: k -> k1) (s :: k) (a :: k) = Optic p f s s a a

-- | <pre>
--   type <a>LensLike</a> f s t a b = <a>Optical</a> (-&gt;) (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Over</a> p f s t a b = <a>Optical</a> p (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Optic</a> p f s t a b = <a>Optical</a> p p f s t a b
--   </pre>
type Optical (p :: k -> k1 -> Type) (q :: k2 -> k1 -> Type) (f :: k3 -> k1) (s :: k2) (t :: k3) (a :: k) (b :: k3) = p a f b -> q s f t

-- | <pre>
--   type <a>Optical'</a> p q f s a = <a>Simple</a> (<a>Optical</a> p q f) s a
--   </pre>
type Optical' (p :: k -> k1 -> Type) (q :: k -> k1 -> Type) (f :: k -> k1) (s :: k) (a :: k) = Optical p q f s s a a

-- | Many combinators that accept a <a>Lens</a> can also accept a
--   <a>Traversal</a> in limited situations.
--   
--   They do so by specializing the type of <a>Functor</a> that they
--   require of the caller.
--   
--   If a function accepts a <tt><a>LensLike</a> f s t a b</tt> for some
--   <a>Functor</a> <tt>f</tt>, then they may be passed a <a>Lens</a>.
--   
--   Further, if <tt>f</tt> is an <a>Applicative</a>, they may also be
--   passed a <a>Traversal</a>.
type LensLike (f :: k -> Type) s (t :: k) a (b :: k) = a -> f b -> s -> f t

-- | <pre>
--   type <a>LensLike'</a> f = <a>Simple</a> (<a>LensLike</a> f)
--   </pre>
type LensLike' (f :: Type -> Type) s a = LensLike f s s a a

-- | Convenient alias for constructing indexed lenses and their ilk.
type IndexedLensLike i (f :: k -> Type) s (t :: k) a (b :: k) = forall (p :: Type -> Type -> Type). Indexable i p => p a f b -> s -> f t

-- | Convenient alias for constructing simple indexed lenses and their ilk.
type IndexedLensLike' i (f :: Type -> Type) s a = IndexedLensLike i f s s a a

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
type Over (p :: k -> Type -> Type) (f :: k1 -> Type) s (t :: k1) (a :: k) (b :: k1) = p a f b -> s -> f t

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
--   
--   <pre>
--   type <a>Over'</a> p f = <a>Simple</a> (<a>Over</a> p f)
--   </pre>
type Over' (p :: Type -> Type -> Type) (f :: Type -> Type) s a = Over p f s s a a

-- | Anything <a>Settable</a> must be isomorphic to the <a>Identity</a>
--   <a>Functor</a>.
class (Applicative f, Distributive f, Traversable f) => Settable (f :: Type -> Type)

-- | This is a profunctor used internally to implement <a>Review</a>
--   
--   It plays a role similar to that of <a>Accessor</a> or <tt>Const</tt>
--   do for <a>Control.Lens.Getter</a>
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b

-- | This class is provided mostly for backwards compatibility with lens
--   3.8, but it can also shorten type signatures.
class (Profunctor p, Bifunctor p) => Reviewable (p :: Type -> Type -> Type)

-- | This provides a way to peek at the internal structure of a
--   <a>Traversal</a> or <a>IndexedTraversal</a>
data Magma i t b a

-- | This data type represents a path-compressed copy of one level of a
--   source data structure. We can safely use path-compression because we
--   know the depth of the tree.
--   
--   Path compression is performed by viewing a <a>Level</a> as a PATRICIA
--   trie of the paths into the structure to leaves at a given depth,
--   similar in many ways to a <a>IntMap</a>, but unlike a regular PATRICIA
--   trie we do not need to store the mask bits merely the depth of the
--   fork.
--   
--   One invariant of this structure is that underneath a <a>Two</a> node
--   you will not find any <a>Zero</a> nodes, so <a>Zero</a> can only occur
--   at the root.
data Level i a

-- | This class provides a generalized notion of list reversal extended to
--   other containers.
class Reversing t
reversing :: Reversing t => t -> t

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar</a> a b t</tt>
--   holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar</a> holds many stores and you can easily add
--   more.
--   
--   This is a final encoding of <a>Bazaar</a>.
newtype Bazaar (p :: Type -> Type -> Type) a b t
Bazaar :: (forall (f :: Type -> Type). Applicative f => p a (f b) -> f t) -> Bazaar (p :: Type -> Type -> Type) a b t
[runBazaar] :: Bazaar (p :: Type -> Type -> Type) a b t -> forall (f :: Type -> Type). Applicative f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar'</a> p a t = <a>Bazaar</a> p a a t
--   </pre>
type Bazaar' (p :: Type -> Type -> Type) a = Bazaar p a a

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar1</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar1</a> a b
--   t</tt> holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar1</a> holds many stores and you can easily
--   add more.
--   
--   This is a final encoding of <a>Bazaar1</a>.
newtype Bazaar1 (p :: Type -> Type -> Type) a b t
Bazaar1 :: (forall (f :: Type -> Type). Apply f => p a (f b) -> f t) -> Bazaar1 (p :: Type -> Type -> Type) a b t
[runBazaar1] :: Bazaar1 (p :: Type -> Type -> Type) a b t -> forall (f :: Type -> Type). Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar1'</a> p a t = <a>Bazaar1</a> p a a t
--   </pre>
type Bazaar1' (p :: Type -> Type -> Type) a = Bazaar1 p a a

-- | The indexed store can be used to characterize a <a>Lens</a> and is
--   used by <a>cloneLens</a>.
--   
--   <tt><a>Context</a> a b t</tt> is isomorphic to <tt>newtype
--   <a>Context</a> a b t = <a>Context</a> { runContext :: forall f.
--   <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; f t }</tt>, and to
--   <tt>exists s. (s, <a>Lens</a> s t a b)</tt>.
--   
--   A <a>Context</a> is like a <a>Lens</a> that has already been applied
--   to a some structure.
data Context a b t
Context :: (b -> t) -> a -> Context a b t

-- | <pre>
--   type <a>Context'</a> a s = <a>Context</a> a a s
--   </pre>
type Context' a = Context a a

-- | When composed with an <tt>IndexedFold</tt> or
--   <tt>IndexedTraversal</tt> this yields an (<a>Indexed</a>)
--   <tt>Fold</tt> of the indices.
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)

-- | Fold a container with indices returning both the indices and the
--   values.
--   
--   The result is only valid to compose in a <tt>Traversal</tt>, if you
--   don't edit the index as edits to the index have no effect.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex
--   [(0,10),(1,20),(2,30)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex . alongside negated (re _Show)
--   [(0,"10"),(-1,"20"),(-2,"30")]
--   </pre>
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   This combinator is like <a>indexing</a> except that it handles large
--   traversals and folds gracefully.
--   
--   <pre>
--   <a>indexing64</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int64</a> s a
--   <a>indexing64</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int64</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing64</a> :: <a>Indexable</a> <a>Int64</a> p =&gt; <a>LensLike</a> (<a>Indexing64</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   <pre>
--   <a>indexing</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int</a>  s t a b
--   <a>indexing</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   <a>indexing</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing</a> :: <a>Indexable</a> <a>Int</a> p =&gt; <a>LensLike</a> (<a>Indexing</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t

-- | This is a <a>Profunctor</a> that is both <a>Corepresentable</a> by
--   <tt>f</tt> and <a>Representable</a> by <tt>g</tt> such that <tt>f</tt>
--   is left adjoint to <tt>g</tt>. From this you can derive a lot of
--   structure due to the preservation of limits and colimits.
class (Choice p, Corepresentable p, Comonad Corep p, Traversable Corep p, Strong p, Representable p, Monad Rep p, MonadFix Rep p, Distributive Rep p, Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p, Closed p) => Conjoined (p :: Type -> Type -> Type)

-- | <a>Conjoined</a> is strong enough to let us distribute every
--   <a>Conjoined</a> <a>Profunctor</a> over every Haskell <a>Functor</a>.
--   This is effectively a generalization of <a>fmap</a>.
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)

-- | This permits us to make a decision at an outermost point about whether
--   or not we use an index.
--   
--   Ideally any use of this function should be done in such a way so that
--   you compute the same answer, but this cannot be enforced at the type
--   level.
conjoined :: Conjoined p => (p ~ ((->) :: Type -> Type -> Type) => q (a -> b) r) -> q (p a b) r -> q (p a b) r

-- | This class permits overloading of function application for things that
--   also admit a notion of a key or index.
class Conjoined p => Indexable i (p :: Type -> Type -> Type)

-- | Build a function from an <a>indexed</a> function.
indexed :: Indexable i p => p a b -> i -> a -> b

-- | A function with access to a index. This constructor may be useful when
--   you need to store an <a>Indexable</a> in a container to avoid
--   <tt>ImpredicativeTypes</tt>.
--   
--   <pre>
--   index :: Indexed i a b -&gt; i -&gt; a -&gt; b
--   </pre>
newtype Indexed i a b
Indexed :: (i -> a -> b) -> Indexed i a b
[runIndexed] :: Indexed i a b -> i -> a -> b

-- | Used internally by <a>traverseOf_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
data Traversed a (f :: Type -> Type)

-- | Used internally by <a>mapM_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
--   
--   See 4.16 Changelog entry for the explanation of "why not Apply f
--   =&gt;"?
data Sequenced a (m :: Type -> Type)

-- | Used for <a>firstOf</a>.
data Leftmost a

-- | Used for <a>lastOf</a>.
data Rightmost a
class (Foldable1 t, Traversable t) => Traversable1 (t :: Type -> Type)
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)

-- | Fold a value using its <a>Foldable</a> instance using explicitly
--   provided <a>Monoid</a> operations. This is like <tt>fold</tt> where
--   the <a>Monoid</a> instance can be manually specified.
--   
--   <pre>
--   <a>foldBy</a> <a>mappend</a> <a>mempty</a> ≡ <tt>fold</tt>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldBy (++) [] ["hello","world"]
--   "helloworld"
--   </pre>
foldBy :: Foldable t => (a -> a -> a) -> a -> t a -> a

-- | Fold a value using its <a>Foldable</a> instance using explicitly
--   provided <a>Monoid</a> operations. This is like <a>foldMap</a> where
--   the <a>Monoid</a> instance can be manually specified.
--   
--   <pre>
--   <a>foldMapBy</a> <a>mappend</a> <a>mempty</a> ≡ <a>foldMap</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMapBy (+) 0 length ["hello","world"]
--   10
--   </pre>
foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r

-- | Traverse a container using its <a>Traversable</a> instance using
--   explicitly provided <a>Applicative</a> operations. This is like
--   <a>traverse</a> where the <a>Applicative</a> instance can be manually
--   specified.
traverseBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> t a -> f (t b)

-- | Sequence a container using its <a>Traversable</a> instance using
--   explicitly provided <a>Applicative</a> operations. This is like
--   <a>sequence</a> where the <a>Applicative</a> instance can be manually
--   specified.
sequenceBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)

-- | The generalization of <a>Costar</a> of <a>Functor</a> that is strong
--   with respect to <a>Either</a>.
--   
--   Note: This is also a notion of strength, except with regards to
--   another monoidal structure that we can choose to equip Hask with: the
--   cocartesian coproduct.
class Profunctor p => Choice (p :: Type -> Type -> Type)

-- | Laws:
--   
--   <pre>
--   <a>left'</a> ≡ <a>dimap</a> swapE swapE <a>.</a> <a>right'</a> where
--     swapE :: <a>Either</a> a b -&gt; <a>Either</a> b a
--     swapE = <a>either</a> <a>Right</a> <a>Left</a>
--   <a>rmap</a> <a>Left</a> ≡ <a>lmap</a> <a>Left</a> <a>.</a> <a>left'</a>
--   <a>lmap</a> (<a>right</a> f) <a>.</a> <a>left'</a> ≡ <a>rmap</a> (<a>right</a> f) <a>.</a> <a>left'</a>
--   <a>left'</a> <a>.</a> <a>left'</a> ≡ <a>dimap</a> assocE unassocE <a>.</a> <a>left'</a> where
--     assocE :: <a>Either</a> (<a>Either</a> a b) c -&gt; <a>Either</a> a (<a>Either</a> b c)
--     assocE (<a>Left</a> (<a>Left</a> a)) = <a>Left</a> a
--     assocE (<a>Left</a> (<a>Right</a> b)) = <a>Right</a> (<a>Left</a> b)
--     assocE (<a>Right</a> c) = <a>Right</a> (<a>Right</a> c)
--     unassocE :: <a>Either</a> a (<a>Either</a> b c) -&gt; <a>Either</a> (<a>Either</a> a b) c
--     unassocE (<a>Left</a> a) = <a>Left</a> (<a>Left</a> a)
--     unassocE (<a>Right</a> (<a>Left</a> b)) = <a>Left</a> (<a>Right</a> b)
--     unassocE (<a>Right</a> (<a>Right</a> c)) = <a>Right</a> c
--   </pre>
left' :: Choice p => p a b -> p (Either a c) (Either b c)

-- | Laws:
--   
--   <pre>
--   <a>right'</a> ≡ <a>dimap</a> swapE swapE <a>.</a> <a>left'</a> where
--     swapE :: <a>Either</a> a b -&gt; <a>Either</a> b a
--     swapE = <a>either</a> <a>Right</a> <a>Left</a>
--   <a>rmap</a> <a>Right</a> ≡ <a>lmap</a> <a>Right</a> <a>.</a> <a>right'</a>
--   <a>lmap</a> (<a>left</a> f) <a>.</a> <a>right'</a> ≡ <a>rmap</a> (<a>left</a> f) <a>.</a> <a>right'</a>
--   <a>right'</a> <a>.</a> <a>right'</a> ≡ <a>dimap</a> unassocE assocE <a>.</a> <a>right'</a> where
--     assocE :: <a>Either</a> (<a>Either</a> a b) c -&gt; <a>Either</a> a (<a>Either</a> b c)
--     assocE (<a>Left</a> (<a>Left</a> a)) = <a>Left</a> a
--     assocE (<a>Left</a> (<a>Right</a> b)) = <a>Right</a> (<a>Left</a> b)
--     assocE (<a>Right</a> c) = <a>Right</a> (<a>Right</a> c)
--     unassocE :: <a>Either</a> a (<a>Either</a> b c) -&gt; <a>Either</a> (<a>Either</a> a b) c
--     unassocE (<a>Left</a> a) = <a>Left</a> (<a>Left</a> a)
--     unassocE (<a>Right</a> (<a>Left</a> b)) = <a>Left</a> (<a>Right</a> b)
--     unassocE (<a>Right</a> (<a>Right</a> c)) = <a>Right</a> c
--   </pre>
right' :: Choice p => p a b -> p (Either c a) (Either c b)

-- | A 4-dimensional vector.
data V4 a
V4 :: !a -> !a -> !a -> !a -> V4 a

-- | A space that distinguishes orthogonal basis vectors <a>_x</a>,
--   <a>_y</a>, <a>_z</a>, <a>_w</a>. (It may have more.)
class R3 t => R4 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V4 1 2 3 4 ^._w
--   4
--   </pre>
_w :: R4 t => Lens' (t a) a
_xyzw :: R4 t => Lens' (t a) (V4 a)

-- | A 3-dimensional vector
data V3 a
V3 :: !a -> !a -> !a -> V3 a

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (It may have more)
class R2 t => R3 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V3 1 2 3 ^. _z
--   3
--   </pre>
_z :: R3 t => Lens' (t a) a
_xyz :: R3 t => Lens' (t a) (V3 a)

-- | A 2-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V2 Int
--   V2 1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 + V2 3 4
--   V2 4 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 * V2 3 4
--   V2 3 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V2 1 2)
--   3
--   </pre>
data V2 a
V2 :: !a -> !a -> V2 a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | A 1-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V1 Int
--   V1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 + V1 3
--   V1 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 * V1 3
--   V1 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V1 2)
--   2
--   </pre>
newtype V1 a
V1 :: a -> V1 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V1 2 ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: R1 t => Lens' (t a) a

-- | <tt><a>between</a> open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces = between (symbol "{") (symbol "}")
--   </pre>
between :: Applicative m => m open -> m close -> m a -> m a

-- | <tt><a>choice</a> ps</tt> tries to apply the parsers in the list
--   <tt>ps</tt> in order, until one of them succeeds. Returns the value of
--   the succeeding parser.
--   
--   <pre>
--   choice = asum
--   </pre>
choice :: (Foldable f, Alternative m) => f (m a) -> m a

-- | Combine two alternatives.
--   
--   <pre>
--   eitherP a b = (Left &lt;$&gt; a) &lt;|&gt; (Right &lt;$&gt; b)
--   </pre>
eitherP :: Alternative m => m a -> m b -> m (Either a b)

-- | <tt><a>count</a> n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>.
--   If <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt><a>return</a> []</tt>. Returns a list of <tt>n</tt> values.
--   
--   See also: <a>skipCount</a>, <a>count'</a>.
count :: Monad m => Int -> m a -> m [a]

-- | <tt><a>count'</a> m n p</tt> parses from <tt>m</tt> to <tt>n</tt>
--   occurrences of <tt>p</tt>. If <tt>n</tt> is not positive or <tt>m &gt;
--   n</tt>, the parser equals to <tt><a>return</a> []</tt>. Returns a list
--   of parsed values.
--   
--   Please note that <tt>m</tt> <i>may</i> be negative, in this case
--   effect is the same as if it were equal to zero.
--   
--   See also: <a>skipCount</a>, <a>count</a>.
count' :: MonadPlus m => Int -> Int -> m a -> m [a]

-- | <tt><a>endBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>manyTill</a> p end</tt> applies parser <tt>p</tt> <i>zero</i>
--   or more times until parser <tt>end</tt> succeeds. Returns the list of
--   values returned by <tt>p</tt>. <b>Note</b> that <tt>end</tt> result is
--   consumed and lost. Use <a>manyTill_</a> if you wish to keep it.
--   
--   See also: <a>skipMany</a>, <a>skipManyTill</a>.
manyTill :: MonadPlus m => m a -> m end -> m [a]

-- | <tt><a>manyTill_</a> p end</tt> applies parser <tt>p</tt> <i>zero</i>
--   or more times until parser <tt>end</tt> succeeds. Returns the list of
--   values returned by <tt>p</tt> and the <tt>end</tt> result. Use
--   <a>manyTill</a> if you have no need in the result of the <tt>end</tt>.
--   
--   See also: <a>skipMany</a>, <a>skipManyTill</a>.
manyTill_ :: MonadPlus m => m a -> m end -> m ([a], end)

-- | <tt><a>someTill</a> p end</tt> works similarly to <tt><a>manyTill</a>
--   p end</tt>, but <tt>p</tt> should succeed at least once. <b>Note</b>
--   that <tt>end</tt> result is consumed and lost. Use <a>someTill_</a> if
--   you wish to keep it.
--   
--   <pre>
--   someTill p end = liftM2 (:) p (manyTill p end)
--   </pre>
--   
--   See also: <a>skipSome</a>, <a>skipSomeTill</a>.
someTill :: MonadPlus m => m a -> m end -> m [a]

-- | <tt><a>someTill_</a> p end</tt> works similarly to
--   <tt><a>manyTill_</a> p end</tt>, but <tt>p</tt> should succeed at
--   least once. Use <a>someTill</a> if you have no need in the result of
--   the <tt>end</tt>.
--   
--   See also: <a>skipSome</a>, <a>skipSomeTill</a>.
someTill_ :: MonadPlus m => m a -> m end -> m ([a], end)

-- | <tt><a>sepBy</a> p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p = p `sepBy` comma
--   </pre>
sepBy :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>sepBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>sepEndBy</a> p sep</tt> parses <i>zero</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a list of values returned by <tt>p</tt>.
sepEndBy :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>sepEndBy1</a> p sep</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a list of values returned by <tt>p</tt>.
sepEndBy1 :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>skipMany</a> p</tt> applies the parser <tt>p</tt> <i>zero</i>
--   or more times, skipping its result.
--   
--   See also: <a>manyTill</a>, <a>skipManyTill</a>.
skipMany :: MonadPlus m => m a -> m ()

-- | <tt><a>skipSome</a> p</tt> applies the parser <tt>p</tt> <i>one</i> or
--   more times, skipping its result.
--   
--   See also: <a>someTill</a>, <a>skipSomeTill</a>.
skipSome :: MonadPlus m => m a -> m ()

-- | <tt><a>skipCount</a> n p</tt> parses <tt>n</tt> occurrences of
--   <tt>p</tt>, skipping its result. If <tt>n</tt> is smaller or equal to
--   zero, the parser equals to <tt><a>return</a> []</tt>. Returns a list
--   of <tt>n</tt> values.
--   
--   See also: <a>count</a>, <a>count'</a>.
skipCount :: Monad m => Int -> m a -> m ()

-- | <tt><a>skipManyTill</a> p end</tt> applies the parser <tt>p</tt>
--   <i>zero</i> or more times skipping results until parser <tt>end</tt>
--   succeeds. Result parsed by <tt>end</tt> is then returned.
--   
--   See also: <a>manyTill</a>, <a>skipMany</a>.
skipManyTill :: MonadPlus m => m a -> m end -> m end

-- | <tt><a>skipSomeTill</a> p end</tt> applies the parser <tt>p</tt>
--   <i>one</i> or more times skipping results until parser <tt>end</tt>
--   succeeds. Result parsed by <tt>end</tt> is then returned.
--   
--   See also: <a>someTill</a>, <a>skipSome</a>.
skipSomeTill :: MonadPlus m => m a -> m end -> m end

-- | <tt><a>signed</a> space p</tt> parser parses an optional sign
--   character (“+” or “-”), then if there is a sign it consumes optional
--   white space (using <tt>space</tt> parser), then it runs parser
--   <tt>p</tt> which should return a number. Sign of the number is changed
--   according to the previously parsed sign character.
--   
--   For example, to parse signed integer you can write:
--   
--   <pre>
--   lexeme        = L.lexeme spaceConsumer
--   integer       = lexeme L.decimal
--   signedInteger = L.signed spaceConsumer integer
--   </pre>
signed :: (MonadParsec e s m, Token s ~ Char, Num a) => m () -> m a -> m a

-- | Parse a floating point number according to the syntax for floating
--   point literals described in the Haskell report.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
--   
--   <b>Note</b>: before version 6.0.0 the function returned <a>Double</a>,
--   i.e. it wasn't polymorphic in its return type.
--   
--   <b>Note</b>: in versions 6.0.0–6.1.1 this function accepted plain
--   integers.
float :: (MonadParsec e s m, Token s ~ Char, RealFloat a) => m a

-- | Parse a floating point value as a <a>Scientific</a> number.
--   <a>Scientific</a> is great for parsing of arbitrary precision numbers
--   coming from an untrusted source. See documentation in
--   <a>Data.Scientific</a> for more information.
--   
--   The parser can be used to parse integers or floating point values. Use
--   functions like <a>floatingOrInteger</a> from <a>Data.Scientific</a> to
--   test and extract integer or real values.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
scientific :: (MonadParsec e s m, Token s ~ Char) => m Scientific

-- | Parse an integer in hexadecimal representation. Representation of
--   hexadecimal number is expected to be according to the Haskell report
--   except for the fact that this parser doesn't parse “0x” or “0X”
--   prefix. It is a responsibility of the programmer to parse correct
--   prefix before parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   hexadecimal = char '0' &gt;&gt; char' 'x' &gt;&gt; L.hexadecimal
--   </pre>
--   
--   <b>Note</b>: before version 6.0.0 the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
hexadecimal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse an integer in octal representation. Representation of octal
--   number is expected to be according to the Haskell report except for
--   the fact that this parser doesn't parse “0o” or “0O” prefix. It is a
--   responsibility of the programmer to parse correct prefix before
--   parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   octal = char '0' &gt;&gt; char' 'o' &gt;&gt; L.octal
--   </pre>
--   
--   <b>Note</b>: before version 6.0.0 the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
octal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse an integer in binary representation. Binary number is expected
--   to be a non-empty sequence of zeroes “0” and ones “1”.
--   
--   You could of course parse some prefix before the actual number:
--   
--   <pre>
--   binary = char '0' &gt;&gt; char' 'b' &gt;&gt; L.binary
--   </pre>
binary :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse an integer in decimal representation according to the format of
--   integer literals described in the Haskell report.
--   
--   If you need to parse signed integers, see the <a>signed</a>
--   combinator.
--   
--   <b>Note</b>: before version 6.0.0 the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
decimal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | A type-constrained version of <a>single</a>.
--   
--   <pre>
--   semicolon = char ';'
--   </pre>
char :: (MonadParsec e s m, Token s ~ Char) => Token s -> m (Token s)

-- | Parse a character from the first 128 characters of the Unicode
--   character set, corresponding to the ASCII character set.
asciiChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a hexadecimal digit, i.e. between “0” and “9”, or “a” and “f”,
--   or “A” and “F”.
hexDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an octal digit, i.e. between “0” and “7”.
octDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a binary digit, i.e. "0" or "1".
binDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an ASCII digit, i.e between “0” and “9”.
digitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Skip <i>one</i> or more white space characters.
--   
--   See also: <a>skipSome</a> and <a>spaceChar</a>.
space1 :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Skip <i>zero</i> or more white space characters.
--   
--   See also: <a>skipMany</a> and <a>spaceChar</a>.
space :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Parse a newline character.
newline :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | The same as <a>string</a>, but case-insensitive. On success returns
--   string cased as actually parsed input.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string' "foobar") "foObAr"
--   "foObAr"
--   </pre>
string' :: (MonadParsec e s m, FoldCase (Tokens s)) => Tokens s -> m (Tokens s)

-- | A synonym for <a>chunk</a>.
string :: MonadParsec e s m => Tokens s -> m (Tokens s)

-- | As the dual of <a>oneOf</a>, <tt><a>noneOf</a> ts</tt> succeeds if the
--   current token <i>not</i> in the supplied list of tokens <tt>ts</tt>.
--   Returns the parsed character. Note that this parser cannot
--   automatically generate the “expected” component of error message, so
--   usually you should label it manually with <a>label</a> or
--   (<a>&lt;?&gt;</a>).
--   
--   <pre>
--   noneOf cs = satisfy (`notElem` cs)
--   </pre>
--   
--   See also: <a>satisfy</a>.
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> and <a>anySingleBut</a>
--   when you can because it's faster.
noneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | <tt><a>oneOf</a> ts</tt> succeeds if the current token is in the
--   supplied collection of tokens <tt>ts</tt>. Returns the parsed token.
--   Note that this parser cannot automatically generate the “expected”
--   component of error message, so usually you should label it manually
--   with <a>label</a> or (<a>&lt;?&gt;</a>).
--   
--   <pre>
--   oneOf cs = satisfy (`elem` cs)
--   </pre>
--   
--   See also: <a>satisfy</a>.
--   
--   <pre>
--   digit = oneOf ['0'..'9'] &lt;?&gt; "digit"
--   </pre>
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> when you can because
--   it's faster when you have only a couple of tokens to compare to:
--   
--   <pre>
--   quoteFast = satisfy (\x -&gt; x == '\'' || x == '\"')
--   quoteSlow = oneOf "'\""
--   </pre>
oneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | Match any token but the given one. It's a good idea to attach a
--   <a>label</a> to this parser.
--   
--   <pre>
--   anySingleBut t = satisfy (/= t)
--   </pre>
--   
--   See also: <a>single</a>, <a>anySingle</a>, <a>satisfy</a>.
anySingleBut :: MonadParsec e s m => Token s -> m (Token s)

-- | Parse and return a single token. It's a good idea to attach a
--   <a>label</a> to this parser.
--   
--   <pre>
--   anySingle = satisfy (const True)
--   </pre>
--   
--   See also: <a>satisfy</a>, <a>anySingleBut</a>.
anySingle :: MonadParsec e s m => m (Token s)

-- | The parser <tt><a>satisfy</a> f</tt> succeeds for any token for which
--   the supplied function <tt>f</tt> returns <a>True</a>.
--   
--   <pre>
--   digitChar = satisfy isDigit &lt;?&gt; "digit"
--   oneOf cs  = satisfy (`elem` cs)
--   </pre>
--   
--   See also: <a>anySingle</a>, <a>anySingleBut</a>, <a>oneOf</a>,
--   <a>noneOf</a>.
satisfy :: MonadParsec e s m => (Token s -> Bool) -> m (Token s)

-- | <a>Parsec</a> is a non-transformer variant of the more general
--   <a>ParsecT</a> monad transformer.
type Parsec e s = ParsecT e s Identity

-- | The parser <tt><a>try</a> p</tt> behaves like parser <tt>p</tt>,
--   except that it backtracks the parser state when <tt>p</tt> fails
--   (either consuming input or not).
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   if the first parser failed while consuming input.
--   
--   For example, here is a parser that is supposed to parse the word “let”
--   or the word “lexical”:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string "let" &lt;|&gt; string "lexical") "lexical"
--   1:1:
--   unexpected "lex"
--   expecting "let"
--   </pre>
--   
--   What happens here? The first parser consumes “le” and fails (because
--   it doesn't see a “t”). The second parser, however, isn't tried, since
--   the first parser has already consumed some input! <a>try</a> fixes
--   this behavior and allows backtracking to work:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "lexical"
--   "lexical"
--   </pre>
--   
--   <a>try</a> also improves error messages in case of overlapping
--   alternatives, because Megaparsec's hint system can be used:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "le"
--   1:1:
--   unexpected "le"
--   expecting "let" or "lexical"
--   </pre>
--   
--   <b>Note</b> that as of Megaparsec 4.4.0, <a>string</a> backtracks
--   automatically (see <a>tokens</a>), so it does not need <a>try</a>.
--   However, the examples above demonstrate the idea behind <a>try</a> so
--   well that it was decided to keep them. You still need to use
--   <a>try</a> when your alternatives are complex, composite parsers.
try :: MonadParsec e s m => m a -> m a

-- | This parser only succeeds at the end of input.
eof :: MonadParsec e s m => m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: forall s (m :: Type -> Type) a. (s -> s) -> StateT s m a -> StateT s m a

-- | A non-empty (by construction) set of values <tt>a</tt>. At least one
--   value exists in an <tt><a>NESet</a> a</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NESet</a> can safely operate on it
--   with the assumption that it has at least one item.
--   
--   Functions that <i>return</i> an <a>NESet</a> provide an assurance that
--   the result has at least one item.
--   
--   <a>Data.Set.NonEmpty</a> re-exports the API of <a>Data.Set</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output sets are both
--   non-empty (like <a>insert</a>) return <a>NESet</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Set</a> instead.
--   
--   You can directly construct an <a>NESet</a> with the API from
--   <a>Data.Set.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Set</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NESet</a> from a <a>Set</a>:
--   
--   <ol>
--   <li>The <a>nonEmptySet</a> smart constructor will convert a
--   <tt><a>Set</a> a</tt> into a <tt><a>Maybe</a> (<a>NESet</a> a)</tt>,
--   returning <a>Nothing</a> if the original <a>Set</a> was empty.</li>
--   <li>You can use the <a>insertSet</a> family of functions to insert a
--   value into a <a>Set</a> to create a guaranteed <a>NESet</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Set</a> to reveal it as either containing a
--   <a>NESet</a> or an empty map.</li>
--   <li><a>withNonEmpty</a> offers a continuation-based interface for
--   deconstructing a <a>Set</a> and treating it as if it were an
--   <a>NESet</a>.</li>
--   </ol>
--   
--   You can convert an <a>NESet</a> into a <a>Set</a> with <a>toSet</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NESet a

-- | A non-empty (by construction) map from keys <tt>k</tt> to values
--   <tt>a</tt>. At least one key-value pair exists in an <tt><a>NEMap</a>
--   k v</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <a>insert</a>) return <a>NEMap</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <a>insertMap</a> family of functions to insert a
--   value into a <a>Map</a> to create a guaranteed <a>NEMap</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Map</a> to reveal it as either containing a
--   <a>NEMap</a> or an empty map.</li>
--   <li><a>withNonEmpty</a> offers a continuation-based interface for
--   deconstructing a <a>Map</a> and treating it as if it were an
--   <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a <a>Map</a> with <a>toMap</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NEMap k a

-- | A non-empty (by construction) set of integers. At least one value
--   exists in an <tt><a>NEIntSet</a> a</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NEIntSet</a> can safely operate on it
--   with the assumption that it has at least one item.
--   
--   Functions that <i>return</i> an <a>NEIntSet</a> provide an assurance
--   that the result has at least one item.
--   
--   <a>Data.IntSet.NonEmpty</a> re-exports the API of <a>Data.IntSet</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output sets are both
--   non-empty (like <a>insert</a>) return <a>NEIntSet</a>, but functions
--   that might potentially return an empty map (like <a>delete</a>) return
--   a <a>IntSet</a> instead.
--   
--   You can directly construct an <a>NEIntSet</a> with the API from
--   <a>Data.IntSet.NonEmpty</a>; it's more or less the same as
--   constructing a normal <a>IntSet</a>, except you don't have access to
--   <a>empty</a>. There are also a few ways to construct an
--   <a>NEIntSet</a> from a <a>IntSet</a>:
--   
--   <ol>
--   <li>The <a>nonEmptySet</a> smart constructor will convert a
--   <tt><a>IntSet</a> a</tt> into a <tt><a>Maybe</a> (<a>NEIntSet</a>
--   a)</tt>, returning <a>Nothing</a> if the original <a>IntSet</a> was
--   empty.</li>
--   <li>You can use the <a>insertIntSet</a> family of functions to insert
--   a value into a <a>IntSet</a> to create a guaranteed
--   <a>NEIntSet</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>IntSet</a> to reveal it as either containing a
--   <a>NEIntSet</a> or an empty map.</li>
--   <li><a>withNonEmpty</a> offers a continuation-based interface for
--   deconstructing a <a>IntSet</a> and treating it as if it were an
--   <a>NEIntSet</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEIntSet</a> into a <a>IntSet</a> with
--   <a>toSet</a> or <a>IsNonEmpty</a>, essentially "obscuring" the
--   non-empty property from the type.
data NEIntSet

-- | A non-empty (by construction) map from integer keys to values
--   <tt>a</tt>. At least one key-value pair exists in an
--   <tt><a>NEIntMap</a> v</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NEIntMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEIntMap</a> provide an assurance
--   that the result has at least one key-value pair.
--   
--   <a>Data.IntMap.NonEmpty</a> re-exports the API of <a>Data.IntMap</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <a>insert</a>) return <a>NEIntMap</a>, but functions
--   that might potentially return an empty map (like <a>delete</a>) return
--   a <a>IntMap</a> instead.
--   
--   You can directly construct an <a>NEIntMap</a> with the API from
--   <a>Data.IntMap.NonEmpty</a>; it's more or less the same as
--   constructing a normal <a>IntMap</a>, except you don't have access to
--   <a>empty</a>. There are also a few ways to construct an
--   <a>NEIntMap</a> from a <a>IntMap</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>IntMap</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEIntMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>IntMap</a> was
--   empty.</li>
--   <li>You can use the <a>insertIntMap</a> family of functions to insert
--   a value into a <a>IntMap</a> to create a guaranteed
--   <a>NEIntMap</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>IntMap</a> to reveal it as either containing a
--   <a>NEIntMap</a> or an empty map.</li>
--   <li><a>withNonEmpty</a> offers a continuation-based interface for
--   deconstructing a <a>IntMap</a> and treating it as if it were an
--   <a>NEIntMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEIntMap</a> into a <a>IntMap</a> with
--   <a>toMap</a> or <a>IsNonEmpty</a>, essentially "obscuring" the
--   non-empty property from the type.
data NEIntMap a

-- | Divides up an input list into a set of sublists, according to
--   <tt>n</tt> and <tt>m</tt> input specifications you provide. Each
--   sublist will have <tt>n</tt> items, and the start of each sublist will
--   be offset by <tt>m</tt> items from the previous one.
--   
--   <pre>
--   divvy 5 5 [1..20] == [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
--   </pre>
--   
--   In the case where a source list's trailing elements do no fill an
--   entire sublist, those trailing elements will be dropped.
--   
--   <pre>
--   divvy 5 2 [1..10] == [[1,2,3,4,5],[3,4,5,6,7],[5,6,7,8,9]]
--   </pre>
--   
--   As an example, you can generate a moving average over a list of
--   prices:
--   
--   <pre>
--   type Prices = [Float]
--   type AveragePrices = [Float]
--   
--   average :: [Float] -&gt; Float
--   average xs = sum xs / (fromIntegral $ length xs)
--   
--   simpleMovingAverage :: Prices -&gt; AveragePrices
--   simpleMovingAverage priceList =
--     map average divvyedPrices
--       where divvyedPrices = divvy 20 1 priceList
--   </pre>
divvy :: Int -> Int -> [a] -> [[a]]

-- | A useful recursion pattern for processing a list to produce a new
--   list, often used for "chopping" up the input list. Typically chop is
--   called with some function that will consume an initial prefix of the
--   list and produce a value and the rest of the list.
--   
--   For example, many common Prelude functions can be implemented in terms
--   of <tt>chop</tt>:
--   
--   <pre>
--   group :: (Eq a) =&gt; [a] -&gt; [[a]]
--   group = chop (\ xs@(x:_) -&gt; span (==x) xs)
--   
--   words :: String -&gt; [String]
--   words = filter (not . null) . chop (span (not . isSpace) . dropWhile isSpace)
--   </pre>
chop :: ([a] -> (b, [a])) -> [a] -> [b]

-- | Split a list into chunks of the given lengths. Unlike
--   <a>splitPlaces</a>, the output list will always be the same length as
--   the first input argument. If the input list is longer than the total
--   of the given lengths, then the remaining elements are dropped. If the
--   list is shorter than the total of the given lengths, then the last
--   several chunks will be shorter than requested or empty. For example:
--   
--   <pre>
--   splitPlacesBlanks [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]
--   splitPlacesBlanks [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]
--   splitPlacesBlanks [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10],[]]
--   </pre>
--   
--   Notice the empty list in the output of the third example, which
--   differs from the behavior of <a>splitPlaces</a>.
splitPlacesBlanks :: Integral a => [a] -> [e] -> [[e]]

-- | Split a list into chunks of the given lengths. For example:
--   
--   <pre>
--   splitPlaces [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]
--   splitPlaces [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]
--   splitPlaces [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]
--   </pre>
--   
--   If the input list is longer than the total of the given lengths, then
--   the remaining elements are dropped. If the list is shorter than the
--   total of the given lengths, then the result may contain fewer chunks
--   than requested, and the last chunk may be shorter than requested.
splitPlaces :: Integral a => [a] -> [e] -> [[e]]
splitEvery :: Int -> [e] -> [[e]]
chunk :: Int -> [e] -> [[e]]

-- | <tt><a>chunksOf</a> n</tt> splits a list into length-n pieces. The
--   last piece will be shorter if <tt>n</tt> does not evenly divide the
--   length of the list. If <tt>n &lt;= 0</tt>, <tt><a>chunksOf</a> n
--   l</tt> returns an infinite list of empty lists. For example:
--   
--   Note that <tt><a>chunksOf</a> n []</tt> is <tt>[]</tt>, not
--   <tt>[[]]</tt>. This is intentional, and is consistent with a recursive
--   definition of <a>chunksOf</a>; it satisfies the property that
--   
--   <pre>
--   chunksOf n xs ++ chunksOf n ys == chunksOf n (xs ++ ys)
--   </pre>
--   
--   whenever <tt>n</tt> evenly divides the length of <tt>xs</tt>.
chunksOf :: Int -> [e] -> [[e]]

-- | Split into "lines", with line boundaries indicated by the given
--   predicate. Satisfies <tt><a>lines</a> === linesBy (=='n')</tt>;
--   equivalent to <tt><a>split</a> . <a>dropFinalBlank</a> .
--   <a>dropDelims</a> . <a>whenElt</a></tt>. For example:
--   
--   <pre>
--   linesBy (=='x') "dogxxxcatxbirdxx" == ["dog","","","cat","bird",""]
--   </pre>
linesBy :: (a -> Bool) -> [a] -> [[a]]

-- | Split into "words", with word boundaries indicated by the given
--   predicate. Satisfies <tt><a>words</a> === wordsBy <a>isSpace</a></tt>;
--   equivalent to <tt><a>split</a> . <a>dropBlanks</a> . <a>dropDelims</a>
--   . <a>whenElt</a></tt>. For example:
--   
--   <pre>
--   wordsBy (=='x') "dogxxxcatxbirdxx" == ["dog","cat","bird"]
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]
unintercalate :: Eq a => [a] -> [a] -> [[a]]

-- | Split into chunks terminated by one of the given elements. Equivalent
--   to <tt><a>split</a> . <a>dropFinalBlank</a> . <a>dropDelims</a> .
--   <a>oneOf</a></tt>. For example:
--   
--   <pre>
--   endByOneOf ";," "foo;bar,baz;" == ["foo","bar","baz"]
--   </pre>
endByOneOf :: Eq a => [a] -> [a] -> [[a]]

-- | Split into chunks terminated by the given subsequence. Equivalent to
--   <tt><a>split</a> . <a>dropFinalBlank</a> . <a>dropDelims</a> .
--   <a>onSublist</a></tt>. For example:
--   
--   <pre>
--   endBy ";" "foo;bar;baz;" == ["foo","bar","baz"]
--   </pre>
--   
--   Note also that the <a>lines</a> function from <a>Data.List</a> is
--   equivalent to <tt><a>endBy</a> "\n"</tt>.
endBy :: Eq a => [a] -> [a] -> [[a]]
sepByOneOf :: Eq a => [a] -> [a] -> [[a]]

-- | Split on elements satisfying the given predicate. Equivalent to
--   <tt><a>split</a> . <a>dropDelims</a> . <a>whenElt</a></tt>. For
--   example:
--   
--   <pre>
--   splitWhen (&lt;0) [1,3,-4,5,7,-9,0,2] == [[1,3],[5,7],[0,2]]
--   </pre>
splitWhen :: (a -> Bool) -> [a] -> [[a]]

-- | Split on the given sublist. Equivalent to <tt><a>split</a> .
--   <a>dropDelims</a> . <a>onSublist</a></tt>. For example:
--   
--   <pre>
--   splitOn ".." "a..b...c....d.." == ["a","b",".c","","d",""]
--   </pre>
--   
--   In some parsing combinator frameworks this is also known as
--   <tt>sepBy</tt>.
--   
--   Note that this is the right inverse of the <a>intercalate</a> function
--   from <a>Data.List</a>, that is,
--   
--   <pre>
--   intercalate x . splitOn x === id
--   </pre>
--   
--   <tt><a>splitOn</a> x . <a>intercalate</a> x</tt> is the identity on
--   certain lists, but it is tricky to state the precise conditions under
--   which this holds. (For example, it is not enough to say that
--   <tt>x</tt> does not occur in any elements of the input list. Working
--   out why is left as an exercise for the reader.)
splitOn :: Eq a => [a] -> [a] -> [[a]]

-- | Split on any of the given elements. Equivalent to <tt><a>split</a> .
--   <a>dropDelims</a> . <a>oneOf</a></tt>. For example:
--   
--   <pre>
--   splitOneOf ";.," "foo,bar;baz.glurk" == ["foo","bar","baz","glurk"]
--   </pre>
splitOneOf :: Eq a => [a] -> [a] -> [[a]]

-- | Make a strategy that splits a list into chunks that all end with one
--   of the given elements, except possibly the last. Equivalent to
--   <tt><a>dropFinalBlank</a> . <a>keepDelimsR</a> . <a>oneOf</a></tt>.
--   For example:
--   
--   <pre>
--   split (condense $ endsWithOneOf ".,?! ") "Hi, there!  How are you?" == ["Hi, ","there!  ","How ","are ","you?"]
--   </pre>
endsWithOneOf :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all end with the
--   given subsequence, except possibly the last. Equivalent to
--   <tt><a>dropFinalBlank</a> . <a>keepDelimsR</a> .
--   <a>onSublist</a></tt>. For example:
--   
--   <pre>
--   split (endsWith "ly") "happilyslowlygnarlylily" == ["happily","slowly","gnarly","lily"]
--   </pre>
endsWith :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all start with one
--   of the given elements (except possibly the first). Equivalent to
--   <tt><a>dropInitBlank</a> . <a>keepDelimsL</a> . <a>oneOf</a></tt>. For
--   example:
--   
--   <pre>
--   split (startsWithOneOf ['A'..'Z']) "ACamelCaseIdentifier" == ["A","Camel","Case","Identifier"]
--   </pre>
startsWithOneOf :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all start with the
--   given subsequence (except possibly the first). Equivalent to
--   <tt><a>dropInitBlank</a> . <a>keepDelimsL</a> . <a>onSublist</a></tt>.
--   For example:
--   
--   <pre>
--   split (startsWith "app") "applyapplicativeapplaudapproachapple" == ["apply","applicative","applaud","approach","apple"]
--   </pre>
startsWith :: Eq a => [a] -> Splitter a

-- | Drop all blank chunks from the output, and condense consecutive
--   delimiters into one. Equivalent to <tt><a>dropInitBlank</a> .
--   <a>dropFinalBlank</a> . <a>condense</a></tt>. For example:
--   
--   <pre>
--   split (oneOf ":") "::b:::a" == ["",":","",":","b",":","",":","",":","a"]
--   split (dropBlanks $ oneOf ":") "::b:::a" == ["::","b",":::","a"]
--   </pre>
dropBlanks :: Splitter a -> Splitter a

-- | Don't generate blank chunks between consecutive delimiters. For
--   example:
--   
--   <pre>
--   split (oneOf ":") "::b:::a" == ["",":","",":","b",":","",":","",":","a"]
--   split (dropInnerBlanks $ oneOf ":") "::b:::a" == ["", ":",":","b",":",":",":","a"]
--   </pre>
dropInnerBlanks :: Splitter a -> Splitter a

-- | Don't generate a blank chunk if there is a delimiter at the end. For
--   example:
--   
--   <pre>
--   split (oneOf ":") "a:b:" == ["a",":","b",":",""]
--   split (dropFinalBlank $ oneOf ":") "a:b:" == ["a",":","b",":"]
--   </pre>
dropFinalBlank :: Splitter a -> Splitter a

-- | Don't generate a blank chunk if there is a delimiter at the beginning.
--   For example:
--   
--   <pre>
--   split (oneOf ":") ":a:b" == ["",":","a",":","b"]
--   split (dropInitBlank $ oneOf ":") ":a:b" == [":","a",":","b"]
--   </pre>
dropInitBlank :: Splitter a -> Splitter a

-- | Condense multiple consecutive delimiters into one. For example:
--   
--   <pre>
--   split (condense $ oneOf "xyz") "aazbxyzcxd" == ["aa","z","b","xyz","c","x","d"]
--   split (dropDelims $ oneOf "xyz") "aazbxyzcxd" == ["aa","b","","","c","d"]
--   split (condense . dropDelims $ oneOf "xyz") "aazbxyzcxd" == ["aa","b","c","d"]
--   </pre>
condense :: Splitter a -> Splitter a

-- | Keep delimiters in the output by appending them to adjacent chunks.
--   For example:
--   
--   <pre>
--   split (keepDelimsR $ oneOf "xyz") "aazbxyzcxd" == ["aaz","bx","y","z","cx","d"]
--   </pre>
keepDelimsR :: Splitter a -> Splitter a

-- | Keep delimiters in the output by prepending them to adjacent chunks.
--   For example:
--   
--   <pre>
--   split (keepDelimsL $ oneOf "xyz") "aazbxyzcxd" == ["aa","zb","x","y","zc","xd"]
--   </pre>
keepDelimsL :: Splitter a -> Splitter a

-- | Drop delimiters from the output (the default is to keep them). For
--   example,
--   
--   <pre>
--   split (oneOf ":") "a:b:c" == ["a", ":", "b", ":", "c"]
--   split (dropDelims $ oneOf ":") "a:b:c" == ["a", "b", "c"]
--   </pre>
dropDelims :: Splitter a -> Splitter a

-- | A splitting strategy that splits on any elements that satisfy the
--   given predicate. For example:
--   
--   <pre>
--   split (whenElt (&lt;0)) [2,4,-3,6,-9,1] == [[2,4],[-3],[6],[-9],[1]]
--   </pre>
whenElt :: (a -> Bool) -> Splitter a

-- | A splitting strategy that splits on the given list, when it is
--   encountered as an exact subsequence. For example:
--   
--   <pre>
--   split (onSublist "xyz") "aazbxyzcxd" == ["aazb","xyz","cxd"]
--   </pre>
--   
--   Note that splitting on the empty list is a special case, which splits
--   just before every element of the list being split. For example:
--   
--   <pre>
--   split (onSublist "") "abc" == ["","","a","","b","","c"]
--   split (dropDelims . dropBlanks $ onSublist "") "abc" == ["a","b","c"]
--   </pre>
--   
--   However, if you want to break a list into singleton elements like
--   this, you are better off using <tt><a>chunksOf</a> 1</tt>, or better
--   yet, <tt><a>map</a> (:[])</tt>.
onSublist :: Eq a => [a] -> Splitter a

-- | Split a list according to the given splitting strategy. This is how to
--   "run" a <a>Splitter</a> that has been built using the other
--   combinators.
split :: Splitter a -> [a] -> [[a]]

-- | The default splitting strategy: keep delimiters in the output as
--   separate chunks, don't condense multiple consecutive delimiters into
--   one, keep initial and final blank chunks. Default delimiter is the
--   constantly false predicate.
--   
--   Note that <a>defaultSplitter</a> should normally not be used; use
--   <a>oneOf</a>, <a>onSublist</a>, or <a>whenElt</a> instead, which are
--   the same as the <a>defaultSplitter</a> with just the delimiter
--   overridden.
--   
--   The <a>defaultSplitter</a> strategy with any delimiter gives a
--   maximally information-preserving splitting strategy, in the sense that
--   (a) taking the <a>concat</a> of the output yields the original list,
--   and (b) given only the output list, we can reconstruct a
--   <a>Splitter</a> which would produce the same output list again given
--   the original input list. This default strategy can be overridden to
--   allow discarding various sorts of information.
defaultSplitter :: Splitter a

-- | A splitting strategy.
data Splitter a

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text that is known
--   to be valid.
--   
--   If the input contains any invalid UTF-8 data, an exception will be
--   thrown that cannot be caught in pure code. For more control over the
--   handling of invalid data, use <a>decodeUtf8'</a> or
--   <a>decodeUtf8With</a>.
decodeUtf8 :: ByteString -> Text
readsTime :: ParseTime t => TimeLocale -> String -> ReadS t
readTime :: ParseTime t => TimeLocale -> String -> String -> t
parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readPTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadP t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readSTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadS t

-- | Parse a time value given a format string. Fails if the input could not
--   be parsed using the given format. See <a>parseTimeM</a> for details.
parseTimeOrError :: ParseTime t => Bool -> TimeLocale -> String -> String -> t

-- | Parses a time value given a format string. Supports the same %-codes
--   as <tt>formatTime</tt>, including <tt>%-</tt>, <tt>%_</tt> and
--   <tt>%0</tt> modifiers, however padding widths are not supported. Case
--   is not significant in the input string. Some variations in the input
--   are accepted:
--   
--   <ul>
--   <li><i><tt>%z</tt></i> accepts any of <tt>±HHMM</tt> or
--   <tt>±HH:MM</tt>.</li>
--   <li><i><tt>%Z</tt></i> accepts any string of letters, or any of the
--   formats accepted by <tt>%z</tt>.</li>
--   <li><i><tt>%0Y</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0G</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0C</tt></i> accepts exactly two digits.</li>
--   <li><i><tt>%0f</tt></i> accepts exactly two digits.</li>
--   </ul>
--   
--   For example, to parse a date in YYYY-MM-DD format, while allowing the
--   month and date to have optional leading zeros (notice the <tt>-</tt>
--   modifier used for <tt>%m</tt> and <tt>%d</tt>):
--   
--   <pre>
--   Prelude Data.Time&gt; parseTimeM True defaultTimeLocale "%Y-%-m-%-d" "2010-3-04" :: Maybe Day
--   Just 2010-03-04
--   </pre>
parseTimeM :: (MonadFail m, ParseTime t) => Bool -> TimeLocale -> String -> String -> m t

utcToLocalZonedTime :: UTCTime -> IO ZonedTime
getZonedTime :: IO ZonedTime
utcToZonedTime :: TimeZone -> UTCTime -> ZonedTime

-- | Substitute various time-related information for each %-code in the
--   string, as per <a>formatCharacter</a>.
--   
--   The general form is
--   <tt>%&lt;modifier&gt;&lt;width&gt;&lt;alternate&gt;&lt;specifier&gt;</tt>,
--   where <tt>&lt;modifier&gt;</tt>, <tt>&lt;width&gt;</tt>, and
--   <tt>&lt;alternate&gt;</tt> are optional.
--   
--   <h2><tt>&lt;modifier&gt;</tt></h2>
--   
--   glibc-style modifiers can be used before the specifier (here marked as
--   <tt>z</tt>):
--   
--   <ul>
--   <li><i><tt>%-z</tt></i> no padding</li>
--   <li><i><tt>%_z</tt></i> pad with spaces</li>
--   <li><i><tt>%0z</tt></i> pad with zeros</li>
--   <li><i><tt>%^z</tt></i> convert to upper case</li>
--   <li><i><tt>%#z</tt></i> convert to lower case (consistently, unlike
--   glibc)</li>
--   </ul>
--   
--   <h2><tt>&lt;width&gt;</tt></h2>
--   
--   Width digits can also be used after any modifiers and before the
--   specifier (here marked as <tt>z</tt>), for example:
--   
--   <ul>
--   <li><i><tt>%4z</tt></i> pad to 4 characters (with default padding
--   character)</li>
--   <li><i><tt>%_12z</tt></i> pad with spaces to 12 characters</li>
--   </ul>
--   
--   <h2><tt>&lt;alternate&gt;</tt></h2>
--   
--   An optional <tt>E</tt> character indicates an alternate formatting.
--   Currently this only affects <tt>%Z</tt> and <tt>%z</tt>.
--   
--   <ul>
--   <li><i><tt>%Ez</tt></i> alternate formatting</li>
--   </ul>
--   
--   <h2><tt>&lt;specifier&gt;</tt></h2>
--   
--   For all types (note these three are done by <a>formatTime</a>, not by
--   <a>formatCharacter</a>):
--   
--   <ul>
--   <li><i><tt>%%</tt></i> <tt>%</tt></li>
--   <li><i><tt>%t</tt></i> tab</li>
--   <li><i><tt>%n</tt></i> newline</li>
--   </ul>
--   
--   <h3><tt>TimeZone</tt></h3>
--   
--   For <tt>TimeZone</tt> (and <tt>ZonedTime</tt> and <tt>UTCTime</tt>):
--   
--   <ul>
--   <li><i><tt>%z</tt></i> timezone offset in the format
--   <tt>±HHMM</tt></li>
--   <li><i><tt>%Ez</tt></i> timezone offset in the format
--   <tt>±HH:MM</tt></li>
--   <li><i><tt>%Z</tt></i> timezone name (or else offset in the format
--   <tt>±HHMM</tt>)</li>
--   <li><i><tt>%EZ</tt></i> timezone name (or else offset in the format
--   <tt>±HH:MM</tt>)</li>
--   </ul>
--   
--   <h3><tt>LocalTime</tt></h3>
--   
--   For <tt>LocalTime</tt> (and <tt>ZonedTime</tt> and <tt>UTCTime</tt>
--   and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%c</tt></i> as <a>dateTimeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%a %b %e %H:%M:%S %Z %Y</tt>)</li>
--   </ul>
--   
--   <h3><tt>TimeOfDay</tt></h3>
--   
--   For <tt>TimeOfDay</tt> (and <tt>LocalTime</tt> and <tt>ZonedTime</tt>
--   and <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%R</tt></i> same as <tt>%H:%M</tt></li>
--   <li><i><tt>%T</tt></i> same as <tt>%H:%M:%S</tt></li>
--   <li><i><tt>%X</tt></i> as <a>timeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%H:%M:%S</tt>)</li>
--   <li><i><tt>%r</tt></i> as <a>time12Fmt</a> <tt>locale</tt> (e.g.
--   <tt>%I:%M:%S %p</tt>)</li>
--   <li><i><tt>%P</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), converted to lowercase, <tt>am</tt>,
--   <tt>pm</tt></li>
--   <li><i><tt>%p</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), <tt>AM</tt>, <tt>PM</tt></li>
--   <li><i><tt>%H</tt></i> hour of day (24-hour), 0-padded to two chars,
--   <tt>00</tt> - <tt>23</tt></li>
--   <li><i><tt>%k</tt></i> hour of day (24-hour), space-padded to two
--   chars, <tt> 0</tt> - <tt>23</tt></li>
--   <li><i><tt>%I</tt></i> hour of day-half (12-hour), 0-padded to two
--   chars, <tt>01</tt> - <tt>12</tt></li>
--   <li><i><tt>%l</tt></i> hour of day-half (12-hour), space-padded to two
--   chars, <tt> 1</tt> - <tt>12</tt></li>
--   <li><i><tt>%M</tt></i> minute of hour, 0-padded to two chars,
--   <tt>00</tt> - <tt>59</tt></li>
--   <li><i><tt>%S</tt></i> second of minute (without decimal part),
--   0-padded to two chars, <tt>00</tt> - <tt>60</tt></li>
--   <li><i><tt>%q</tt></i> picosecond of second, 0-padded to twelve chars,
--   <tt>000000000000</tt> - <tt>999999999999</tt>.</li>
--   <li><i><tt>%Q</tt></i> decimal point and fraction of second, up to 12
--   second decimals, without trailing zeros. For a whole number of
--   seconds, <tt>%Q</tt> omits the decimal point unless padding is
--   specified.</li>
--   </ul>
--   
--   <h3><tt>UTCTime</tt> and <tt>ZonedTime</tt></h3>
--   
--   For <tt>UTCTime</tt> and <tt>ZonedTime</tt>:
--   
--   <ul>
--   <li><i><tt>%s</tt></i> number of whole seconds since the Unix epoch.
--   For times before the Unix epoch, this is a negative number. Note that
--   in <tt>%s.%q</tt> and <tt>%s%Q</tt> the decimals are positive, not
--   negative. For example, 0.9 seconds before the Unix epoch is formatted
--   as <tt>-1.1</tt> with <tt>%s%Q</tt>.</li>
--   </ul>
--   
--   <h3><tt>DayOfWeek</tt></h3>
--   
--   For <tt>DayOfWeek</tt> (and <tt>Day</tt> and <tt>LocalTime</tt> and
--   <tt>ZonedTime</tt> and <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%u</tt></i> day of week number for Week Date format,
--   <tt>1</tt> (= Monday) - <tt>7</tt> (= Sunday)</li>
--   <li><i><tt>%w</tt></i> day of week number, <tt>0</tt> (= Sunday) -
--   <tt>6</tt> (= Saturday)</li>
--   <li><i><tt>%a</tt></i> day of week, short form (<a>snd</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sun</tt> - <tt>Sat</tt></li>
--   <li><i><tt>%A</tt></i> day of week, long form (<a>fst</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sunday</tt> -
--   <tt>Saturday</tt></li>
--   </ul>
--   
--   <h3><tt>Day</tt></h3>
--   
--   For <tt>Day</tt> (and <tt>LocalTime</tt> and <tt>ZonedTime</tt> and
--   <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%D</tt></i> same as <tt>%m/%d/%y</tt></li>
--   <li><i><tt>%F</tt></i> same as <tt>%Y-%m-%d</tt></li>
--   <li><i><tt>%x</tt></i> as <a>dateFmt</a> <tt>locale</tt> (e.g.
--   <tt>%m/%d/%y</tt>)</li>
--   <li><i><tt>%Y</tt></i> year, no padding. Note <tt>%0Y</tt> and
--   <tt>%_Y</tt> pad to four chars</li>
--   <li><i><tt>%y</tt></i> year of century, 0-padded to two chars,
--   <tt>00</tt> - <tt>99</tt></li>
--   <li><i><tt>%C</tt></i> century, no padding. Note <tt>%0C</tt> and
--   <tt>%_C</tt> pad to two chars</li>
--   <li><i><tt>%B</tt></i> month name, long form (<a>fst</a> from
--   <a>months</a> <tt>locale</tt>), <tt>January</tt> -
--   <tt>December</tt></li>
--   <li><i><tt>%b</tt>, <tt>%h</tt></i> month name, short form (<a>snd</a>
--   from <a>months</a> <tt>locale</tt>), <tt>Jan</tt> - <tt>Dec</tt></li>
--   <li><i><tt>%m</tt></i> month of year, 0-padded to two chars,
--   <tt>01</tt> - <tt>12</tt></li>
--   <li><i><tt>%d</tt></i> day of month, 0-padded to two chars,
--   <tt>01</tt> - <tt>31</tt></li>
--   <li><i><tt>%e</tt></i> day of month, space-padded to two chars, <tt>
--   1</tt> - <tt>31</tt></li>
--   <li><i><tt>%j</tt></i> day of year, 0-padded to three chars,
--   <tt>001</tt> - <tt>366</tt></li>
--   <li><i><tt>%f</tt></i> century for Week Date format, no padding. Note
--   <tt>%0f</tt> and <tt>%_f</tt> pad to two chars</li>
--   <li><i><tt>%V</tt></i> week of year for Week Date format, 0-padded to
--   two chars, <tt>01</tt> - <tt>53</tt></li>
--   <li><i><tt>%U</tt></i> week of year where weeks start on Sunday (as
--   <tt>sundayStartWeek</tt>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   <li><i><tt>%W</tt></i> week of year where weeks start on Monday (as
--   <tt>mondayStartWeek</tt>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   </ul>
--   
--   <h2>Duration types</h2>
--   
--   The specifiers for <tt>DiffTime</tt>, <tt>NominalDiffTime</tt>,
--   <tt>CalendarDiffDays</tt>, and <tt>CalendarDiffTime</tt> are
--   semantically separate from the other types. Specifiers on negative
--   time differences will generally be negative (think <a>rem</a> rather
--   than <a>mod</a>).
--   
--   <h3><tt>NominalDiffTime</tt> and <tt>DiffTime</tt></h3>
--   
--   Note that a "minute" of <tt>DiffTime</tt> is simply 60 SI seconds,
--   rather than a minute of civil time. Use <tt>NominalDiffTime</tt> to
--   work with civil time, ignoring any leap seconds.
--   
--   For <tt>NominalDiffTime</tt> and <tt>DiffTime</tt>:
--   
--   <ul>
--   <li><i><tt>%w</tt></i> total whole weeks</li>
--   <li><i><tt>%d</tt></i> total whole days</li>
--   <li><i><tt>%D</tt></i> whole days of week</li>
--   <li><i><tt>%h</tt></i> total whole hours</li>
--   <li><i><tt>%H</tt></i> whole hours of day</li>
--   <li><i><tt>%m</tt></i> total whole minutes</li>
--   <li><i><tt>%M</tt></i> whole minutes of hour</li>
--   <li><i><tt>%s</tt></i> total whole seconds</li>
--   <li><i><tt>%Es</tt></i> total seconds, with decimal point and up to
--   &lt;width&gt; (default 12) decimal places, without trailing zeros. For
--   a whole number of seconds, <tt>%Es</tt> omits the decimal point unless
--   padding is specified.</li>
--   <li><i><tt>%0Es</tt></i> total seconds, with decimal point and
--   &lt;width&gt; (default 12) decimal places.</li>
--   <li><i><tt>%S</tt></i> whole seconds of minute</li>
--   <li><i><tt>%ES</tt></i> seconds of minute, with decimal point and up
--   to &lt;width&gt; (default 12) decimal places, without trailing zeros.
--   For a whole number of seconds, <tt>%ES</tt> omits the decimal point
--   unless padding is specified.</li>
--   <li><i><tt>%0ES</tt></i> seconds of minute as two digits, with decimal
--   point and &lt;width&gt; (default 12) decimal places.</li>
--   </ul>
--   
--   <h3><tt>CalendarDiffDays</tt></h3>
--   
--   For <tt>CalendarDiffDays</tt> (and <tt>CalendarDiffTime</tt>):
--   
--   <ul>
--   <li><i><tt>%y</tt></i> total years</li>
--   <li><i><tt>%b</tt></i> total months</li>
--   <li><i><tt>%B</tt></i> months of year</li>
--   <li><i><tt>%w</tt></i> total weeks, not including months</li>
--   <li><i><tt>%d</tt></i> total days, not including months</li>
--   <li><i><tt>%D</tt></i> days of week</li>
--   </ul>
--   
--   <h3><tt>CalendarDiffTime</tt></h3>
--   
--   For <tt>CalendarDiffTime</tt>:
--   
--   <ul>
--   <li><i><tt>%h</tt></i> total hours, not including months</li>
--   <li><i><tt>%H</tt></i> hours of day</li>
--   <li><i><tt>%m</tt></i> total minutes, not including months</li>
--   <li><i><tt>%M</tt></i> minutes of hour</li>
--   <li><i><tt>%s</tt></i> total whole seconds, not including months</li>
--   <li><i><tt>%Es</tt></i> total seconds, not including months, with
--   decimal point and up to &lt;width&gt; (default 12) decimal places,
--   without trailing zeros. For a whole number of seconds, <tt>%Es</tt>
--   omits the decimal point unless padding is specified.</li>
--   <li><i><tt>%0Es</tt></i> total seconds, not including months, with
--   decimal point and &lt;width&gt; (default 12) decimal places.</li>
--   <li><i><tt>%S</tt></i> whole seconds of minute</li>
--   <li><i><tt>%ES</tt></i> seconds of minute, with decimal point and up
--   to &lt;width&gt; (default 12) decimal places, without trailing zeros.
--   For a whole number of seconds, <tt>%ES</tt> omits the decimal point
--   unless padding is specified.</li>
--   <li><i><tt>%0ES</tt></i> seconds of minute as two digits, with decimal
--   point and &lt;width&gt; (default 12) decimal places.</li>
--   </ul>
formatTime :: FormatTime t => TimeLocale -> String -> t -> String
class FormatTime t

-- | The class of types which can be parsed given a UNIX-style time format
--   string.
class ParseTime t

-- | Format string according to <a>RFC822</a>.
rfc822DateFormat :: String

-- | Construct format string according to <a>ISO-8601</a>.
--   
--   The <tt>Maybe String</tt> argument allows to supply an optional time
--   specification. E.g.:
--   
--   <pre>
--   <a>iso8601DateFormat</a> Nothing            == "%Y-%m-%d"           -- i.e. <tt><i>YYYY-MM-DD</i></tt>
--   <a>iso8601DateFormat</a> (Just "%H:%M:%S")  == "%Y-%m-%dT%H:%M:%S"  -- i.e. <tt><i>YYYY-MM-DD</i>T<i>HH:MM:SS</i></tt>
--   </pre>
iso8601DateFormat :: Maybe String -> String

-- | Locale representing American usage.
--   
--   <a>knownTimeZones</a> contains only the ten time-zones mentioned in
--   RFC 822 sec. 5: "UT", "GMT", "EST", "EDT", "CST", "CDT", "MST", "MDT",
--   "PST", "PDT". Note that the parsing functions will regardless parse
--   "UTC", single-letter military time-zones, and +HHMM format.
defaultTimeLocale :: TimeLocale
data TimeLocale
TimeLocale :: [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> [TimeZone] -> TimeLocale

-- | full and abbreviated week days, starting with Sunday
[wDays] :: TimeLocale -> [(String, String)]

-- | full and abbreviated months
[months] :: TimeLocale -> [(String, String)]

-- | AM/PM symbols
[amPm] :: TimeLocale -> (String, String)

-- | formatting strings
[dateTimeFmt] :: TimeLocale -> String

-- | formatting strings
[dateFmt] :: TimeLocale -> String

-- | formatting strings
[timeFmt] :: TimeLocale -> String

-- | formatting strings
[time12Fmt] :: TimeLocale -> String

-- | time zones known by name
[knownTimeZones] :: TimeLocale -> [TimeZone]

-- | Get the UT1 time of a local time on a particular meridian (in degrees,
--   positive is East).
localTimeToUT1 :: Rational -> LocalTime -> UniversalTime

-- | Get the local time of a UT1 time on a particular meridian (in degrees,
--   positive is East).
ut1ToLocalTime :: Rational -> UniversalTime -> LocalTime

-- | Get the UTC time of a local time in a time zone.
localTimeToUTC :: TimeZone -> LocalTime -> UTCTime

-- | Get the local time of a UTC time in a time zone.
utcToLocalTime :: TimeZone -> UTCTime -> LocalTime

-- | diffLocalTime a b = a - b
diffLocalTime :: LocalTime -> LocalTime -> NominalDiffTime

-- | addLocalTime a b = a + b
addLocalTime :: NominalDiffTime -> LocalTime -> LocalTime

-- | A simple day and time aggregate, where the day is of the specified
--   parameter, and the time is a TimeOfDay. Conversion of this (as local
--   civil time) to UTC depends on the time zone. Conversion of this (as
--   local mean time) to UT1 depends on the longitude.
data LocalTime
LocalTime :: Day -> TimeOfDay -> LocalTime
[localDay] :: LocalTime -> Day
[localTimeOfDay] :: LocalTime -> TimeOfDay

-- | Get the fraction of a day since midnight given a time of day.
timeOfDayToDayFraction :: TimeOfDay -> Rational

-- | Get the time of day given the fraction of a day since midnight.
dayFractionToTimeOfDay :: Rational -> TimeOfDay

-- | Get the time since midnight for a given time of day.
timeOfDayToTime :: TimeOfDay -> DiffTime

-- | Get the time of day given a time since midnight. Time more than 24h
--   will be converted to leap-seconds.
timeToTimeOfDay :: DiffTime -> TimeOfDay

-- | Convert a time of day in some timezone to a time of day in UTC,
--   together with a day adjustment.
localToUTCTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)

-- | Convert a time of day in UTC to a time of day in some timezone,
--   together with a day adjustment.
utcToLocalTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)

-- | Convert a count of days and a time of day since midnight into a period
--   of time.
daysAndTimeOfDayToTime :: Integer -> TimeOfDay -> NominalDiffTime

-- | Convert a period of time into a count of days and a time of day since
--   midnight. The time of day will never have a leap second.
timeToDaysAndTimeOfDay :: NominalDiffTime -> (Integer, TimeOfDay)
makeTimeOfDayValid :: Int -> Int -> Pico -> Maybe TimeOfDay

-- | Hour twelve
midday :: TimeOfDay

-- | Hour zero
midnight :: TimeOfDay

-- | Time of day as represented in hour, minute and second (with
--   picoseconds), typically used to express local time of day.
data TimeOfDay
TimeOfDay :: Int -> Int -> Pico -> TimeOfDay

-- | range 0 - 23
[todHour] :: TimeOfDay -> Int

-- | range 0 - 59
[todMin] :: TimeOfDay -> Int

-- | Note that 0 &lt;= <a>todSec</a> &lt; 61, accomodating leap seconds.
--   Any local minute may have a leap second, since leap seconds happen in
--   all zones simultaneously
[todSec] :: TimeOfDay -> Pico

-- | Get the current time-zone.
getCurrentTimeZone :: IO TimeZone

-- | Get the local time-zone for a given time (varying as per summertime
--   adjustments).
getTimeZone :: UTCTime -> IO TimeZone

-- | The UTC time zone.
utc :: TimeZone

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime).
timeZoneOffsetString :: TimeZone -> String

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime), with arbitrary padding.
timeZoneOffsetString' :: Maybe Char -> TimeZone -> String

-- | Create a nameless non-summer timezone for this number of hours.
hoursToTimeZone :: Int -> TimeZone

-- | Create a nameless non-summer timezone for this number of minutes.
minutesToTimeZone :: Int -> TimeZone

-- | A TimeZone is a whole number of minutes offset from UTC, together with
--   a name and a "just for summer" flag.
data TimeZone
TimeZone :: Int -> Bool -> String -> TimeZone

-- | The number of minutes offset from UTC. Positive means local time will
--   be later in the day than UTC.
[timeZoneMinutes] :: TimeZone -> Int

-- | Is this time zone just persisting for the summer?
[timeZoneSummerOnly] :: TimeZone -> Bool

-- | The name of the zone, typically a three- or four-letter acronym.
[timeZoneName] :: TimeZone -> String

-- | Scale by a factor. Note that <tt>scaleCalendarDiffTime (-1)</tt> will
--   not perfectly invert a duration, due to variable month lengths.
scaleCalendarDiffTime :: Integer -> CalendarDiffTime -> CalendarDiffTime
calendarTimeTime :: NominalDiffTime -> CalendarDiffTime
calendarTimeDays :: CalendarDiffDays -> CalendarDiffTime
data CalendarDiffTime
CalendarDiffTime :: Integer -> NominalDiffTime -> CalendarDiffTime
[ctMonths] :: CalendarDiffTime -> Integer
[ctTime] :: CalendarDiffTime -> NominalDiffTime

-- | diffUTCTime a b = a - b
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime

-- | addUTCTime a b = a + b
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime

-- | Get the current <a>UTCTime</a> from the system clock.
getCurrentTime :: IO UTCTime

-- | The Modified Julian Date is the day with the fraction of the day,
--   measured from UT midnight. It's used to represent UT1, which is time
--   as measured by the earth's rotation, adjusted for various wobbles.
newtype UniversalTime
ModJulianDate :: Rational -> UniversalTime
[getModJulianDate] :: UniversalTime -> Rational

-- | The resolution of <a>getSystemTime</a>, <tt>getCurrentTime</tt>,
--   <tt>getPOSIXTime</tt>
getTime_resolution :: DiffTime

-- | One day in <a>NominalDiffTime</a>.
nominalDay :: NominalDiffTime

-- | Get the seconds in a <a>NominalDiffTime</a>.
nominalDiffTimeToSeconds :: NominalDiffTime -> Pico

-- | Create a <a>NominalDiffTime</a> from a number of seconds.
secondsToNominalDiffTime :: Pico -> NominalDiffTime

-- | Get the number of picoseconds in a <a>DiffTime</a>.
diffTimeToPicoseconds :: DiffTime -> Integer

-- | Create a <a>DiffTime</a> from a number of picoseconds.
picosecondsToDiffTime :: Integer -> DiffTime

-- | Create a <a>DiffTime</a> which represents an integral number of
--   seconds.
secondsToDiffTime :: Integer -> DiffTime
dayOfWeek :: Day -> DayOfWeek
data DayOfWeek
Monday :: DayOfWeek
Tuesday :: DayOfWeek
Wednesday :: DayOfWeek
Thursday :: DayOfWeek
Friday :: DayOfWeek
Saturday :: DayOfWeek
Sunday :: DayOfWeek

-- | Calendrical difference, with as many whole months as possible. Same as
--   <a>diffGregorianDurationClip</a> for positive durations.
diffGregorianDurationRollOver :: Day -> Day -> CalendarDiffDays

-- | Calendrical difference, with as many whole months as possible
diffGregorianDurationClip :: Day -> Day -> CalendarDiffDays

-- | Add months (rolling over to next month), then add days
addGregorianDurationRollOver :: CalendarDiffDays -> Day -> Day

-- | Add months (clipped to last day), then add days
addGregorianDurationClip :: CalendarDiffDays -> Day -> Day

-- | Add years, matching month and day, with Feb 29th rolled over to Mar
--   1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.
addGregorianYearsRollOver :: Integer -> Day -> Day

-- | Add years, matching month and day, with Feb 29th clipped to Feb 28th
--   if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.
addGregorianYearsClip :: Integer -> Day -> Day

-- | Add months, with days past the last day of the month rolling over to
--   the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.
addGregorianMonthsRollOver :: Integer -> Day -> Day

-- | Add months, with days past the last day of the month clipped to the
--   last day. For instance, 2005-01-30 + 1 month = 2005-02-28.
addGregorianMonthsClip :: Integer -> Day -> Day

-- | The number of days in a given month according to the proleptic
--   Gregorian calendar. First argument is year, second is month.
gregorianMonthLength :: Integer -> Int -> Int

-- | Show in ISO 8601 format (yyyy-mm-dd)
showGregorian :: Day -> String

-- | Convert from proleptic Gregorian calendar. First argument is year,
--   second month number (1-12), third day (1-31). Invalid values will
--   return Nothing
fromGregorianValid :: Integer -> Int -> Int -> Maybe Day

-- | Convert from proleptic Gregorian calendar. First argument is year,
--   second month number (1-12), third day (1-31). Invalid values will be
--   clipped to the correct range, month first, then day.
fromGregorian :: Integer -> Int -> Int -> Day

-- | Convert to proleptic Gregorian calendar. First element of result is
--   year, second month number (1-12), third day (1-31).
toGregorian :: Day -> (Integer, Int, Int)

-- | Is this year a leap year according to the proleptic Gregorian
--   calendar?
isLeapYear :: Integer -> Bool
diffDays :: Day -> Day -> Integer
addDays :: Integer -> Day -> Day
pattern ModifiedJulianDay :: () => Integer -> Day
toModifiedJulianDay :: Day -> Integer

-- | Scale by a factor. Note that <tt>scaleCalendarDiffDays (-1)</tt> will
--   not perfectly invert a duration, due to variable month lengths.
scaleCalendarDiffDays :: Integer -> CalendarDiffDays -> CalendarDiffDays
calendarYear :: CalendarDiffDays
calendarMonth :: CalendarDiffDays
calendarWeek :: CalendarDiffDays
calendarDay :: CalendarDiffDays
data CalendarDiffDays
CalendarDiffDays :: Integer -> Integer -> CalendarDiffDays
[cdMonths] :: CalendarDiffDays -> Integer
[cdDays] :: CalendarDiffDays -> Integer

-- | Strip trailing and leading whitespace.
strip :: String -> String

-- | Strip trailing newline
stripNewline :: String -> String

-- | Convert an <a>Either</a> into a <a>Maybe</a>, or any
--   <a>Alternative</a> instance, forgetting the error value.
eitherToMaybe :: Alternative m => Either e a -> m a

-- | Convert a <a>Maybe</a> into an <a>Either</a>, or any <a>MonadError</a>
--   instance, by providing an error value in case <a>Nothing</a> was
--   given.
maybeToEither :: MonadError e m => e -> Maybe a -> m a

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
firstJust :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Generalize a <a>Maybe</a> to any <a>Alternative</a>
maybeAlt :: Alternative m => Maybe a -> m a

-- | Like <a>traceShowId</a> but with an extra message
traceShowIdMsg :: Show a => String -> a -> a

-- | Like <a>traceShow</a> but with an extra message
traceShowMsg :: Show a => String -> a -> b -> b
type CharParser = Parsec Void String

-- | Use a stream of tokens <tt>a</tt> as the underlying parser stream.
--   Note that error messages for parser errors are going necessarily to be
--   wonky.
newtype TokStream a
TokStream :: [a] -> TokStream a
[getTokStream] :: TokStream a -> [a]

-- | It's <a>Point</a>, but with a newtype wrapper so we have an <a>Ord</a>
--   that sorts by y first, then x
newtype ScanPoint
SP :: Point -> ScanPoint
[_getSP] :: ScanPoint -> Point
data Dir
North :: Dir
East :: Dir
South :: Dir
West :: Dir

-- | 2D Coordinate
type Point = V2 Int
type Letter = Finite 26

-- | Strict (!!)
(!!!) :: [a] -> Int -> a

-- | Strict drop
drop' :: Int -> [a] -> [a]

-- | Iterate until a <a>Nothing</a> is produced
iterateMaybe :: (a -> Maybe a) -> a -> [a]
(!?) :: [a] -> Int -> Maybe a

-- | Apply function until <a>Nothing</a> is produced, and return last
--   produced value.
loopMaybe :: (a -> Maybe a) -> a -> a

-- | Apply function until a <a>Left</a>.
loopEither :: (a -> Either r a) -> a -> r

-- | Apply monadic function until <a>Nothing</a> is produced, and return
--   last produced value.
loopMaybeM :: Monad m => (a -> m (Maybe a)) -> a -> m a

-- | A tuple of the same item twice
dup :: a -> (a, a)

-- | <a>scanl</a> generalized to all <a>Traversable</a>.
scanlT :: Traversable t => (b -> a -> b) -> b -> t a -> t b

-- | <a>scanr</a> generalized to all <a>Traversable</a>.
scanrT :: Traversable t => (a -> b -> b) -> b -> t a -> t b

-- | Lazily find the first repeated item.
firstRepeated :: Ord a => [a] -> Maybe a

-- | Repeat a function until you get the same result twice.
fixedPoint :: Eq a => (a -> a) -> a -> a

-- | Count the number of items in a container where the predicate is true.
countTrue :: Foldable f => (a -> Bool) -> f a -> Int

-- | Build a frequency map
freqs :: (Foldable f, Ord a) => f a -> Map a Int

-- | each item paired with the list not including that item
select :: [a] -> [(a, [a])]

-- | Look up a count from a frequency map, defaulting to zero if item is
--   not foudn
lookupFreq :: Ord a => a -> Map a Int -> Int

-- | Build a reverse frequency map
revFreq :: (Foldable f, Ord a) => f a -> IntMap (NESet a)

-- | Build a list of <i>descending</i> frequencies. Ties are sorted.
freqList :: (Foldable f, Ord a) => f a -> [(Int, a)]
eitherItem :: Lens' (Either a a) a
getDown :: Down a -> a
splitWord :: Word8 -> (Finite 16, Finite 16)
decimalDigit :: Prism' Char (Finite 10)
hexDigit :: Prism' Char (Finite 16)

-- | Parse a letter into a number 0 to 25. Returns <a>False</a> if
--   lowercase and <a>True</a> if uppercase.
charFinite :: Char -> Maybe (Bool, Finite 26)
digitToIntSafe :: Char -> Maybe Int

-- | Prism for a <a>Char</a> as <tt>(<a>Bool</a>, <a>Finite</a> 26)</tt>,
--   where the <a>Finite</a> is the letter parsed as a number from 0 to 25,
--   and the <a>Bool</a> is lowercase (<a>False</a>) or uppercase
--   (<a>True</a>).
_CharFinite :: Prism' Char (Bool, Finite 26)

-- | Caeser shift, preserving case. If you have an <a>Int</a> or
--   <a>Integer</a>, convert into <a>Finite</a> using <a>modulo</a>.
caeser :: Finite 26 -> Char -> Char

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbations :: (a -> [a]) -> [a] -> [[a]]

-- | Clear out characters not matching a predicate
clearOut :: (Char -> Bool) -> String -> String

-- | Get the key-value pair corresponding to the maximum value in the map
maximumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the maximum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'maximumVal' == 'maximumValBy' 'compare'
--   </pre>
maximumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'minimumVal' == 'minimumValBy' 'compare'
--   </pre>
minimumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map
minimumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Version of <a>maximumValBy</a> for nonempty maps.
maximumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>maximumVal</a> for nonempty maps.
maximumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>minimumValBy</a> for nonempty maps.
minimumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>minimumVal</a> for nonempty maps.
minimumValNE :: Ord b => NEMap a b -> (a, b)
foldMapParChunk :: (NFData m, Monoid m) => Int -> (a -> m) -> [a] -> m
listTup :: [a] -> Maybe (a, a)
_ListTup :: Prism' [a] (a, a)
listTup3 :: [a] -> Maybe (a, a, a)
_ListTup3 :: Prism' [a] (a, a, a)
listTup4 :: [a] -> Maybe (a, a, a, a)
_ListTup4 :: Prism' [a] (a, a, a, a)

-- | Delete a potential value from a <a>Finite</a>.
deleteFinite :: KnownNat n => Finite (n + 1) -> Finite (n + 1) -> Maybe (Finite n)

-- | <a>foldMap</a>, but in parallel.
foldMapPar :: Monoid b => (a -> b) -> [a] -> b

-- | <a>foldMap1</a>, but in parallel.
foldMapPar1 :: Semigroup b => (a -> b) -> NonEmpty a -> b

-- | <a>Fold</a> for computing mean and variance
meanVar :: Fractional a => Fold a (a, a)

-- | Flood fill from a starting set
floodFill :: Ord a => (a -> Set a) -> Set a -> Set a

-- | Flood fill from a starting set, counting the number of steps
floodFillCount :: Ord a => (a -> Set a) -> Set a -> (Int, Set a)

-- | Find the minimum and maximum x and y from a collection of points.
--   
--   Returns <tt><a>V2</a> (V2 xMin yMin) (V2 xMax yMax)</tt>.
boundingBox :: (Foldable1 f, Applicative g, Ord a) => f (g a) -> V2 (g a)

-- | A version of <a>boundingBox</a> that works for normal possibly-empty
--   lists.
boundingBox' :: Foldable f => f Point -> Maybe (V2 Point)
cardinalNeighbs :: Point -> [Point]
cardinalNeighbsSet :: Point -> Set Point
fullNeighbs :: Point -> [Point]
fullNeighbsSet :: Point -> Set Point
memoPoint :: Memo Point
mannDist :: (Foldable f, Num a, Num (f a)) => f a -> f a -> a

-- | Treat as complex number multiplication. useful for rotations
mulPoint :: Point -> Point -> Point
dirPoint :: Dir -> Point

-- | <a>dirPoint</a> but with inverted y axis
dirPoint' :: Dir -> Point
parseDir :: Char -> Maybe Dir

-- | Multiply headings, taking North as straight, East as clockwise turn,
--   West as counter-clockwise turn, and South as reverse.
--   
--   Should be a commutative group; it's essentially complex number
--   multiplication like <a>mulPoint</a>, with North = 1, West = i. The
--   identity is <a>North</a> and the inverse is the opposite direction.
mulDir :: Dir -> Dir -> Dir
parseAsciiMap :: (Char -> Maybe a) -> String -> Map Point a
parseAsciiSet :: (Char -> Bool) -> String -> Set Point
displayAsciiMap :: Char -> Map Point Char -> String

-- | Parse a stream of tokens <tt>s</tt> purely, returning <a>Either</a>
parseTokStream :: Foldable t => Parsec e (TokStream s) a -> t s -> Either (ParseErrorBundle (TokStream s) e) a

-- | Parse a stream of tokens <tt>s</tt> purely
parseTokStream_ :: (Alternative m, Foldable t) => Parsec e (TokStream s) a -> t s -> m a

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad,
--   returning <a>Either</a>
parseTokStreamT :: (Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (Either (ParseErrorBundle (TokStream s) e) a)

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad
parseTokStreamT_ :: (Alternative f, Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (f a)
parseMaybeLenient :: Parsec e s a -> s -> Maybe a
parseOrFail :: (Stream s, ShowErrorComponent e) => Parsec e s a -> s -> a
parseLines :: Parsec e String a -> String -> Maybe [a]

-- | Skip every result until this token matches
nextMatch :: MonadParsec e s m => m a -> m a
toNatural :: Integral a => a -> Maybe Natural

-- | Lattice points for line between points, not including endpoints
lineTo :: Point -> Point -> [Point]

-- | Errors that might happen when running a <a>:~&gt;</a> on some input.
data SolutionError
SEParse :: SolutionError
SESolve :: SolutionError

-- | Wrap an <tt>a <a>:~&gt;</a> b</tt> and hide the type variables so we
--   can put different solutions in a container.
data SomeSolution
[MkSomeSolWH] :: (a :~> b) -> SomeSolution
[MkSomeSolNF] :: (NFData a, NFData b) => (a :~> b) -> SomeSolution

-- | Handy pattern to work with both <a>MkSomeSolWH</a> and
--   <a>MkSomeSolNF</a>. As a constructor, just uses <a>MkSomeSolWH</a>, so
--   might not be desirable.
pattern MkSomeSol :: () => forall a b. () => (a :~> b) -> SomeSolution

-- | Abstracting over the type of a challenge solver to help with cleaner
--   solutions.
--   
--   A <tt>a <a>:~&gt;</a> b</tt> encapsulates something that solves a
--   challenge with input type <tt>a</tt> into a response of type
--   <tt>b</tt>.
--   
--   Consists of a parser, a shower, and a solver. The solver solves a
--   general <tt>a -&gt; <a>Maybe</a> b</tt> function, and the parser and
--   shower are used to handle the boilerplate of parsing and printing the
--   solution.
data a :~> b
MkSol :: (String -> Maybe a) -> ((?dyno :: DynoMap) => a -> Maybe b) -> (b -> String) -> (:~>) a b

-- | parse input into an <tt>a</tt>
[sParse] :: (:~>) a b -> String -> Maybe a

-- | solve an <tt>a</tt> input to a <tt>b</tt> solution
[sSolve] :: (:~>) a b -> (?dyno :: DynoMap) => a -> Maybe b

-- | print out the <tt>b</tt> solution in a pretty way
[sShow] :: (:~>) a b -> b -> String

-- | Check if a <a>SomeSolution</a> is equipped with an <a>NFData</a>
--   instance on the types
ssIsNF :: SomeSolution -> Bool

-- | Construct a <a>:~&gt;</a> from just a normal <tt>String -&gt;
--   String</tt> solver. Does no parsing or special printing treatment.
withSolver' :: (String -> String) -> String :~> String

-- | Construct a <a>:~&gt;</a> from a <tt>String -&gt; <a>Maybe</a>
--   String</tt> solver, which might fail. Does no parsing or special
--   printing treatment.
withSolver :: (String -> Maybe String) -> String :~> String

-- | Run a <a>:~&gt;</a> on some input.
runSolution :: (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>:~&gt;</a> on some input, with a map of dynamic values for
--   testing
runSolutionWith :: Map String Dynamic -> (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input.
runSomeSolution :: SomeSolution -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input, with a map of dynamic values
--   for testing
runSomeSolutionWith :: Map String Dynamic -> SomeSolution -> String -> Either SolutionError String

-- | From a <tt>?dyno</tt> Implicit Params, look up a value at a given key.
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno' @"hello"
--   </pre>
--   
--   This can be used within the body of <a>sSolve</a>, since it will
--   always be called with the implicit parameter.
--   
--   When called on actual puzzle input, result will always be
--   <a>Nothing</a>. But, for some test inputs, there might be supplied
--   values.
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> Maybe a

-- | A version of <a>dyno</a> taking a default value in case the key is not
--   in the map. When called on actual puzzle input, this is always
--   <a>id</a>. However, for some test inputs, there might be supplied
--   values.
--   
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno_' @"hello" 7
--   </pre>
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno_ :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> a -> a


-- | Day 25. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day25


-- | Day 24. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day24


-- | Day 23. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day23


-- | Day 22. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day22


-- | Day 21. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day21


-- | Day 20. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day20


-- | Day 19. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day19


-- | Day 18. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day18


-- | Day 17. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day17


-- | Day 16. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day16


-- | Day 15. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day15


-- | Day 14. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day14


-- | Day 13. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day13


-- | Day 12. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day12


-- | Day 11. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day11


-- | Day 10. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day10


-- | Day 9. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day09


-- | Day 8. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day08


-- | Day 7. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day07


-- | Template Haskell for discovering all named challenges in a given
--   directory.
module AOC.Discover

-- | Meant to be called like:
--   
--   <pre>
--   mkChallengeMap $$(solutionList "src/AOC/Challenge")
--   </pre>
mkChallengeMap :: [(Day, (Part, SomeSolution))] -> ChallengeMap

-- | Template Haskell splice to produce a list of all named solutions in a
--   directory. Expects solutions as function names following the format
--   <tt>dayDDp</tt>, where <tt>DD</tt> is a two-digit zero-added day, and
--   <tt>p</tt> is a lower-case letter corresponding to the part of the
--   challenge.
--   
--   See <a>mkChallengeMap</a> for a description of usage.
solutionList :: FilePath -> Q (TExp [(Day, (Part, SomeSolution))])

-- | A map of days to parts to solutions.
type ChallengeMap = Map Day (Map Part SomeSolution)

-- | A specification for a specific challenge. Should consist of a day and
--   a lowercase character.
data ChallengeSpec
CS :: Day -> Part -> ChallengeSpec
[_csDay] :: ChallengeSpec -> Day
[_csPart] :: ChallengeSpec -> Part

-- | Get a <a>ChallengeSpec</a> from a given reified solution (name).
--   
--   <pre>
--   solSpec 'day02a == CS { _csDay = 1, _csPart = <tt>a</tt> }
--   </pre>
solSpec :: Name -> ChallengeSpec
solSpecStr :: String -> Either (ParseErrorBundle String Void) ChallengeSpec
solSpecStr_ :: String -> ChallengeSpec

-- | Parse a <a>Char</a> into a <a>Part</a>
charPart :: Char -> Maybe Part
challengeName :: Parser ChallengeSpec

-- | Check if a solver identifier is of type <tt>A <a>:~&gt;</a> B</tt>,
--   where <tt>B</tt> is an instance of <a>NFData</a>.
solverNFData :: Name -> Q Bool

-- | Check if a type is an instance of a class, unifying when possible
deepInstance :: Name -> Type -> Q Bool
instance GHC.Classes.Ord AOC.Discover.ChallengeSpec
instance GHC.Classes.Eq AOC.Discover.ChallengeSpec
instance GHC.Show.Show AOC.Discover.ChallengeSpec
instance Data.String.IsString AOC.Discover.ChallengeSpec


-- | Day 6. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day06
day06a :: [[String]] :~> Int
day06b :: [[String]] :~> Int


-- | Day 5. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day05
day05a :: [String] :~> Int
day05b :: [String] :~> Int


-- | Day 4. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day04
day04a :: [String] :~> Int
day04b :: [String] :~> Int
instance GHC.Generics.Generic (AOC.Challenge.Day04.Passport f)
instance GHC.Enum.Enum AOC.Challenge.Day04.Eye
instance GHC.Classes.Ord AOC.Challenge.Day04.Eye
instance GHC.Classes.Eq AOC.Challenge.Day04.Eye
instance GHC.Read.Read AOC.Challenge.Day04.Eye
instance GHC.Show.Show AOC.Challenge.Day04.Eye
instance GHC.Classes.Ord AOC.Challenge.Day04.Height
instance GHC.Classes.Eq AOC.Challenge.Day04.Height
instance GHC.Read.Read AOC.Challenge.Day04.Height
instance GHC.Show.Show AOC.Challenge.Day04.Height
instance Barbies.Internal.ConstraintsB.AllBF GHC.Show.Show f AOC.Challenge.Day04.Passport => GHC.Show.Show (AOC.Challenge.Day04.Passport f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Base.Semigroup f AOC.Challenge.Day04.Passport => GHC.Base.Semigroup (AOC.Challenge.Day04.Passport f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Base.Monoid f AOC.Challenge.Day04.Passport => GHC.Base.Monoid (AOC.Challenge.Day04.Passport f)
instance Barbies.Internal.FunctorB.FunctorB AOC.Challenge.Day04.Passport
instance Barbies.Internal.ApplicativeB.ApplicativeB AOC.Challenge.Day04.Passport
instance Barbies.Internal.TraversableB.TraversableB AOC.Challenge.Day04.Passport
instance Barbies.Internal.ConstraintsB.ConstraintsB AOC.Challenge.Day04.Passport


module AOC.Challenge.Day03
day03a :: String :~> Int
day03b :: String :~> Int
validCoord :: Finite 31 -> Int -> Coord -> Bool


-- | Day 2. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day02
day02a :: [Policy] :~> Int
day02b :: [Policy] :~> Int
instance GHC.Generics.Generic AOC.Challenge.Day02.Policy
instance GHC.Classes.Ord AOC.Challenge.Day02.Policy
instance GHC.Classes.Eq AOC.Challenge.Day02.Policy
instance GHC.Show.Show AOC.Challenge.Day02.Policy
instance Control.DeepSeq.NFData AOC.Challenge.Day02.Policy


-- | Day 1. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day01
day01a :: [Int] :~> Int
day01b :: [Int] :~> Int

-- | Given a goal sum and a set of numbers to pick from, finds the
--   <tt>n</tt> numbers in the set that add to the goal sum. The number of
--   items desired is inferred from the desired length of the return type.
knapsack :: forall n. SNatI n => Int -> IntSet -> Maybe (Vec ('S n) Int)


-- | Gather together all challenges and collect them into a single map.
module AOC.Challenge

-- | A map of days to parts to solutions.
type ChallengeMap = Map Day (Map Part SomeSolution)

-- | A specification for a specific challenge. Should consist of a day and
--   a lowercase character.
data ChallengeSpec
CS :: Day -> Part -> ChallengeSpec
[_csDay] :: ChallengeSpec -> Day
[_csPart] :: ChallengeSpec -> Part

-- | A given part of a problem. All Advent of Code challenges are
--   two-parts.
--   
--   You can usually get <a>Part1</a> (if it is already released) with a
--   nonsense session key, but <a>Part2</a> always requires a valid session
--   key.
data Part
Part1 :: Part
Part2 :: Part

-- | A map of all challenges.
challengeMap :: ChallengeMap

-- | Lookup up a solution from a <a>ChallengeMap</a>
lookupSolution :: ChallengeSpec -> Map Day (Map Part a) -> Maybe a

-- | Describes the day: a number between 1 and 25 inclusive.
--   
--   Represented by a <a>Finite</a> ranging from 0 to 24 inclusive; you
--   should probably make one using the smart constructor <a>mkDay</a>.
newtype Day
Day :: Finite 25 -> Day
[dayFinite] :: Day -> Finite 25

-- | Convert a <tt><a>Finite</a> 25</tt> day into a day integer (1 - 25).
--   Inverse of <a>mkDay</a>.
dayInt :: Day -> Integer

-- | Construct a <a>Day</a> from a day integer (1 - 25). If input is out of
--   range, <a>Nothing</a> is returned. See <a>mkDay_</a> for an unsafe
--   version useful for literals.
--   
--   Inverse of <a>dayInt</a>.
mkDay :: Integer -> Maybe Day

-- | Construct a <tt><a>Finite</a> 25</tt> (the type of a Day) from a day
--   integer (1 - 25). Is undefined if input is out of range. Can be useful
--   for compile-time literals, like <tt><a>mkDay_</a> 4</tt>
--   
--   Inverse of <a>dayInt</a>.
mkDay_ :: Integer -> Day

-- | Get a <a>ChallengeSpec</a> from a given reified solution (name).
--   
--   <pre>
--   solSpec 'day02a == CS { _csDay = 1, _csPart = <tt>a</tt> }
--   </pre>
solSpec :: Name -> ChallengeSpec

-- | Parse a <a>Char</a> into a <a>Part</a>
charPart :: Char -> Maybe Part


-- | Loading challenge data and prompts.
module AOC.Run.Load

-- | A record of paths corresponding to a specific challenge.
data ChallengePaths
CP :: !FilePath -> !FilePath -> !FilePath -> !FilePath -> !FilePath -> ChallengePaths
[_cpPrompt] :: ChallengePaths -> !FilePath
[_cpInput] :: ChallengePaths -> !FilePath
[_cpAnswer] :: ChallengePaths -> !FilePath
[_cpTests] :: ChallengePaths -> !FilePath
[_cpLog] :: ChallengePaths -> !FilePath

-- | Generate a <a>ChallengePaths</a> from a specification of a challenge.
challengePaths :: Integer -> ChallengeSpec -> ChallengePaths

-- | A record of data (test inputs, answers) corresponding to a specific
--   challenge.
data ChallengeData
CD :: !Either [String] Text -> !Either [String] String -> !Maybe String -> ![(String, TestMeta)] -> ChallengeData
[_cdPrompt] :: ChallengeData -> !Either [String] Text
[_cdInput] :: ChallengeData -> !Either [String] String
[_cdAnswer] :: ChallengeData -> !Maybe String
[_cdTests] :: ChallengeData -> ![(String, TestMeta)]

-- | Load data associated with a challenge from a given specification. Will
--   fetch answers online and cache if required (and if giten a session
--   token).
challengeData :: Maybe String -> Integer -> ChallengeSpec -> IO ChallengeData

-- | Describes the day: a number between 1 and 25 inclusive.
--   
--   Represented by a <a>Finite</a> ranging from 0 to 24 inclusive; you
--   should probably make one using the smart constructor <a>mkDay</a>.
newtype Day
Day :: Finite 25 -> Day
[dayFinite] :: Day -> Finite 25

-- | Run a countdown on the console.
countdownConsole :: MonadIO m => Integer -> Day -> m a -> m a

-- | Get time until release of a given challenge.
timeToRelease :: Integer -> Day -> IO NominalDiffTime

-- | Pretty-print a <a>NominalDiffTime</a>
showNominalDiffTime :: NominalDiffTime -> String

-- | Parse a <a>Char</a> into a <a>Part</a>
charPart :: Char -> Maybe Part
showAoCError :: AoCError -> [String]
htmlToMarkdown :: Bool -> Text -> Either [String] Text

-- | Construct a <a>Day</a> from a day integer (1 - 25). If input is out of
--   range, <a>Nothing</a> is returned. See <a>mkDay_</a> for an unsafe
--   version useful for literals.
--   
--   Inverse of <a>dayInt</a>.
mkDay :: Integer -> Maybe Day

-- | Construct a <tt><a>Finite</a> 25</tt> (the type of a Day) from a day
--   integer (1 - 25). Is undefined if input is out of range. Can be useful
--   for compile-time literals, like <tt><a>mkDay_</a> 4</tt>
--   
--   Inverse of <a>dayInt</a>.
mkDay_ :: Integer -> Day

-- | Convert a <tt><a>Finite</a> 25</tt> day into a day integer (1 - 25).
--   Inverse of <a>mkDay</a>.
dayInt :: Day -> Integer
data TestMeta
TM :: Maybe String -> Map String Dynamic -> TestMeta
[_tmAnswer] :: TestMeta -> Maybe String
[_tmData] :: TestMeta -> Map String Dynamic
parseMeta :: Parser TestMeta
parseTests :: Parser [(String, TestMeta)]
instance GHC.Show.Show AOC.Run.Load.MetaLine
instance GHC.Show.Show AOC.Run.Load.TestMeta
instance GHC.Show.Show AOC.Run.Load.ChallengePaths


-- | Run actions regarding challenges, solutions, tests, submissions,
--   viewing prompts, etc.
--   
--   Essentially implements the functionality of the main app.
module AOC.Run

-- | Specification of parts to test and run
data TestSpec
TSAll :: TestSpec
TSDayAll :: Day -> TestSpec
[_tsDay] :: TestSpec -> Day
TSDayPart :: ChallengeSpec -> TestSpec
[_tsSpec] :: TestSpec -> ChallengeSpec

-- | Options for <a>mainRun</a>.
data MainRunOpts
MRO :: !TestSpec -> !Bool -> !Bool -> !Bool -> !Bool -> !Day -> Part -> IO (Maybe String) -> MainRunOpts
[_mroSpec] :: MainRunOpts -> !TestSpec

-- | Run input? (Defualt: True
[_mroActual] :: MainRunOpts -> !Bool

-- | Run tests? (Default: False)
[_mroTest] :: MainRunOpts -> !Bool

-- | Benchmark? (Default: False)
[_mroBench] :: MainRunOpts -> !Bool

-- | Lock in answer as correct? (Default: False)
[_mroLock] :: MainRunOpts -> !Bool

-- | Manually supply input (Default: always return Nothing)
[_mroInput] :: MainRunOpts -> !Day -> Part -> IO (Maybe String)
class HasMainRunOpts c_a24Jk
mainRunOpts :: HasMainRunOpts c_a24Jk => Lens' c_a24Jk MainRunOpts
mroActual :: HasMainRunOpts c_a24Jk => Lens' c_a24Jk Bool
mroBench :: HasMainRunOpts c_a24Jk => Lens' c_a24Jk Bool
mroInput :: HasMainRunOpts c_a24Jk => Lens' c_a24Jk (Day -> Part -> IO (Maybe String))
mroLock :: HasMainRunOpts c_a24Jk => Lens' c_a24Jk Bool
mroSpec :: HasMainRunOpts c_a24Jk => Lens' c_a24Jk TestSpec
mroTest :: HasMainRunOpts c_a24Jk => Lens' c_a24Jk Bool

-- | Run, test, bench.
mainRun :: (MonadIO m, MonadError [String] m) => Config -> MainRunOpts -> m (Map Day (Map Part (Maybe Bool, Either [String] String)))

-- | Default options for <a>mainRun</a>.
defaultMRO :: TestSpec -> MainRunOpts

-- | Options for <a>mainView</a>.
data MainViewOpts
MVO :: !TestSpec -> !Bool -> MainViewOpts
[_mvoSpec] :: MainViewOpts -> !TestSpec
[_mvoWait] :: MainViewOpts -> !Bool
class HasMainViewOpts c_a24QN
mainViewOpts :: HasMainViewOpts c_a24QN => Lens' c_a24QN MainViewOpts
mvoSpec :: HasMainViewOpts c_a24QN => Lens' c_a24QN TestSpec
mvoWait :: HasMainViewOpts c_a24QN => Lens' c_a24QN Bool

-- | View prompt
mainView :: (MonadIO m, MonadError [String] m) => Config -> MainViewOpts -> m (Map Day (Map Part Text))

-- | Default options for <a>mainView</a>.
defaultMVO :: TestSpec -> MainViewOpts

-- | Options for <a>mainSubmit</a>
data MainSubmitOpts
MSO :: !ChallengeSpec -> !Bool -> !Bool -> !Bool -> MainSubmitOpts
[_msoSpec] :: MainSubmitOpts -> !ChallengeSpec

-- | Run tests before submitting? (Default: True)
[_msoTest] :: MainSubmitOpts -> !Bool

-- | Force submission even if bad? (Default: False)
[_msoForce] :: MainSubmitOpts -> !Bool

-- | Lock answer if submission succeeded? (Default: True)
[_msoLock] :: MainSubmitOpts -> !Bool
class HasMainSubmitOpts c_a24V4
mainSubmitOpts :: HasMainSubmitOpts c_a24V4 => Lens' c_a24V4 MainSubmitOpts
msoForce :: HasMainSubmitOpts c_a24V4 => Lens' c_a24V4 Bool
msoLock :: HasMainSubmitOpts c_a24V4 => Lens' c_a24V4 Bool
msoSpec :: HasMainSubmitOpts c_a24V4 => Lens' c_a24V4 ChallengeSpec
msoTest :: HasMainSubmitOpts c_a24V4 => Lens' c_a24V4 Bool

-- | Submit and analyze result
mainSubmit :: (MonadIO m, MonadError [String] m) => Config -> MainSubmitOpts -> m (Text, SubmitRes)

-- | Default options for <a>mainSubmit</a>.
defaultMSO :: ChallengeSpec -> MainSubmitOpts

-- | Do the action with a given ANSI foreground color and intensity.
withColor :: ColorIntensity -> Color -> IO () -> IO ()
instance AOC.Run.HasMainSubmitOpts AOC.Run.MainSubmitOpts
instance GHC.Show.Show AOC.Run.MainSubmitOpts
instance AOC.Run.HasMainViewOpts AOC.Run.MainViewOpts
instance GHC.Show.Show AOC.Run.MainViewOpts
instance AOC.Run.HasMainRunOpts AOC.Run.MainRunOpts
instance GHC.Show.Show AOC.Run.TestSpec


-- | Versions of loaders and runners meant to be used in GHCI.
module AOC.Run.Interactive

-- | Run the solution indicated by the challenge spec on the official
--   puzzle input. Get answer as result.
execSolution :: ChallengeSpec -> IO String

-- | Run the solution indicated by the challenge spec on a custom input.
--   Get answer as result.
execSolutionWith :: ChallengeSpec -> String -> IO String

-- | Run test suite for a given challenge spec.
--   
--   Returns <a>Just</a> if any tests were run, with a <a>Bool</a>
--   specifying whether or not all tests passed.
testSolution :: ChallengeSpec -> IO (Maybe Bool)

-- | View the prompt for a given challenge spec.
viewPrompt :: ChallengeSpec -> IO Text

-- | Countdown to get the prompt for a given challenge spec, if not yet
--   available.
waitForPrompt :: ChallengeSpec -> IO Text

-- | Submit solution for a given challenge spec, and lock if correct.
submitSolution :: ChallengeSpec -> IO (Text, SubmitRes)

-- | Result-suppressing version of <a>execSolution</a>.
execSolution_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>execSolutionWith</a>.
execSolutionWith_ :: ChallengeSpec -> String -> IO ()

-- | Result-suppressing version of <a>testSolution</a>.
testSolution_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>viewPrompt</a>.
viewPrompt_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>waitForPrompt</a>.
waitForPrompt_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>submitSolution</a>.
submitSolution_ :: ChallengeSpec -> IO ()

-- | Load input for a given challenge
loadInput :: ChallengeSpec -> IO String

-- | Run the parser of a solution, given its <a>ChallengeSpec</a>.
--   
--   <pre>
--   <a>loadParseInput</a> (solSpec 'day01a) day01a
--   </pre>
loadParseInput :: ChallengeSpec -> (a :~> b) -> IO a

-- | Load test cases for a given challenge
loadTests :: ChallengeSpec -> IO [(String, TestMeta)]

-- | Run the parser of a solution on test data, given its
--   <a>ChallengeSpec</a>.
--   
--   <pre>
--   <a>loadParseTests</a> (solSpec 'day01a) day01a
--   </pre>
loadParseTests :: ChallengeSpec -> (a :~> b) -> IO [(Maybe a, TestMeta)]

-- | Unsafely create a <a>ChallengeSpec</a> from a day number and part.
--   
--   Is undefined if given a day number out of range (1-25).
mkSpec :: Integer -> Part -> ChallengeSpec


-- | Single-stop entry point for the library's functionality and all
--   challenge solutions.
module AOC
